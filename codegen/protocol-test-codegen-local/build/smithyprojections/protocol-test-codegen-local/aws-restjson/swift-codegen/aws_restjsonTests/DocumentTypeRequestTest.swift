// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import AWSClientRuntime
import ClientRuntime
import SmithyTestUtil
import XCTest


class DocumentTypeRequestTest: HttpRequestTestBase {
    /// Serializes document types as part of the JSON request payload with no escaping.
    func testDocumentTypeInputWithObject() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .put,
            path: "/DocumentType",
            headers: [
                "Content-Type": "application/json"
            ],
            body: """
            {
                "stringValue": "string",
                "documentValue": {
                    "foo": "bar"
                }
            }
            """,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = DocumentTypeInput(
            documentValue: try decoder.decode(Document.self, from:
                """
                {
                    "foo": "bar"
                }
                """.data(using: .utf8)!)
                ,
                stringValue: "string"
            )
            let encoder = ClientRuntime.JSONEncoder()
            encoder.dateEncodingStrategy = .secondsSince1970
            encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let context = HttpContextBuilder()
                          .withEncoder(value: encoder)
                          .withMethod(value: .put)
                          .build()
            var operationStack = OperationStack<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(id: "DocumentTypeInputWithObject")
            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(urlPrefix: urlPrefix))
            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(host: hostOnly))
            operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeOutputResponse> in
                input.withMethod(context.getMethod())
                input.withPath(context.getPath())
                let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                input.withHost(host)
                return try await next.handle(context: context, input: input)
            }
            operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(contentType: "application/json"))
            operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>())
            operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
            operationStack.deserializeStep.intercept(position: .after,
                         middleware: MockDeserializeMiddleware<DocumentTypeOutputResponse, DocumentTypeOutputError>(
                                 id: "TestDeserializeMiddleware"){ context, actual in
                self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                    XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                    XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                    self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                        do {
                            let expectedObj = try decoder.decode(DocumentTypeInputBody.self, from: expectedData)
                            let actualObj = try decoder.decode(DocumentTypeInputBody.self, from: actualData)
                            XCTAssertEqual(expectedObj.stringValue, actualObj.stringValue)
                            XCTAssertEqual(expectedObj.documentValue, actualObj.documentValue)
                        } catch let err {
                            XCTFail("Failed to verify body \(err)")
                        }
                    }
                })
                let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                let mockOutput = try! DocumentTypeOutputResponse(httpResponse: response, decoder: nil)
                let output = OperationOutput<DocumentTypeOutputResponse>(httpResponse: response, output: mockOutput)
                return output
            })
            _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                XCTFail("Deserialize was mocked out, this should fail")
                let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                let serviceError = try! DocumentTypeOutputError(httpResponse: httpResponse)
                throw SdkError<DocumentTypeOutputError>.service(serviceError, httpResponse)
            })
        }
        /// Serializes document types using a string.
        func testDocumentInputWithString() async throws {
            let urlPrefix = urlPrefixFromHost(host: "")
            let hostOnly = hostOnlyFromHost(host: "")
            let expected = buildExpectedHttpRequest(
                method: .put,
                path: "/DocumentType",
                headers: [
                    "Content-Type": "application/json"
                ],
                body: """
                {
                    "stringValue": "string",
                    "documentValue": "hello"
                }
                """,
                host: "",
                resolvedHost: ""
            )

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

            let input = DocumentTypeInput(
                documentValue: try decoder.decode(Document.self, from:
                    """
                    "hello"
                    """.data(using: .utf8)!)
                    ,
                    stringValue: "string"
                )
                let encoder = ClientRuntime.JSONEncoder()
                encoder.dateEncodingStrategy = .secondsSince1970
                encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                let context = HttpContextBuilder()
                              .withEncoder(value: encoder)
                              .withMethod(value: .put)
                              .build()
                var operationStack = OperationStack<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(id: "DocumentInputWithString")
                operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(urlPrefix: urlPrefix))
                operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(host: hostOnly))
                operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeOutputResponse> in
                    input.withMethod(context.getMethod())
                    input.withPath(context.getPath())
                    let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                    input.withHost(host)
                    return try await next.handle(context: context, input: input)
                }
                operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(contentType: "application/json"))
                operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>())
                operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
                operationStack.deserializeStep.intercept(position: .after,
                             middleware: MockDeserializeMiddleware<DocumentTypeOutputResponse, DocumentTypeOutputError>(
                                     id: "TestDeserializeMiddleware"){ context, actual in
                    self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                        XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                        XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                        self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                            do {
                                let expectedObj = try decoder.decode(DocumentTypeInputBody.self, from: expectedData)
                                let actualObj = try decoder.decode(DocumentTypeInputBody.self, from: actualData)
                                XCTAssertEqual(expectedObj.stringValue, actualObj.stringValue)
                                XCTAssertEqual(expectedObj.documentValue, actualObj.documentValue)
                            } catch let err {
                                XCTFail("Failed to verify body \(err)")
                            }
                        }
                    })
                    let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                    let mockOutput = try! DocumentTypeOutputResponse(httpResponse: response, decoder: nil)
                    let output = OperationOutput<DocumentTypeOutputResponse>(httpResponse: response, output: mockOutput)
                    return output
                })
                _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                    XCTFail("Deserialize was mocked out, this should fail")
                    let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                    let serviceError = try! DocumentTypeOutputError(httpResponse: httpResponse)
                    throw SdkError<DocumentTypeOutputError>.service(serviceError, httpResponse)
                })
            }
            /// Serializes document types using a number.
            func testDocumentInputWithNumber() async throws {
                let urlPrefix = urlPrefixFromHost(host: "")
                let hostOnly = hostOnlyFromHost(host: "")
                let expected = buildExpectedHttpRequest(
                    method: .put,
                    path: "/DocumentType",
                    headers: [
                        "Content-Type": "application/json"
                    ],
                    body: """
                    {
                        "stringValue": "string",
                        "documentValue": 10
                    }
                    """,
                    host: "",
                    resolvedHost: ""
                )

                let decoder = ClientRuntime.JSONDecoder()
                decoder.dateDecodingStrategy = .secondsSince1970
                decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

                let input = DocumentTypeInput(
                    documentValue: try decoder.decode(Document.self, from:
                        """
                        10
                        """.data(using: .utf8)!)
                        ,
                        stringValue: "string"
                    )
                    let encoder = ClientRuntime.JSONEncoder()
                    encoder.dateEncodingStrategy = .secondsSince1970
                    encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                    let context = HttpContextBuilder()
                                  .withEncoder(value: encoder)
                                  .withMethod(value: .put)
                                  .build()
                    var operationStack = OperationStack<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(id: "DocumentInputWithNumber")
                    operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(urlPrefix: urlPrefix))
                    operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(host: hostOnly))
                    operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeOutputResponse> in
                        input.withMethod(context.getMethod())
                        input.withPath(context.getPath())
                        let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                        input.withHost(host)
                        return try await next.handle(context: context, input: input)
                    }
                    operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(contentType: "application/json"))
                    operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>())
                    operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
                    operationStack.deserializeStep.intercept(position: .after,
                                 middleware: MockDeserializeMiddleware<DocumentTypeOutputResponse, DocumentTypeOutputError>(
                                         id: "TestDeserializeMiddleware"){ context, actual in
                        self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                            XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                            XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                            self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                                do {
                                    let expectedObj = try decoder.decode(DocumentTypeInputBody.self, from: expectedData)
                                    let actualObj = try decoder.decode(DocumentTypeInputBody.self, from: actualData)
                                    XCTAssertEqual(expectedObj.stringValue, actualObj.stringValue)
                                    XCTAssertEqual(expectedObj.documentValue, actualObj.documentValue)
                                } catch let err {
                                    XCTFail("Failed to verify body \(err)")
                                }
                            }
                        })
                        let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                        let mockOutput = try! DocumentTypeOutputResponse(httpResponse: response, decoder: nil)
                        let output = OperationOutput<DocumentTypeOutputResponse>(httpResponse: response, output: mockOutput)
                        return output
                    })
                    _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                        XCTFail("Deserialize was mocked out, this should fail")
                        let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                        let serviceError = try! DocumentTypeOutputError(httpResponse: httpResponse)
                        throw SdkError<DocumentTypeOutputError>.service(serviceError, httpResponse)
                    })
                }
                /// Serializes document types using a boolean.
                func testDocumentInputWithBoolean() async throws {
                    let urlPrefix = urlPrefixFromHost(host: "")
                    let hostOnly = hostOnlyFromHost(host: "")
                    let expected = buildExpectedHttpRequest(
                        method: .put,
                        path: "/DocumentType",
                        headers: [
                            "Content-Type": "application/json"
                        ],
                        body: """
                        {
                            "stringValue": "string",
                            "documentValue": true
                        }
                        """,
                        host: "",
                        resolvedHost: ""
                    )

                    let decoder = ClientRuntime.JSONDecoder()
                    decoder.dateDecodingStrategy = .secondsSince1970
                    decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

                    let input = DocumentTypeInput(
                        documentValue: try decoder.decode(Document.self, from:
                            """
                            true
                            """.data(using: .utf8)!)
                            ,
                            stringValue: "string"
                        )
                        let encoder = ClientRuntime.JSONEncoder()
                        encoder.dateEncodingStrategy = .secondsSince1970
                        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                        let context = HttpContextBuilder()
                                      .withEncoder(value: encoder)
                                      .withMethod(value: .put)
                                      .build()
                        var operationStack = OperationStack<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(id: "DocumentInputWithBoolean")
                        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(urlPrefix: urlPrefix))
                        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(host: hostOnly))
                        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeOutputResponse> in
                            input.withMethod(context.getMethod())
                            input.withPath(context.getPath())
                            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                            input.withHost(host)
                            return try await next.handle(context: context, input: input)
                        }
                        operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(contentType: "application/json"))
                        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>())
                        operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
                        operationStack.deserializeStep.intercept(position: .after,
                                     middleware: MockDeserializeMiddleware<DocumentTypeOutputResponse, DocumentTypeOutputError>(
                                             id: "TestDeserializeMiddleware"){ context, actual in
                            self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                                XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                                XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                                self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                                    do {
                                        let expectedObj = try decoder.decode(DocumentTypeInputBody.self, from: expectedData)
                                        let actualObj = try decoder.decode(DocumentTypeInputBody.self, from: actualData)
                                        XCTAssertEqual(expectedObj.stringValue, actualObj.stringValue)
                                        XCTAssertEqual(expectedObj.documentValue, actualObj.documentValue)
                                    } catch let err {
                                        XCTFail("Failed to verify body \(err)")
                                    }
                                }
                            })
                            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                            let mockOutput = try! DocumentTypeOutputResponse(httpResponse: response, decoder: nil)
                            let output = OperationOutput<DocumentTypeOutputResponse>(httpResponse: response, output: mockOutput)
                            return output
                        })
                        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                            XCTFail("Deserialize was mocked out, this should fail")
                            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                            let serviceError = try! DocumentTypeOutputError(httpResponse: httpResponse)
                            throw SdkError<DocumentTypeOutputError>.service(serviceError, httpResponse)
                        })
                    }
                    /// Serializes document types using a list.
                    func testDocumentInputWithList() async throws {
                        let urlPrefix = urlPrefixFromHost(host: "")
                        let hostOnly = hostOnlyFromHost(host: "")
                        let expected = buildExpectedHttpRequest(
                            method: .put,
                            path: "/DocumentType",
                            headers: [
                                "Content-Type": "application/json"
                            ],
                            body: """
                            {
                                "stringValue": "string",
                                "documentValue": [
                                    true,
                                    "hi",
                                    [
                                        1,
                                        2
                                    ],
                                    {
                                        "foo": {
                                            "baz": [
                                                3,
                                                4
                                            ]
                                        }
                                    }
                                ]
                            }
                            """,
                            host: "",
                            resolvedHost: ""
                        )

                        let decoder = ClientRuntime.JSONDecoder()
                        decoder.dateDecodingStrategy = .secondsSince1970
                        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

                        let input = DocumentTypeInput(
                            documentValue: try decoder.decode(Document.self, from:
                                """
                                [
                                    true,
                                    "hi",
                                    [
                                        1,
                                        2
                                    ],
                                    {
                                        "foo": {
                                            "baz": [
                                                3,
                                                4
                                            ]
                                        }
                                    }
                                ]
                                """.data(using: .utf8)!)
                                ,
                                stringValue: "string"
                            )
                            let encoder = ClientRuntime.JSONEncoder()
                            encoder.dateEncodingStrategy = .secondsSince1970
                            encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                            let context = HttpContextBuilder()
                                          .withEncoder(value: encoder)
                                          .withMethod(value: .put)
                                          .build()
                            var operationStack = OperationStack<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(id: "DocumentInputWithList")
                            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeInput, DocumentTypeOutputResponse, DocumentTypeOutputError>(urlPrefix: urlPrefix))
                            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(host: hostOnly))
                            operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeOutputResponse> in
                                input.withMethod(context.getMethod())
                                input.withPath(context.getPath())
                                let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                                input.withHost(host)
                                return try await next.handle(context: context, input: input)
                            }
                            operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>(contentType: "application/json"))
                            operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<DocumentTypeInput, DocumentTypeOutputResponse>())
                            operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
                            operationStack.deserializeStep.intercept(position: .after,
                                         middleware: MockDeserializeMiddleware<DocumentTypeOutputResponse, DocumentTypeOutputError>(
                                                 id: "TestDeserializeMiddleware"){ context, actual in
                                self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                                    XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                                    XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                                    self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                                        do {
                                            let expectedObj = try decoder.decode(DocumentTypeInputBody.self, from: expectedData)
                                            let actualObj = try decoder.decode(DocumentTypeInputBody.self, from: actualData)
                                            XCTAssertEqual(expectedObj.stringValue, actualObj.stringValue)
                                            XCTAssertEqual(expectedObj.documentValue, actualObj.documentValue)
                                        } catch let err {
                                            XCTFail("Failed to verify body \(err)")
                                        }
                                    }
                                })
                                let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                                let mockOutput = try! DocumentTypeOutputResponse(httpResponse: response, decoder: nil)
                                let output = OperationOutput<DocumentTypeOutputResponse>(httpResponse: response, output: mockOutput)
                                return output
                            })
                            _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                                XCTFail("Deserialize was mocked out, this should fail")
                                let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                                let serviceError = try! DocumentTypeOutputError(httpResponse: httpResponse)
                                throw SdkError<DocumentTypeOutputError>.service(serviceError, httpResponse)
                            })
                        }
                    }
