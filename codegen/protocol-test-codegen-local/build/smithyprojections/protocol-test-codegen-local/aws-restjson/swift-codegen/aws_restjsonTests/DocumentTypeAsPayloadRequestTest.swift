// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import AWSClientRuntime
import ClientRuntime
import SmithyTestUtil
import XCTest


class DocumentTypeAsPayloadRequestTest: HttpRequestTestBase {
    /// Serializes a document as the target of the httpPayload trait.
    func testDocumentTypeAsPayloadInput() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .put,
            path: "/DocumentTypeAsPayload",
            headers: [
                "Content-Type": "application/json"
            ],
            body: """
            {
                "foo": "bar"
            }
            """,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = DocumentTypeAsPayloadInput(
            documentValue: try decoder.decode(Document.self, from:
                """
                {
                    "foo": "bar"
                }
                """.data(using: .utf8)!)

            )
            let encoder = ClientRuntime.JSONEncoder()
            encoder.dateEncodingStrategy = .secondsSince1970
            encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let context = HttpContextBuilder()
                          .withEncoder(value: encoder)
                          .withMethod(value: .put)
                          .build()
            var operationStack = OperationStack<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(id: "DocumentTypeAsPayloadInput")
            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(urlPrefix: urlPrefix))
            operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse>(host: hostOnly))
            operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeAsPayloadOutputResponse> in
                input.withMethod(context.getMethod())
                input.withPath(context.getPath())
                let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                input.withHost(host)
                return try await next.handle(context: context, input: input)
            }
            operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse>(contentType: "application/json"))
            operationStack.serializeStep.intercept(position: .after, middleware: DocumentTypeAsPayloadInputBodyMiddleware())
            operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
            operationStack.deserializeStep.intercept(position: .after,
                         middleware: MockDeserializeMiddleware<DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(
                                 id: "TestDeserializeMiddleware"){ context, actual in
                self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                    XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                    XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                    self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                        do {
                            let expectedObj = try decoder.decode(ClientRuntime.Document.self, from: expectedData)
                            let actualObj = try decoder.decode(ClientRuntime.Document.self, from: actualData)
                            XCTAssertEqual(expectedObj, actualObj)
                        } catch let err {
                            XCTFail("Failed to verify body \(err)")
                        }
                    }
                })
                let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                let mockOutput = try! DocumentTypeAsPayloadOutputResponse(httpResponse: response, decoder: nil)
                let output = OperationOutput<DocumentTypeAsPayloadOutputResponse>(httpResponse: response, output: mockOutput)
                return output
            })
            _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                XCTFail("Deserialize was mocked out, this should fail")
                let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                let serviceError = try! DocumentTypeAsPayloadOutputError(httpResponse: httpResponse)
                throw SdkError<DocumentTypeAsPayloadOutputError>.service(serviceError, httpResponse)
            })
        }
        /// Serializes a document as the target of the httpPayload trait using a string.
        func testDocumentTypeAsPayloadInputString() async throws {
            let urlPrefix = urlPrefixFromHost(host: "")
            let hostOnly = hostOnlyFromHost(host: "")
            let expected = buildExpectedHttpRequest(
                method: .put,
                path: "/DocumentTypeAsPayload",
                headers: [
                    "Content-Type": "application/json"
                ],
                body: """
                "hello"
                """,
                host: "",
                resolvedHost: ""
            )

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

            let input = DocumentTypeAsPayloadInput(
                documentValue: try decoder.decode(Document.self, from:
                    """
                    "hello"
                    """.data(using: .utf8)!)

                )
                let encoder = ClientRuntime.JSONEncoder()
                encoder.dateEncodingStrategy = .secondsSince1970
                encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                let context = HttpContextBuilder()
                              .withEncoder(value: encoder)
                              .withMethod(value: .put)
                              .build()
                var operationStack = OperationStack<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(id: "DocumentTypeAsPayloadInputString")
                operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(urlPrefix: urlPrefix))
                operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse>(host: hostOnly))
                operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<DocumentTypeAsPayloadOutputResponse> in
                    input.withMethod(context.getMethod())
                    input.withPath(context.getPath())
                    let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
                    input.withHost(host)
                    return try await next.handle(context: context, input: input)
                }
                operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<DocumentTypeAsPayloadInput, DocumentTypeAsPayloadOutputResponse>(contentType: "application/json"))
                operationStack.serializeStep.intercept(position: .after, middleware: DocumentTypeAsPayloadInputBodyMiddleware())
                operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
                operationStack.deserializeStep.intercept(position: .after,
                             middleware: MockDeserializeMiddleware<DocumentTypeAsPayloadOutputResponse, DocumentTypeAsPayloadOutputError>(
                                     id: "TestDeserializeMiddleware"){ context, actual in
                    self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                        XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                        XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                        self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                            do {
                                let expectedObj = try decoder.decode(ClientRuntime.Document.self, from: expectedData)
                                let actualObj = try decoder.decode(ClientRuntime.Document.self, from: actualData)
                                XCTAssertEqual(expectedObj, actualObj)
                            } catch let err {
                                XCTFail("Failed to verify body \(err)")
                            }
                        }
                    })
                    let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
                    let mockOutput = try! DocumentTypeAsPayloadOutputResponse(httpResponse: response, decoder: nil)
                    let output = OperationOutput<DocumentTypeAsPayloadOutputResponse>(httpResponse: response, output: mockOutput)
                    return output
                })
                _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
                    XCTFail("Deserialize was mocked out, this should fail")
                    let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
                    let serviceError = try! DocumentTypeAsPayloadOutputError(httpResponse: httpResponse)
                    throw SdkError<DocumentTypeAsPayloadOutputError>.service(serviceError, httpResponse)
                })
            }
        }
