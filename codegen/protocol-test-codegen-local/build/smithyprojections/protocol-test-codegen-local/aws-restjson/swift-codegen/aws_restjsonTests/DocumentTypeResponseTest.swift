// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import ClientRuntime
import SmithyTestUtil
import XCTest


class DocumentTypeResponseTest: HttpResponseTestBase {
    /// Serializes documents as part of the JSON response payload with no escaping.
    func testDocumentOutput() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "stringValue": "string",
                "documentValue": {
                    "foo": "bar"
                }
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try DocumentTypeOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = DocumentTypeOutputResponse(
            documentValue: try decoder.decode(Document.self, from:
                """
                {
                    "foo": "bar"
                }
                """.data(using: .utf8)!)
                ,
                stringValue: "string"
            )

            XCTAssertEqual(expected.stringValue, actual.stringValue)
            XCTAssertEqual(expected.documentValue, actual.documentValue)

        }
        /// Document types can be JSON scalars too.
        func testDocumentOutputString() async throws {
            guard let httpResponse = buildHttpResponse(
                code: 200,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "stringValue": "string",
                    "documentValue": "hello"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let actual = try DocumentTypeOutputResponse(httpResponse: httpResponse, decoder: decoder)

            let expected = DocumentTypeOutputResponse(
                documentValue: try decoder.decode(Document.self, from:
                    """
                    "hello"
                    """.data(using: .utf8)!)
                    ,
                    stringValue: "string"
                )

                XCTAssertEqual(expected.stringValue, actual.stringValue)
                XCTAssertEqual(expected.documentValue, actual.documentValue)

            }
            /// Document types can be JSON scalars too.
            func testDocumentOutputNumber() async throws {
                guard let httpResponse = buildHttpResponse(
                    code: 200,
                    headers: [
                        "Content-Type": "application/json"
                    ],
                    content: HttpBody.stream(ByteStream.from(data: """
                    {
                        "stringValue": "string",
                        "documentValue": 10
                    }
                    """.data(using: .utf8)!))
                ) else {
                    XCTFail("Something is wrong with the created http response")
                    return
                }

                let decoder = ClientRuntime.JSONDecoder()
                decoder.dateDecodingStrategy = .secondsSince1970
                decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                let actual = try DocumentTypeOutputResponse(httpResponse: httpResponse, decoder: decoder)

                let expected = DocumentTypeOutputResponse(
                    documentValue: try decoder.decode(Document.self, from:
                        """
                        10
                        """.data(using: .utf8)!)
                        ,
                        stringValue: "string"
                    )

                    XCTAssertEqual(expected.stringValue, actual.stringValue)
                    XCTAssertEqual(expected.documentValue, actual.documentValue)

                }
                /// Document types can be JSON scalars too.
                func testDocumentOutputBoolean() async throws {
                    guard let httpResponse = buildHttpResponse(
                        code: 200,
                        headers: [
                            "Content-Type": "application/json"
                        ],
                        content: HttpBody.stream(ByteStream.from(data: """
                        {
                            "stringValue": "string",
                            "documentValue": false
                        }
                        """.data(using: .utf8)!))
                    ) else {
                        XCTFail("Something is wrong with the created http response")
                        return
                    }

                    let decoder = ClientRuntime.JSONDecoder()
                    decoder.dateDecodingStrategy = .secondsSince1970
                    decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                    let actual = try DocumentTypeOutputResponse(httpResponse: httpResponse, decoder: decoder)

                    let expected = DocumentTypeOutputResponse(
                        documentValue: try decoder.decode(Document.self, from:
                            """
                            false
                            """.data(using: .utf8)!)
                            ,
                            stringValue: "string"
                        )

                        XCTAssertEqual(expected.stringValue, actual.stringValue)
                        XCTAssertEqual(expected.documentValue, actual.documentValue)

                    }
                    /// Document types can be JSON arrays.
                    func testDocumentOutputArray() async throws {
                        guard let httpResponse = buildHttpResponse(
                            code: 200,
                            headers: [
                                "Content-Type": "application/json"
                            ],
                            content: HttpBody.stream(ByteStream.from(data: """
                            {
                                "stringValue": "string",
                                "documentValue": [
                                    true,
                                    false
                                ]
                            }
                            """.data(using: .utf8)!))
                        ) else {
                            XCTFail("Something is wrong with the created http response")
                            return
                        }

                        let decoder = ClientRuntime.JSONDecoder()
                        decoder.dateDecodingStrategy = .secondsSince1970
                        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
                        let actual = try DocumentTypeOutputResponse(httpResponse: httpResponse, decoder: decoder)

                        let expected = DocumentTypeOutputResponse(
                            documentValue: try decoder.decode(Document.self, from:
                                """
                                [
                                    true,
                                    false
                                ]
                                """.data(using: .utf8)!)
                                ,
                                stringValue: "string"
                            )

                            XCTAssertEqual(expected.stringValue, actual.stringValue)
                            XCTAssertEqual(expected.documentValue, actual.documentValue)

                        }
                    }
