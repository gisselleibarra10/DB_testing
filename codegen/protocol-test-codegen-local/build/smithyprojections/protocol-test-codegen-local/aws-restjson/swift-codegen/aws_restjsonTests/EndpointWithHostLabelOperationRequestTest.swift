// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import AWSClientRuntime
import ClientRuntime
import SmithyTestUtil
import XCTest


class EndpointWithHostLabelOperationRequestTest: HttpRequestTestBase {
    /// Operations can prepend to the given host if they define the endpoint trait, and can use the host label trait to define further customization based on user input.
    func testRestJsonEndpointTraitWithHostLabel() async throws {
        let urlPrefix = urlPrefixFromHost(host: "example.com")
        let hostOnly = hostOnlyFromHost(host: "example.com")
        let expected = buildExpectedHttpRequest(
            method: .post,
            path: "/EndpointWithHostLabelOperation",
            body: """
            {"label": "bar"}
            """,
            host: "example.com",
            resolvedHost: "foo.bar.example.com"
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = EndpointWithHostLabelOperationInput(
            label: "bar"
        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .post)
                      .build()
        var operationStack = OperationStack<EndpointWithHostLabelOperationInput, EndpointWithHostLabelOperationOutputResponse, EndpointWithHostLabelOperationOutputError>(id: "RestJsonEndpointTraitWithHostLabel")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<EndpointWithHostLabelOperationInput, EndpointWithHostLabelOperationOutputResponse, EndpointWithHostLabelOperationOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<EndpointWithHostLabelOperationInput, EndpointWithHostLabelOperationOutputResponse>(host: hostOnly, hostPrefix: "foo.\(input.label!)."))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<EndpointWithHostLabelOperationOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<EndpointWithHostLabelOperationInput, EndpointWithHostLabelOperationOutputResponse>(contentType: "application/json"))
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.SerializableBodyMiddleware<EndpointWithHostLabelOperationInput, EndpointWithHostLabelOperationOutputResponse>())
        operationStack.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<EndpointWithHostLabelOperationOutputResponse, EndpointWithHostLabelOperationOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual, { (expectedHttpBody, actualHttpBody) -> Void in
                XCTAssertNotNil(actualHttpBody, "The actual HttpBody is nil")
                XCTAssertNotNil(expectedHttpBody, "The expected HttpBody is nil")
                self.genericAssertEqualHttpBodyData(expectedHttpBody!, actualHttpBody!) { expectedData, actualData in
                    do {
                        let expectedObj = try decoder.decode(EndpointWithHostLabelOperationInputBody.self, from: expectedData)
                        let actualObj = try decoder.decode(EndpointWithHostLabelOperationInputBody.self, from: actualData)
                        XCTAssertEqual(expectedObj.label, actualObj.label)
                    } catch let err {
                        XCTFail("Failed to verify body \(err)")
                    }
                }
            })
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! EndpointWithHostLabelOperationOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<EndpointWithHostLabelOperationOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! EndpointWithHostLabelOperationOutputError(httpResponse: httpResponse)
            throw SdkError<EndpointWithHostLabelOperationOutputError>.service(serviceError, httpResponse)
        })
    }
}
