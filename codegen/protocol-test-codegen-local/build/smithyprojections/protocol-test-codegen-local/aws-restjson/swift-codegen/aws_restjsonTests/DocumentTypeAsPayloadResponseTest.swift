// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import ClientRuntime
import SmithyTestUtil
import XCTest


class DocumentTypeAsPayloadResponseTest: HttpResponseTestBase {
    /// Serializes a document as the target of the httpPayload trait.
    func testDocumentTypeAsPayloadOutput() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "foo": "bar"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try DocumentTypeAsPayloadOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = DocumentTypeAsPayloadOutputResponse(
            documentValue: try decoder.decode(Document.self, from:
                """
                {
                    "foo": "bar"
                }
                """.data(using: .utf8)!)

            )

            XCTAssertEqual(expected.documentValue, actual.documentValue)

        }
        /// Serializes a document as a payload string.
        func testDocumentTypeAsPayloadOutputString() async throws {
            guard let httpResponse = buildHttpResponse(
                code: 200,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                "hello"
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let actual = try DocumentTypeAsPayloadOutputResponse(httpResponse: httpResponse, decoder: decoder)

            let expected = DocumentTypeAsPayloadOutputResponse(
                documentValue: try decoder.decode(Document.self, from:
                    """
                    "hello"
                    """.data(using: .utf8)!)

                )

                XCTAssertEqual(expected.documentValue, actual.documentValue)

            }
        }
