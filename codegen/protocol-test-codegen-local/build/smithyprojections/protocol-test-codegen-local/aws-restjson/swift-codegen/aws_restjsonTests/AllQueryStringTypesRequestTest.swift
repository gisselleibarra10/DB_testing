// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import AWSClientRuntime
import ClientRuntime
import SmithyTestUtil
import XCTest


class AllQueryStringTypesRequestTest: HttpRequestTestBase {
    /// Serializes query string parameters with all supported types
    func testRestJsonAllQueryStringTypes() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "String=Hello%20there",
                "StringList=a",
                "StringList=b",
                "StringList=c",
                "StringSet=a",
                "StringSet=b",
                "StringSet=c",
                "Byte=1",
                "Short=2",
                "Integer=3",
                "IntegerList=1",
                "IntegerList=2",
                "IntegerList=3",
                "IntegerSet=1",
                "IntegerSet=2",
                "IntegerSet=3",
                "Long=4",
                "Float=1.1",
                "Double=1.1",
                "DoubleList=1.1",
                "DoubleList=2.1",
                "DoubleList=3.1",
                "Boolean=true",
                "BooleanList=true",
                "BooleanList=false",
                "BooleanList=true",
                "Timestamp=1970-01-01T00%3A00%3A01Z",
                "TimestampList=1970-01-01T00%3A00%3A01Z",
                "TimestampList=1970-01-01T00%3A00%3A02Z",
                "TimestampList=1970-01-01T00%3A00%3A03Z",
                "Enum=Foo",
                "EnumList=Foo",
                "EnumList=Baz",
                "EnumList=Bar",
                "IntegerEnum=1",
                "IntegerEnumList=1",
                "IntegerEnumList=2",
                "IntegerEnumList=3"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryBoolean: true,
            queryBooleanList: [
                true,
                false,
                true
            ],
            queryByte: 1,
            queryDouble: 1.1,
            queryDoubleList: [
                1.1,
                2.1,
                3.1
            ],
            queryEnum: RestJsonClientTypes.FooEnum(rawValue: "Foo")!,
            queryEnumList: [
                RestJsonClientTypes.FooEnum(rawValue: "Foo")!,
                RestJsonClientTypes.FooEnum(rawValue: "Baz")!,
                RestJsonClientTypes.FooEnum(rawValue: "Bar")!
            ],
            queryFloat: 1.1,
            queryInteger: 3,
            queryIntegerEnum: IntegerEnum(rawValue: 1),
            queryIntegerEnumList: [
                IntegerEnum(rawValue: 1),
                IntegerEnum(rawValue: 2),
                IntegerEnum(rawValue: 3)
            ],
            queryIntegerList: [
                1,
                2,
                3
            ],
            queryIntegerSet: [
                1,
                2,
                3
            ],
            queryLong: 4,
            queryShort: 2,
            queryString: "Hello there",
            queryStringList: [
                "a",
                "b",
                "c"
            ],
            queryStringSet: [
                "a",
                "b",
                "c"
            ],
            queryTimestamp: Date(timeIntervalSince1970: 1),
            queryTimestampList: [
                Date(timeIntervalSince1970: 1),
                Date(timeIntervalSince1970: 2),
                Date(timeIntervalSince1970: 3)
            ]
        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonAllQueryStringTypes")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
    /// Handles query string maps
    func testRestJsonQueryStringMap() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "QueryParamsStringKeyA=Foo",
                "QueryParamsStringKeyB=Bar"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryParamsMapOfStringList: [
                "QueryParamsStringKeyA": [
                    "Foo"
                ],
                "QueryParamsStringKeyB": [
                    "Bar"
                ]]

        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonQueryStringMap")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
    /// Handles escaping all required characters in the query string.
    func testRestJsonQueryStringEscaping() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "String=%25%3A%2F%3F%23%5B%5D%40%21%24%26%27%28%29%2A%2B%2C%3B%3D%F0%9F%98%B9"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryString: "%:/?#[]@!$&'()*+,;=ðŸ˜¹"
        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonQueryStringEscaping")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
    /// Supports handling NaN float query values.
    func testRestJsonSupportsNaNFloatQueryValues() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "Float=NaN",
                "Double=NaN"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryDouble: Swift.Double.nan,
            queryFloat: Swift.Float.nan,
            queryParamsMapOfStringList: [
                "Double": [
                    "NaN"
                ],
                "Float": [
                    "NaN"
                ]]

        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonSupportsNaNFloatQueryValues")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
    /// Supports handling Infinity float query values.
    func testRestJsonSupportsInfinityFloatQueryValues() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "Float=Infinity",
                "Double=Infinity"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryDouble: Swift.Double.infinity,
            queryFloat: Swift.Float.infinity,
            queryParamsMapOfStringList: [
                "Double": [
                    "Infinity"
                ],
                "Float": [
                    "Infinity"
                ]]

        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonSupportsInfinityFloatQueryValues")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
    /// Supports handling -Infinity float query values.
    func testRestJsonSupportsNegativeInfinityFloatQueryValues() async throws {
        let urlPrefix = urlPrefixFromHost(host: "")
        let hostOnly = hostOnlyFromHost(host: "")
        let expected = buildExpectedHttpRequest(
            method: .get,
            path: "/AllQueryStringTypesInput",
            queryParams: [
                "Float=-Infinity",
                "Double=-Infinity"
            ],
            body: nil,
            host: "",
            resolvedHost: ""
        )

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")

        let input = AllQueryStringTypesInput(
            queryDouble: -Swift.Double.infinity,
            queryFloat: -Swift.Float.infinity,
            queryParamsMapOfStringList: [
                "Double": [
                    "-Infinity"
                ],
                "Float": [
                    "-Infinity"
                ]]

        )
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withMethod(value: .get)
                      .build()
        var operationStack = OperationStack<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(id: "RestJsonSupportsNegativeInfinityFloatQueryValues")
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(urlPrefix: urlPrefix))
        operationStack.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>(host: hostOnly))
        operationStack.buildStep.intercept(position: .after, id: "RequestTestEndpointResolver") { (context, input, next) -> ClientRuntime.OperationOutput<AllQueryStringTypesOutputResponse> in
            input.withMethod(context.getMethod())
            input.withPath(context.getPath())
            let host = "\(context.getHostPrefix() ?? "")\(context.getHost() ?? "")"
            input.withHost(host)
            return try await next.handle(context: context, input: input)
        }
        operationStack.serializeStep.intercept(position: .after, middleware: ClientRuntime.QueryItemMiddleware<AllQueryStringTypesInput, AllQueryStringTypesOutputResponse>())
        operationStack.deserializeStep.intercept(position: .after,
                     middleware: MockDeserializeMiddleware<AllQueryStringTypesOutputResponse, AllQueryStringTypesOutputError>(
                             id: "TestDeserializeMiddleware"){ context, actual in
            self.assertEqual(expected, actual)
            let response = HttpResponse(body: HttpBody.none, statusCode: .ok)
            let mockOutput = try! AllQueryStringTypesOutputResponse(httpResponse: response, decoder: nil)
            let output = OperationOutput<AllQueryStringTypesOutputResponse>(httpResponse: response, output: mockOutput)
            return output
        })
        _ = try await operationStack.handleMiddleware(context: context, input: input, next: MockHandler(){ (context, request) in
            XCTFail("Deserialize was mocked out, this should fail")
            let httpResponse = HttpResponse(body: .none, statusCode: .badRequest)
            let serviceError = try! AllQueryStringTypesOutputError(httpResponse: httpResponse)
            throw SdkError<AllQueryStringTypesOutputError>.service(serviceError, httpResponse)
        })
    }
}
