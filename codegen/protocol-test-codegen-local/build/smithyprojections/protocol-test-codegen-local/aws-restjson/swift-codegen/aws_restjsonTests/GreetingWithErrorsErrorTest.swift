// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import ClientRuntime
import SmithyTestUtil
import XCTest


class GreetingWithErrorsInvalidGreetingTest: HttpResponseTestBase {
    /// Parses simple JSON errors
    func testRestJsonInvalidGreetingError() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 400,
                headers: [
                    "Content-Type": "application/json",
                    "X-Amzn-Errortype": "InvalidGreeting"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "Message": "Hi"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .invalidGreeting(let actual) = greetingWithErrorsOutputError {

                let expected = InvalidGreeting(
                    message: "Hi"
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 400))
                XCTAssertEqual(expected.message, actual.message)
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
}

class GreetingWithErrorsComplexErrorTest: HttpResponseTestBase {
    /// Serializes a complex error with no message member
    func testRestJsonComplexErrorWithNoMessage() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 403,
                headers: [
                    "Content-Type": "application/json",
                    "X-Amzn-Errortype": "ComplexError",
                    "X-Header": "Header"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "TopLevel": "Top level",
                    "Nested": {
                        "Fooooo": "bar"
                    }
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .complexError(let actual) = greetingWithErrorsOutputError {

                let expected = ComplexError(
                    header: "Header",
                    nested: RestJsonClientTypes.ComplexNestedErrorData(
                        foo: "bar"
                    ),
                    topLevel: "Top level"
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 403))
                XCTAssertEqual(expected.header, actual.header)
                XCTAssertEqual(expected.topLevel, actual.topLevel)
                XCTAssertEqual(expected.nested, actual.nested)
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    func testRestJsonEmptyComplexErrorWithNoMessage() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 403,
                headers: [
                    "Content-Type": "application/json",
                    "X-Amzn-Errortype": "ComplexError"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {}
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .complexError(let actual) = greetingWithErrorsOutputError {

                let expected = ComplexError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 403))
                XCTAssertEqual(expected.header, actual.header)
                XCTAssertEqual(expected.topLevel, actual.topLevel)
                XCTAssertEqual(expected.nested, actual.nested)
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
}

class GreetingWithErrorsFooErrorTest: HttpResponseTestBase {
    /// Serializes the X-Amzn-ErrorType header. For an example service, see Amazon EKS.
    func testRestJsonFooErrorUsingXAmznErrorType() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "X-Amzn-Errortype": "FooError"
                ],
                content: HttpBody.empty
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some X-Amzn-Errortype headers contain URLs. Clients need to split the URL on ':' and take only the first half of the string. For example, 'ValidationException:http://internal.amazon.com/coral/com.amazon.coral.validate/' is to be interpreted as 'ValidationException'. For an example service see Amazon Polly.
    func testRestJsonFooErrorUsingXAmznErrorTypeWithUri() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "X-Amzn-Errortype": "FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/"
                ],
                content: HttpBody.empty
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// X-Amzn-Errortype might contain a URL and a namespace. Client should extract only the shape name. This is a pathalogical case that might not actually happen in any deployed AWS service.
    func testRestJsonFooErrorUsingXAmznErrorTypeWithUriAndNamespace() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "X-Amzn-Errortype": "aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/"
                ],
                content: HttpBody.empty
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// This example uses the 'code' property in the output rather than X-Amzn-Errortype. Some services do this though it's preferable to send the X-Amzn-Errortype. Client implementations must first check for the X-Amzn-Errortype and then check for a top-level 'code' property. For example service see Amazon S3 Glacier.
    func testRestJsonFooErrorUsingCode() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "code": "FooError"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    func testRestJsonFooErrorUsingCodeAndNamespace() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "code": "aws.protocoltests.restjson#FooError"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some services serialize errors using code, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    func testRestJsonFooErrorUsingCodeUriAndNamespace() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "code": "aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some services serialize errors using __type.
    func testRestJsonFooErrorWithDunderType() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "__type": "FooError"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. Clients should just take the last part of the string after '#'.
    func testRestJsonFooErrorWithDunderTypeAndNamespace() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "__type": "aws.protocoltests.restjson#FooError"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
    /// Some services serialize errors using __type, and it might contain a namespace. It also might contain a URI. Clients should just take the last part of the string after '#' and before ":". This is a pathalogical case that might not occur in any deployed AWS service.
    func testRestJsonFooErrorWithDunderTypeUriAndNamespace() async throws {
        do {
            guard let httpResponse = buildHttpResponse(
                code: 500,
                headers: [
                    "Content-Type": "application/json"
                ],
                content: HttpBody.stream(ByteStream.from(data: """
                {
                    "__type": "aws.protocoltests.restjson#FooError:http://internal.amazon.com/coral/com.amazon.coral.validate/"
                }
                """.data(using: .utf8)!))
            ) else {
                XCTFail("Something is wrong with the created http response")
                return
            }

            let decoder = ClientRuntime.JSONDecoder()
            decoder.dateDecodingStrategy = .secondsSince1970
            decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
            let greetingWithErrorsOutputError = try GreetingWithErrorsOutputError(httpResponse: httpResponse, decoder: decoder)

            if case .fooError(let actual) = greetingWithErrorsOutputError {

                let expected = FooError(
                )
                XCTAssertEqual(actual._statusCode, HttpStatusCode(rawValue: 500))
            } else {
                XCTFail("The deserialized error type does not match expected type")
            }

        } catch let err {
            XCTFail(err.localizedDescription)
        }
    }
}
