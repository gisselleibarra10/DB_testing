// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import ClientRuntime
import SmithyTestUtil
import XCTest


class JsonTimestampsResponseTest: HttpResponseTestBase {
    /// Tests how normal timestamps are serialized
    func testRestJsonJsonTimestamps() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "normal": 1398796238
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            normal: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of date-time works like normal timestamps
    func testRestJsonJsonTimestampsWithDateTimeFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "dateTime": "2014-04-29T18:30:38Z"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            dateTime: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of date-time on the target shape works like normal timestamps
    func testRestJsonJsonTimestampsWithDateTimeOnTargetFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "dateTimeOnTarget": "2014-04-29T18:30:38Z"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            dateTimeOnTarget: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of epoch-seconds works
    func testRestJsonJsonTimestampsWithEpochSecondsFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "epochSeconds": 1398796238
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            epochSeconds: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of epoch-seconds on the target shape works
    func testRestJsonJsonTimestampsWithEpochSecondsOnTargetFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "epochSecondsOnTarget": 1398796238
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            epochSecondsOnTarget: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of http-date works
    func testRestJsonJsonTimestampsWithHttpDateFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "httpDate": "Tue, 29 Apr 2014 18:30:38 GMT"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            httpDate: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
    /// Ensures that the timestampFormat of http-date on the target shape works
    func testRestJsonJsonTimestampsWithHttpDateOnTargetFormat() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "httpDateOnTarget": "Tue, 29 Apr 2014 18:30:38 GMT"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try JsonTimestampsOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = JsonTimestampsOutputResponse(
            httpDateOnTarget: Date(timeIntervalSince1970: 1398796238)
        )

        XCTAssertEqual(expected.normal, actual.normal)
        XCTAssertEqual(expected.dateTime, actual.dateTime)
        XCTAssertEqual(expected.dateTimeOnTarget, actual.dateTimeOnTarget)
        XCTAssertEqual(expected.epochSeconds, actual.epochSeconds)
        XCTAssertEqual(expected.epochSecondsOnTarget, actual.epochSecondsOnTarget)
        XCTAssertEqual(expected.httpDate, actual.httpDate)
        XCTAssertEqual(expected.httpDateOnTarget, actual.httpDateOnTarget)

    }
}
