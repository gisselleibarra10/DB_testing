// Code generated by smithy-swift-codegen. DO NOT EDIT!

@testable import aws_restjson
import ClientRuntime
import SmithyTestUtil
import XCTest


class SimpleScalarPropertiesResponseTest: HttpResponseTestBase {
    /// Serializes simple scalar properties
    func testRestJsonSimpleScalarProperties() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json",
                "X-Foo": "Foo"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "stringValue": "string",
                "trueBooleanValue": true,
                "falseBooleanValue": false,
                "byteValue": 1,
                "shortValue": 2,
                "integerValue": 3,
                "longValue": 4,
                "floatValue": 5.5,
                "DoubleDribble": 6.5
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try SimpleScalarPropertiesOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = SimpleScalarPropertiesOutputResponse(
            byteValue: 1,
            doubleValue: 6.5,
            falseBooleanValue: false,
            floatValue: 5.5,
            foo: "Foo",
            integerValue: 3,
            longValue: 4,
            shortValue: 2,
            stringValue: "string",
            trueBooleanValue: true
        )

        XCTAssertEqual(expected.foo, actual.foo)
        XCTAssertEqual(expected.stringValue, actual.stringValue)
        XCTAssertEqual(expected.trueBooleanValue, actual.trueBooleanValue)
        XCTAssertEqual(expected.falseBooleanValue, actual.falseBooleanValue)
        XCTAssertEqual(expected.byteValue, actual.byteValue)
        XCTAssertEqual(expected.shortValue, actual.shortValue)
        XCTAssertEqual(expected.integerValue, actual.integerValue)
        XCTAssertEqual(expected.longValue, actual.longValue)
        XCTAssertEqual(expected.floatValue, actual.floatValue)
        XCTAssertEqual(expected.doubleValue, actual.doubleValue)

    }
    /// Rest Json should not deserialize null structure values
    func testRestJsonDoesntDeserializeNullStructureValues() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "stringValue": null
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try SimpleScalarPropertiesOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = SimpleScalarPropertiesOutputResponse(
        )

        XCTAssertEqual(expected.foo, actual.foo)
        XCTAssertEqual(expected.stringValue, actual.stringValue)
        XCTAssertEqual(expected.trueBooleanValue, actual.trueBooleanValue)
        XCTAssertEqual(expected.falseBooleanValue, actual.falseBooleanValue)
        XCTAssertEqual(expected.byteValue, actual.byteValue)
        XCTAssertEqual(expected.shortValue, actual.shortValue)
        XCTAssertEqual(expected.integerValue, actual.integerValue)
        XCTAssertEqual(expected.longValue, actual.longValue)
        XCTAssertEqual(expected.floatValue, actual.floatValue)
        XCTAssertEqual(expected.doubleValue, actual.doubleValue)

    }
    /// Supports handling NaN float values.
    func testRestJsonSupportsNaNFloatInputs() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "floatValue": "NaN",
                "DoubleDribble": "NaN"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try SimpleScalarPropertiesOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = SimpleScalarPropertiesOutputResponse(
            doubleValue: Swift.Double.nan,
            floatValue: Swift.Float.nan
        )

        XCTAssertEqual(expected.foo, actual.foo)
        XCTAssertEqual(expected.stringValue, actual.stringValue)
        XCTAssertEqual(expected.trueBooleanValue, actual.trueBooleanValue)
        XCTAssertEqual(expected.falseBooleanValue, actual.falseBooleanValue)
        XCTAssertEqual(expected.byteValue, actual.byteValue)
        XCTAssertEqual(expected.shortValue, actual.shortValue)
        XCTAssertEqual(expected.integerValue, actual.integerValue)
        XCTAssertEqual(expected.longValue, actual.longValue)
        XCTAssertEqual(expected.floatValue?.isNaN, actual.floatValue?.isNaN)
        XCTAssertEqual(expected.doubleValue?.isNaN, actual.doubleValue?.isNaN)

    }
    /// Supports handling Infinity float values.
    func testRestJsonSupportsInfinityFloatInputs() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "floatValue": "Infinity",
                "DoubleDribble": "Infinity"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try SimpleScalarPropertiesOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = SimpleScalarPropertiesOutputResponse(
            doubleValue: Swift.Double.infinity,
            floatValue: Swift.Float.infinity
        )

        XCTAssertEqual(expected.foo, actual.foo)
        XCTAssertEqual(expected.stringValue, actual.stringValue)
        XCTAssertEqual(expected.trueBooleanValue, actual.trueBooleanValue)
        XCTAssertEqual(expected.falseBooleanValue, actual.falseBooleanValue)
        XCTAssertEqual(expected.byteValue, actual.byteValue)
        XCTAssertEqual(expected.shortValue, actual.shortValue)
        XCTAssertEqual(expected.integerValue, actual.integerValue)
        XCTAssertEqual(expected.longValue, actual.longValue)
        XCTAssertEqual(expected.floatValue, actual.floatValue)
        XCTAssertEqual(expected.doubleValue, actual.doubleValue)

    }
    /// Supports handling -Infinity float values.
    func testRestJsonSupportsNegativeInfinityFloatInputs() async throws {
        guard let httpResponse = buildHttpResponse(
            code: 200,
            headers: [
                "Content-Type": "application/json"
            ],
            content: HttpBody.stream(ByteStream.from(data: """
            {
                "floatValue": "-Infinity",
                "DoubleDribble": "-Infinity"
            }
            """.data(using: .utf8)!))
        ) else {
            XCTFail("Something is wrong with the created http response")
            return
        }

        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        let actual = try SimpleScalarPropertiesOutputResponse(httpResponse: httpResponse, decoder: decoder)

        let expected = SimpleScalarPropertiesOutputResponse(
            doubleValue: -Swift.Double.infinity,
            floatValue: -Swift.Float.infinity
        )

        XCTAssertEqual(expected.foo, actual.foo)
        XCTAssertEqual(expected.stringValue, actual.stringValue)
        XCTAssertEqual(expected.trueBooleanValue, actual.trueBooleanValue)
        XCTAssertEqual(expected.falseBooleanValue, actual.falseBooleanValue)
        XCTAssertEqual(expected.byteValue, actual.byteValue)
        XCTAssertEqual(expected.shortValue, actual.shortValue)
        XCTAssertEqual(expected.integerValue, actual.integerValue)
        XCTAssertEqual(expected.longValue, actual.longValue)
        XCTAssertEqual(expected.floatValue, actual.floatValue)
        XCTAssertEqual(expected.doubleValue, actual.doubleValue)

    }
}
