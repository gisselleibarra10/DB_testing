// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.7)
extension WaitersClientProtocol {

    static func successTrueMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                switch result {
                    case .success: return true
                    case .failure: return false
                }
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SuccessTrueMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSuccessTrueMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.successTrueMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func successFalseMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                switch result {
                    case .success: return false
                    case .failure: return true
                }
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the SuccessFalseMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilSuccessFalseMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.successFalseMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func errorTypeMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // Match on error case: myError
                return false
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ErrorTypeMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilErrorTypeMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.errorTypeMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func outputStringPropertyMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: stringProperty
                // JMESPath comparator: stringEquals
                // JMESPath expected value: payload property contents
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let stringProperty = current?.stringProperty
                return JMESValue(stringProperty) == JMESValue("payload property contents")
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the OutputStringPropertyMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilOutputStringPropertyMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.outputStringPropertyMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func outputStringArrayAllPropertyMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: stringArrayProperty
                // JMESPath comparator: allStringEquals
                // JMESPath expected value: payload property contents
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let stringArrayProperty = current?.stringArrayProperty
                return (stringArrayProperty?.count ?? 0) > 1 && (stringArrayProperty?.allSatisfy { JMESValue($0) == JMESValue("payload property contents") } ?? false)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the OutputStringArrayAllPropertyMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilOutputStringArrayAllPropertyMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.outputStringArrayAllPropertyMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func outputStringArrayAnyPropertyMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: stringArrayProperty
                // JMESPath comparator: anyStringEquals
                // JMESPath expected value: payload property contents
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let stringArrayProperty = current?.stringArrayProperty
                return stringArrayProperty?.contains(where: { JMESValue($0) == JMESValue("payload property contents") }) ?? false
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the OutputStringArrayAnyPropertyMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilOutputStringArrayAnyPropertyMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.outputStringArrayAnyPropertyMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func outputBooleanPropertyMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: booleanProperty
                // JMESPath comparator: booleanEquals
                // JMESPath expected value: false
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let booleanProperty = current?.booleanProperty
                return JMESValue(booleanProperty) == JMESValue(false)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the OutputBooleanPropertyMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilOutputBooleanPropertyMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.outputBooleanPropertyMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func inputOutputPropertyMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: input.stringProperty == output.stringProperty
                // JMESPath comparator: booleanEquals
                // JMESPath expected value: true
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor.InputOutput(input: input, output: unwrappedOutput))
                let input = current?.input
                let stringProperty = input?.stringProperty
                let output = current?.output
                let stringProperty2 = output?.stringProperty
                let comparison = JMESValue(stringProperty) == JMESValue(stringProperty2)
                return JMESValue(comparison) == JMESValue(true)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the InputOutputPropertyMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilInputOutputPropertyMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.inputOutputPropertyMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func flattenMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: children[].grandchildren[].name
                // JMESPath comparator: anyStringEquals
                // JMESPath expected value: expected name
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let children = current?.children
                let childrenOrEmpty = Optional.some((children ?? []).flattenIfPossible { $0 })
                let projection = Optional.some((childrenOrEmpty ?? []).compactMap { current in
                    let current = Optional.some(current)
                    let grandchildren = current?.grandchildren
                    let innerResult = grandchildren
                    return innerResult
                })
                let projectionOrEmpty = Optional.some((projection ?? []).flattenIfPossible { $0 })
                let projection2 = Optional.some((projectionOrEmpty ?? []).compactMap { current in
                    let current = Optional.some(current)
                    let name = current?.name
                    let innerResult2 = name
                    return innerResult2
                })
                return projection2?.contains(where: { JMESValue($0) == JMESValue("expected name") }) ?? false
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the FlattenMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilFlattenMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.flattenMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func flattenLengthMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: length(children[].grandchildren[]) == `6`
                // JMESPath comparator: booleanEquals
                // JMESPath expected value: true
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let children = current?.children
                let childrenOrEmpty = Optional.some((children ?? []).flattenIfPossible { $0 })
                let projection = Optional.some((childrenOrEmpty ?? []).compactMap { current in
                    let current = Optional.some(current)
                    let grandchildren = current?.grandchildren
                    let innerResult = grandchildren
                    return innerResult
                })
                let projectionOrEmpty = Optional.some((projection ?? []).flattenIfPossible { $0 })
                let count = Optional.some(Double(projectionOrEmpty?.count ?? 0))
                let number = Optional.some(Double(6.0))
                let comparison = JMESValue(count) == JMESValue(number)
                return JMESValue(comparison) == JMESValue(true)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the FlattenLengthMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilFlattenLengthMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.flattenLengthMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func projectedLengthMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: length(children[?length(grandchildren) == `3`]) == `1`
                // JMESPath comparator: booleanEquals
                // JMESPath expected value: true
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let children = current?.children
                let childrenFiltered = Optional.some((children ?? []).filter { current in
                    let current = Optional.some(current)
                    let grandchildren = current?.grandchildren
                    let count = Optional.some(Double(grandchildren?.count ?? 0))
                    let number = Optional.some(Double(3.0))
                    let comparison = JMESValue(count) == JMESValue(number)
                    return comparison
                })
                let count = Optional.some(Double(childrenFiltered?.count ?? 0))
                let number = Optional.some(Double(1.0))
                let comparison = JMESValue(count) == JMESValue(number)
                return JMESValue(comparison) == JMESValue(true)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the ProjectedLengthMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilProjectedLengthMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.projectedLengthMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }

    static func filterMatcherWaiterConfig() throws -> WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse> {
        let acceptors: [WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>.Acceptor] = [
            .init(state: .success, matcher: { (input: GetWidgetInput, result: Result<GetWidgetOutputResponse, Error>) -> Bool in
                // JMESPath expression: length((children[].grandchildren[])[?number > `4`]) == `3`
                // JMESPath comparator: booleanEquals
                // JMESPath expected value: true
                guard case .success(let unwrappedOutput) = result else { return false }
                let current = Optional.some(unwrappedOutput)
                let children = current?.children
                let childrenOrEmpty = Optional.some((children ?? []).flattenIfPossible { $0 })
                let projection = Optional.some((childrenOrEmpty ?? []).compactMap { current in
                    let current = Optional.some(current)
                    let grandchildren = current?.grandchildren
                    let innerResult = grandchildren
                    return innerResult
                })
                let projectionOrEmpty = Optional.some((projection ?? []).flattenIfPossible { $0 })
                let projectionOrEmptyFiltered = Optional.some((projectionOrEmpty ?? []).filter { current in
                    let current = Optional.some(current)
                    let number = current?.number
                    let number2 = Optional.some(Double(4.0))
                    let comparison = JMESValue(number) > JMESValue(number2)
                    return comparison
                })
                let count = Optional.some(Double(projectionOrEmptyFiltered?.count ?? 0))
                let number = Optional.some(Double(3.0))
                let comparison = JMESValue(count) == JMESValue(number)
                return JMESValue(comparison) == JMESValue(true)
            }),
        ]
        return try WaiterConfiguration<GetWidgetInput, GetWidgetOutputResponse>(acceptors: acceptors, minDelay: 2.0, maxDelay: 120.0)
    }

    /// Initiates waiting for the FilterMatcher event on the getWidget operation.
    /// The operation will be tried and (if necessary) retried until the wait succeeds, fails, or times out.
    /// Returns a `WaiterOutcome` asynchronously on waiter success, throws an error asynchronously on
    /// waiter failure or timeout.
    /// - Parameters:
    ///   - options: `WaiterOptions` to be used to configure this wait.
    ///   - input: The `GetWidgetInput` object to be used as a parameter when performing the operation.
    /// - Returns: A `WaiterOutcome` with the result of the final, successful performance of the operation.
    /// - Throws: `WaiterFailureError` if the waiter fails due to matching an `Acceptor` with state `failure`
    /// or there is an error not handled by any `Acceptor.`
    /// `WaiterTimeoutError` if the waiter times out.
    public func waitUntilFilterMatcher(options: WaiterOptions, input: GetWidgetInput) async throws -> WaiterOutcome<GetWidgetOutputResponse> {
        let waiter = Waiter(config: try Self.filterMatcherWaiterConfig(), operation: self.getWidget(input:))
        return try await waiter.waitUntil(options: options, input: input)
    }
}
#endif
