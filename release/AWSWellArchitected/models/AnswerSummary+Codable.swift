// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension WellArchitectedClientTypes.AnswerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case choiceAnswerSummaries = "ChoiceAnswerSummaries"
        case choices = "Choices"
        case isApplicable = "IsApplicable"
        case pillarId = "PillarId"
        case questionId = "QuestionId"
        case questionTitle = "QuestionTitle"
        case reason = "Reason"
        case risk = "Risk"
        case selectedChoices = "SelectedChoices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let choiceAnswerSummaries = choiceAnswerSummaries {
            var choiceAnswerSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choiceAnswerSummaries)
            for choiceanswersummaries0 in choiceAnswerSummaries {
                try choiceAnswerSummariesContainer.encode(choiceanswersummaries0)
            }
        }
        if let choices = choices {
            var choicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .choices)
            for choices0 in choices {
                try choicesContainer.encode(choices0)
            }
        }
        if isApplicable != false {
            try encodeContainer.encode(isApplicable, forKey: .isApplicable)
        }
        if let pillarId = self.pillarId {
            try encodeContainer.encode(pillarId, forKey: .pillarId)
        }
        if let questionId = self.questionId {
            try encodeContainer.encode(questionId, forKey: .questionId)
        }
        if let questionTitle = self.questionTitle {
            try encodeContainer.encode(questionTitle, forKey: .questionTitle)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
        if let risk = self.risk {
            try encodeContainer.encode(risk.rawValue, forKey: .risk)
        }
        if let selectedChoices = selectedChoices {
            var selectedChoicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedChoices)
            for selectedchoices0 in selectedChoices {
                try selectedChoicesContainer.encode(selectedchoices0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let questionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionId)
        questionId = questionIdDecoded
        let pillarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pillarId)
        pillarId = pillarIdDecoded
        let questionTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .questionTitle)
        questionTitle = questionTitleDecoded
        let choicesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.Choice?].self, forKey: .choices)
        var choicesDecoded0:[WellArchitectedClientTypes.Choice]? = nil
        if let choicesContainer = choicesContainer {
            choicesDecoded0 = [WellArchitectedClientTypes.Choice]()
            for structure0 in choicesContainer {
                if let structure0 = structure0 {
                    choicesDecoded0?.append(structure0)
                }
            }
        }
        choices = choicesDecoded0
        let selectedChoicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedChoices)
        var selectedChoicesDecoded0:[Swift.String]? = nil
        if let selectedChoicesContainer = selectedChoicesContainer {
            selectedChoicesDecoded0 = [Swift.String]()
            for string0 in selectedChoicesContainer {
                if let string0 = string0 {
                    selectedChoicesDecoded0?.append(string0)
                }
            }
        }
        selectedChoices = selectedChoicesDecoded0
        let choiceAnswerSummariesContainer = try containerValues.decodeIfPresent([WellArchitectedClientTypes.ChoiceAnswerSummary?].self, forKey: .choiceAnswerSummaries)
        var choiceAnswerSummariesDecoded0:[WellArchitectedClientTypes.ChoiceAnswerSummary]? = nil
        if let choiceAnswerSummariesContainer = choiceAnswerSummariesContainer {
            choiceAnswerSummariesDecoded0 = [WellArchitectedClientTypes.ChoiceAnswerSummary]()
            for structure0 in choiceAnswerSummariesContainer {
                if let structure0 = structure0 {
                    choiceAnswerSummariesDecoded0?.append(structure0)
                }
            }
        }
        choiceAnswerSummaries = choiceAnswerSummariesDecoded0
        let isApplicableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApplicable) ?? false
        isApplicable = isApplicableDecoded
        let riskDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.Risk.self, forKey: .risk)
        risk = riskDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WellArchitectedClientTypes.AnswerReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}
