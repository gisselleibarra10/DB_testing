// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct RestoreDBClusterToPointInTimeInputBody: Swift.Equatable {
    let dBClusterIdentifier: Swift.String?
    let restoreType: Swift.String?
    let sourceDBClusterIdentifier: Swift.String?
    let restoreToTime: ClientRuntime.Date?
    let useLatestRestorableTime: Swift.Bool
    let port: Swift.Int?
    let dBSubnetGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let tags: [DocDbClientTypes.Tag]?
    let kmsKeyId: Swift.String?
    let enableCloudwatchLogsExports: [Swift.String]?
    let deletionProtection: Swift.Bool?
}

extension RestoreDBClusterToPointInTimeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case deletionProtection = "DeletionProtection"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case kmsKeyId = "KmsKeyId"
        case port = "Port"
        case restoreToTime = "RestoreToTime"
        case restoreType = "RestoreType"
        case sourceDBClusterIdentifier = "SourceDBClusterIdentifier"
        case tags = "Tags"
        case useLatestRestorableTime = "UseLatestRestorableTime"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let restoreTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreType)
        restoreType = restoreTypeDecoded
        let sourceDBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceDBClusterIdentifier)
        sourceDBClusterIdentifier = sourceDBClusterIdentifierDecoded
        let restoreToTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restoreToTime)
        var restoreToTimeBuffer:ClientRuntime.Date? = nil
        if let restoreToTimeDecoded = restoreToTimeDecoded {
            restoreToTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(restoreToTimeDecoded, format: .dateTime)
        }
        restoreToTime = restoreToTimeBuffer
        let useLatestRestorableTimeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useLatestRestorableTime)
        useLatestRestorableTime = useLatestRestorableTimeDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([DocDbClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[DocDbClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [DocDbClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
    }
}
