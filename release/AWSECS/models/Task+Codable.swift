// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EcsClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachments
        case attributes
        case availabilityZone
        case capacityProviderName
        case clusterArn
        case connectivity
        case connectivityAt
        case containerInstanceArn
        case containers
        case cpu
        case createdAt
        case desiredStatus
        case enableExecuteCommand
        case ephemeralStorage
        case executionStoppedAt
        case group
        case healthStatus
        case inferenceAccelerators
        case lastStatus
        case launchType
        case memory
        case overrides
        case platformFamily
        case platformVersion
        case pullStartedAt
        case pullStoppedAt
        case startedAt
        case startedBy
        case stopCode
        case stoppedAt
        case stoppedReason
        case stoppingAt
        case tags
        case taskArn
        case taskDefinitionArn
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachments0 in attachments {
                try attachmentsContainer.encode(attachments0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributes0 in attributes {
                try attributesContainer.encode(attributes0)
            }
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let capacityProviderName = self.capacityProviderName {
            try encodeContainer.encode(capacityProviderName, forKey: .capacityProviderName)
        }
        if let clusterArn = self.clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let connectivity = self.connectivity {
            try encodeContainer.encode(connectivity.rawValue, forKey: .connectivity)
        }
        if let connectivityAt = self.connectivityAt {
            try encodeContainer.encode(connectivityAt.timeIntervalSince1970, forKey: .connectivityAt)
        }
        if let containerInstanceArn = self.containerInstanceArn {
            try encodeContainer.encode(containerInstanceArn, forKey: .containerInstanceArn)
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for containers0 in containers {
                try containersContainer.encode(containers0)
            }
        }
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let desiredStatus = self.desiredStatus {
            try encodeContainer.encode(desiredStatus, forKey: .desiredStatus)
        }
        if enableExecuteCommand != false {
            try encodeContainer.encode(enableExecuteCommand, forKey: .enableExecuteCommand)
        }
        if let ephemeralStorage = self.ephemeralStorage {
            try encodeContainer.encode(ephemeralStorage, forKey: .ephemeralStorage)
        }
        if let executionStoppedAt = self.executionStoppedAt {
            try encodeContainer.encode(executionStoppedAt.timeIntervalSince1970, forKey: .executionStoppedAt)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let inferenceAccelerators = inferenceAccelerators {
            var inferenceAcceleratorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inferenceAccelerators)
            for inferenceaccelerators0 in inferenceAccelerators {
                try inferenceAcceleratorsContainer.encode(inferenceaccelerators0)
            }
        }
        if let lastStatus = self.lastStatus {
            try encodeContainer.encode(lastStatus, forKey: .lastStatus)
        }
        if let launchType = self.launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let overrides = self.overrides {
            try encodeContainer.encode(overrides, forKey: .overrides)
        }
        if let platformFamily = self.platformFamily {
            try encodeContainer.encode(platformFamily, forKey: .platformFamily)
        }
        if let platformVersion = self.platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let pullStartedAt = self.pullStartedAt {
            try encodeContainer.encode(pullStartedAt.timeIntervalSince1970, forKey: .pullStartedAt)
        }
        if let pullStoppedAt = self.pullStoppedAt {
            try encodeContainer.encode(pullStoppedAt.timeIntervalSince1970, forKey: .pullStoppedAt)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let stopCode = self.stopCode {
            try encodeContainer.encode(stopCode.rawValue, forKey: .stopCode)
        }
        if let stoppedAt = self.stoppedAt {
            try encodeContainer.encode(stoppedAt.timeIntervalSince1970, forKey: .stoppedAt)
        }
        if let stoppedReason = self.stoppedReason {
            try encodeContainer.encode(stoppedReason, forKey: .stoppedReason)
        }
        if let stoppingAt = self.stoppingAt {
            try encodeContainer.encode(stoppingAt.timeIntervalSince1970, forKey: .stoppingAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let taskArn = self.taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskDefinitionArn = self.taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentsContainer = try containerValues.decodeIfPresent([EcsClientTypes.Attachment?].self, forKey: .attachments)
        var attachmentsDecoded0:[EcsClientTypes.Attachment]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [EcsClientTypes.Attachment]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([EcsClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[EcsClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [EcsClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let capacityProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityProviderName)
        capacityProviderName = capacityProviderNameDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let connectivityDecoded = try containerValues.decodeIfPresent(EcsClientTypes.Connectivity.self, forKey: .connectivity)
        connectivity = connectivityDecoded
        let connectivityAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .connectivityAt)
        connectivityAt = connectivityAtDecoded
        let containerInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerInstanceArn)
        containerInstanceArn = containerInstanceArnDecoded
        let containersContainer = try containerValues.decodeIfPresent([EcsClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[EcsClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [EcsClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let desiredStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredStatus)
        desiredStatus = desiredStatusDecoded
        let enableExecuteCommandDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableExecuteCommand) ?? false
        enableExecuteCommand = enableExecuteCommandDecoded
        let executionStoppedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStoppedAt)
        executionStoppedAt = executionStoppedAtDecoded
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(EcsClientTypes.HealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let inferenceAcceleratorsContainer = try containerValues.decodeIfPresent([EcsClientTypes.InferenceAccelerator?].self, forKey: .inferenceAccelerators)
        var inferenceAcceleratorsDecoded0:[EcsClientTypes.InferenceAccelerator]? = nil
        if let inferenceAcceleratorsContainer = inferenceAcceleratorsContainer {
            inferenceAcceleratorsDecoded0 = [EcsClientTypes.InferenceAccelerator]()
            for structure0 in inferenceAcceleratorsContainer {
                if let structure0 = structure0 {
                    inferenceAcceleratorsDecoded0?.append(structure0)
                }
            }
        }
        inferenceAccelerators = inferenceAcceleratorsDecoded0
        let lastStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastStatus)
        lastStatus = lastStatusDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(EcsClientTypes.LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let overridesDecoded = try containerValues.decodeIfPresent(EcsClientTypes.TaskOverride.self, forKey: .overrides)
        overrides = overridesDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let platformFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformFamily)
        platformFamily = platformFamilyDecoded
        let pullStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .pullStartedAt)
        pullStartedAt = pullStartedAtDecoded
        let pullStoppedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .pullStoppedAt)
        pullStoppedAt = pullStoppedAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let stopCodeDecoded = try containerValues.decodeIfPresent(EcsClientTypes.TaskStopCode.self, forKey: .stopCode)
        stopCode = stopCodeDecoded
        let stoppedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
        let stoppedReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stoppedReason)
        stoppedReason = stoppedReasonDecoded
        let stoppingAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .stoppingAt)
        stoppingAt = stoppingAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version) ?? 0
        version = versionDecoded
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(EcsClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
    }
}
