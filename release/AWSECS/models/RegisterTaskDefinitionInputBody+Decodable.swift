// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct RegisterTaskDefinitionInputBody: Swift.Equatable {
    let family: Swift.String?
    let taskRoleArn: Swift.String?
    let executionRoleArn: Swift.String?
    let networkMode: EcsClientTypes.NetworkMode?
    let containerDefinitions: [EcsClientTypes.ContainerDefinition]?
    let volumes: [EcsClientTypes.Volume]?
    let placementConstraints: [EcsClientTypes.TaskDefinitionPlacementConstraint]?
    let requiresCompatibilities: [EcsClientTypes.Compatibility]?
    let cpu: Swift.String?
    let memory: Swift.String?
    let tags: [EcsClientTypes.Tag]?
    let pidMode: EcsClientTypes.PidMode?
    let ipcMode: EcsClientTypes.IpcMode?
    let proxyConfiguration: EcsClientTypes.ProxyConfiguration?
    let inferenceAccelerators: [EcsClientTypes.InferenceAccelerator]?
    let ephemeralStorage: EcsClientTypes.EphemeralStorage?
    let runtimePlatform: EcsClientTypes.RuntimePlatform?
}

extension RegisterTaskDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerDefinitions
        case cpu
        case ephemeralStorage
        case executionRoleArn
        case family
        case inferenceAccelerators
        case ipcMode
        case memory
        case networkMode
        case pidMode
        case placementConstraints
        case proxyConfiguration
        case requiresCompatibilities
        case runtimePlatform
        case tags
        case taskRoleArn
        case volumes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let taskRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskRoleArn)
        taskRoleArn = taskRoleArnDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let networkModeDecoded = try containerValues.decodeIfPresent(EcsClientTypes.NetworkMode.self, forKey: .networkMode)
        networkMode = networkModeDecoded
        let containerDefinitionsContainer = try containerValues.decodeIfPresent([EcsClientTypes.ContainerDefinition?].self, forKey: .containerDefinitions)
        var containerDefinitionsDecoded0:[EcsClientTypes.ContainerDefinition]? = nil
        if let containerDefinitionsContainer = containerDefinitionsContainer {
            containerDefinitionsDecoded0 = [EcsClientTypes.ContainerDefinition]()
            for structure0 in containerDefinitionsContainer {
                if let structure0 = structure0 {
                    containerDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        containerDefinitions = containerDefinitionsDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([EcsClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[EcsClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [EcsClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let placementConstraintsContainer = try containerValues.decodeIfPresent([EcsClientTypes.TaskDefinitionPlacementConstraint?].self, forKey: .placementConstraints)
        var placementConstraintsDecoded0:[EcsClientTypes.TaskDefinitionPlacementConstraint]? = nil
        if let placementConstraintsContainer = placementConstraintsContainer {
            placementConstraintsDecoded0 = [EcsClientTypes.TaskDefinitionPlacementConstraint]()
            for structure0 in placementConstraintsContainer {
                if let structure0 = structure0 {
                    placementConstraintsDecoded0?.append(structure0)
                }
            }
        }
        placementConstraints = placementConstraintsDecoded0
        let requiresCompatibilitiesContainer = try containerValues.decodeIfPresent([EcsClientTypes.Compatibility?].self, forKey: .requiresCompatibilities)
        var requiresCompatibilitiesDecoded0:[EcsClientTypes.Compatibility]? = nil
        if let requiresCompatibilitiesContainer = requiresCompatibilitiesContainer {
            requiresCompatibilitiesDecoded0 = [EcsClientTypes.Compatibility]()
            for enum0 in requiresCompatibilitiesContainer {
                if let enum0 = enum0 {
                    requiresCompatibilitiesDecoded0?.append(enum0)
                }
            }
        }
        requiresCompatibilities = requiresCompatibilitiesDecoded0
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let pidModeDecoded = try containerValues.decodeIfPresent(EcsClientTypes.PidMode.self, forKey: .pidMode)
        pidMode = pidModeDecoded
        let ipcModeDecoded = try containerValues.decodeIfPresent(EcsClientTypes.IpcMode.self, forKey: .ipcMode)
        ipcMode = ipcModeDecoded
        let proxyConfigurationDecoded = try containerValues.decodeIfPresent(EcsClientTypes.ProxyConfiguration.self, forKey: .proxyConfiguration)
        proxyConfiguration = proxyConfigurationDecoded
        let inferenceAcceleratorsContainer = try containerValues.decodeIfPresent([EcsClientTypes.InferenceAccelerator?].self, forKey: .inferenceAccelerators)
        var inferenceAcceleratorsDecoded0:[EcsClientTypes.InferenceAccelerator]? = nil
        if let inferenceAcceleratorsContainer = inferenceAcceleratorsContainer {
            inferenceAcceleratorsDecoded0 = [EcsClientTypes.InferenceAccelerator]()
            for structure0 in inferenceAcceleratorsContainer {
                if let structure0 = structure0 {
                    inferenceAcceleratorsDecoded0?.append(structure0)
                }
            }
        }
        inferenceAccelerators = inferenceAcceleratorsDecoded0
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(EcsClientTypes.EphemeralStorage.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let runtimePlatformDecoded = try containerValues.decodeIfPresent(EcsClientTypes.RuntimePlatform.self, forKey: .runtimePlatform)
        runtimePlatform = runtimePlatformDecoded
    }
}
