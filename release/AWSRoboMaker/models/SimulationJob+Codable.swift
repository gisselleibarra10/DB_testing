// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RoboMakerClientTypes.SimulationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case clientRequestToken
        case compute
        case dataSources
        case failureBehavior
        case failureCode
        case failureReason
        case iamRole
        case lastStartedAt
        case lastUpdatedAt
        case loggingConfig
        case maxJobDurationInSeconds
        case name
        case networkInterface
        case outputLocation
        case robotApplications
        case simulationApplications
        case simulationTimeMillis
        case status
        case tags
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasources0 in dataSources {
                try dataSourcesContainer.encode(datasources0)
            }
        }
        if let failureBehavior = self.failureBehavior {
            try encodeContainer.encode(failureBehavior.rawValue, forKey: .failureBehavior)
        }
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let lastStartedAt = self.lastStartedAt {
            try encodeContainer.encode(lastStartedAt.timeIntervalSince1970, forKey: .lastStartedAt)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let loggingConfig = self.loggingConfig {
            try encodeContainer.encode(loggingConfig, forKey: .loggingConfig)
        }
        if maxJobDurationInSeconds != 0 {
            try encodeContainer.encode(maxJobDurationInSeconds, forKey: .maxJobDurationInSeconds)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let robotApplications = robotApplications {
            var robotApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .robotApplications)
            for robotapplicationconfigs0 in robotApplications {
                try robotApplicationsContainer.encode(robotapplicationconfigs0)
            }
        }
        if let simulationApplications = simulationApplications {
            var simulationApplicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .simulationApplications)
            for simulationapplicationconfigs0 in simulationApplications {
                try simulationApplicationsContainer.encode(simulationapplicationconfigs0)
            }
        }
        if simulationTimeMillis != 0 {
            try encodeContainer.encode(simulationTimeMillis, forKey: .simulationTimeMillis)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobStatus.self, forKey: .status)
        status = statusDecoded
        let lastStartedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStartedAt)
        lastStartedAt = lastStartedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let failureBehaviorDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.FailureBehavior.self, forKey: .failureBehavior)
        failureBehavior = failureBehaviorDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.SimulationJobErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.OutputLocation.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let loggingConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.LoggingConfig.self, forKey: .loggingConfig)
        loggingConfig = loggingConfigDecoded
        let maxJobDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxJobDurationInSeconds) ?? 0
        maxJobDurationInSeconds = maxJobDurationInSecondsDecoded
        let simulationTimeMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .simulationTimeMillis) ?? 0
        simulationTimeMillis = simulationTimeMillisDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
        let robotApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.RobotApplicationConfig?].self, forKey: .robotApplications)
        var robotApplicationsDecoded0:[RoboMakerClientTypes.RobotApplicationConfig]? = nil
        if let robotApplicationsContainer = robotApplicationsContainer {
            robotApplicationsDecoded0 = [RoboMakerClientTypes.RobotApplicationConfig]()
            for structure0 in robotApplicationsContainer {
                if let structure0 = structure0 {
                    robotApplicationsDecoded0?.append(structure0)
                }
            }
        }
        robotApplications = robotApplicationsDecoded0
        let simulationApplicationsContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.SimulationApplicationConfig?].self, forKey: .simulationApplications)
        var simulationApplicationsDecoded0:[RoboMakerClientTypes.SimulationApplicationConfig]? = nil
        if let simulationApplicationsContainer = simulationApplicationsContainer {
            simulationApplicationsDecoded0 = [RoboMakerClientTypes.SimulationApplicationConfig]()
            for structure0 in simulationApplicationsContainer {
                if let structure0 = structure0 {
                    simulationApplicationsDecoded0?.append(structure0)
                }
            }
        }
        simulationApplications = simulationApplicationsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([RoboMakerClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[RoboMakerClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [RoboMakerClientTypes.DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let vpcConfigDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.VPCConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let computeDecoded = try containerValues.decodeIfPresent(RoboMakerClientTypes.ComputeResponse.self, forKey: .compute)
        compute = computeDecoded
    }
}
