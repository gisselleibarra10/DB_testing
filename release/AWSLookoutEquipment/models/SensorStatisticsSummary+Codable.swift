// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LookoutEquipmentClientTypes.SensorStatisticsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoricalValues = "CategoricalValues"
        case componentName = "ComponentName"
        case dataEndTime = "DataEndTime"
        case dataExists = "DataExists"
        case dataStartTime = "DataStartTime"
        case duplicateTimestamps = "DuplicateTimestamps"
        case invalidDateEntries = "InvalidDateEntries"
        case invalidValues = "InvalidValues"
        case largeTimestampGaps = "LargeTimestampGaps"
        case missingValues = "MissingValues"
        case monotonicValues = "MonotonicValues"
        case multipleOperatingModes = "MultipleOperatingModes"
        case sensorName = "SensorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalValues = self.categoricalValues {
            try encodeContainer.encode(categoricalValues, forKey: .categoricalValues)
        }
        if let componentName = self.componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let dataEndTime = self.dataEndTime {
            try encodeContainer.encode(dataEndTime.timeIntervalSince1970, forKey: .dataEndTime)
        }
        if dataExists != false {
            try encodeContainer.encode(dataExists, forKey: .dataExists)
        }
        if let dataStartTime = self.dataStartTime {
            try encodeContainer.encode(dataStartTime.timeIntervalSince1970, forKey: .dataStartTime)
        }
        if let duplicateTimestamps = self.duplicateTimestamps {
            try encodeContainer.encode(duplicateTimestamps, forKey: .duplicateTimestamps)
        }
        if let invalidDateEntries = self.invalidDateEntries {
            try encodeContainer.encode(invalidDateEntries, forKey: .invalidDateEntries)
        }
        if let invalidValues = self.invalidValues {
            try encodeContainer.encode(invalidValues, forKey: .invalidValues)
        }
        if let largeTimestampGaps = self.largeTimestampGaps {
            try encodeContainer.encode(largeTimestampGaps, forKey: .largeTimestampGaps)
        }
        if let missingValues = self.missingValues {
            try encodeContainer.encode(missingValues, forKey: .missingValues)
        }
        if let monotonicValues = self.monotonicValues {
            try encodeContainer.encode(monotonicValues, forKey: .monotonicValues)
        }
        if let multipleOperatingModes = self.multipleOperatingModes {
            try encodeContainer.encode(multipleOperatingModes, forKey: .multipleOperatingModes)
        }
        if let sensorName = self.sensorName {
            try encodeContainer.encode(sensorName, forKey: .sensorName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let sensorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sensorName)
        sensorName = sensorNameDecoded
        let dataExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataExists) ?? false
        dataExists = dataExistsDecoded
        let missingValuesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.CountPercent.self, forKey: .missingValues)
        missingValues = missingValuesDecoded
        let invalidValuesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.CountPercent.self, forKey: .invalidValues)
        invalidValues = invalidValuesDecoded
        let invalidDateEntriesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.CountPercent.self, forKey: .invalidDateEntries)
        invalidDateEntries = invalidDateEntriesDecoded
        let duplicateTimestampsDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.CountPercent.self, forKey: .duplicateTimestamps)
        duplicateTimestamps = duplicateTimestampsDecoded
        let categoricalValuesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.CategoricalValues.self, forKey: .categoricalValues)
        categoricalValues = categoricalValuesDecoded
        let multipleOperatingModesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.MultipleOperatingModes.self, forKey: .multipleOperatingModes)
        multipleOperatingModes = multipleOperatingModesDecoded
        let largeTimestampGapsDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.LargeTimestampGaps.self, forKey: .largeTimestampGaps)
        largeTimestampGaps = largeTimestampGapsDecoded
        let monotonicValuesDecoded = try containerValues.decodeIfPresent(LookoutEquipmentClientTypes.MonotonicValues.self, forKey: .monotonicValues)
        monotonicValues = monotonicValuesDecoded
        let dataStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataStartTime)
        dataStartTime = dataStartTimeDecoded
        let dataEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dataEndTime)
        dataEndTime = dataEndTimeDecoded
    }
}
