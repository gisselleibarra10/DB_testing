// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct SimulateCustomPolicyInputBody: Swift.Equatable {
    let policyInputList: [Swift.String]?
    let permissionsBoundaryPolicyInputList: [Swift.String]?
    let actionNames: [Swift.String]?
    let resourceArns: [Swift.String]?
    let resourcePolicy: Swift.String?
    let resourceOwner: Swift.String?
    let callerArn: Swift.String?
    let contextEntries: [IamClientTypes.ContextEntry]?
    let resourceHandlingOption: Swift.String?
    let maxItems: Swift.Int?
    let marker: Swift.String?
}

extension SimulateCustomPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionNames = "ActionNames"
        case callerArn = "CallerArn"
        case contextEntries = "ContextEntries"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case permissionsBoundaryPolicyInputList = "PermissionsBoundaryPolicyInputList"
        case policyInputList = "PolicyInputList"
        case resourceArns = "ResourceArns"
        case resourceHandlingOption = "ResourceHandlingOption"
        case resourceOwner = "ResourceOwner"
        case resourcePolicy = "ResourcePolicy"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.policyInputList) {
            struct KeyVal0{struct member{}}
            let policyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .policyInputList)
            if let policyInputListWrappedContainer = policyInputListWrappedContainer {
                let policyInputListContainer = try policyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var policyInputListBuffer:[Swift.String]? = nil
                if let policyInputListContainer = policyInputListContainer {
                    policyInputListBuffer = [Swift.String]()
                    for stringContainer0 in policyInputListContainer {
                        policyInputListBuffer?.append(stringContainer0)
                    }
                }
                policyInputList = policyInputListBuffer
            } else {
                policyInputList = []
            }
        } else {
            policyInputList = nil
        }
        if containerValues.contains(.permissionsBoundaryPolicyInputList) {
            struct KeyVal0{struct member{}}
            let permissionsBoundaryPolicyInputListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .permissionsBoundaryPolicyInputList)
            if let permissionsBoundaryPolicyInputListWrappedContainer = permissionsBoundaryPolicyInputListWrappedContainer {
                let permissionsBoundaryPolicyInputListContainer = try permissionsBoundaryPolicyInputListWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var permissionsBoundaryPolicyInputListBuffer:[Swift.String]? = nil
                if let permissionsBoundaryPolicyInputListContainer = permissionsBoundaryPolicyInputListContainer {
                    permissionsBoundaryPolicyInputListBuffer = [Swift.String]()
                    for stringContainer0 in permissionsBoundaryPolicyInputListContainer {
                        permissionsBoundaryPolicyInputListBuffer?.append(stringContainer0)
                    }
                }
                permissionsBoundaryPolicyInputList = permissionsBoundaryPolicyInputListBuffer
            } else {
                permissionsBoundaryPolicyInputList = []
            }
        } else {
            permissionsBoundaryPolicyInputList = nil
        }
        if containerValues.contains(.actionNames) {
            struct KeyVal0{struct member{}}
            let actionNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actionNames)
            if let actionNamesWrappedContainer = actionNamesWrappedContainer {
                let actionNamesContainer = try actionNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var actionNamesBuffer:[Swift.String]? = nil
                if let actionNamesContainer = actionNamesContainer {
                    actionNamesBuffer = [Swift.String]()
                    for stringContainer0 in actionNamesContainer {
                        actionNamesBuffer?.append(stringContainer0)
                    }
                }
                actionNames = actionNamesBuffer
            } else {
                actionNames = []
            }
        } else {
            actionNames = nil
        }
        if containerValues.contains(.resourceArns) {
            struct KeyVal0{struct member{}}
            let resourceArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .resourceArns)
            if let resourceArnsWrappedContainer = resourceArnsWrappedContainer {
                let resourceArnsContainer = try resourceArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var resourceArnsBuffer:[Swift.String]? = nil
                if let resourceArnsContainer = resourceArnsContainer {
                    resourceArnsBuffer = [Swift.String]()
                    for stringContainer0 in resourceArnsContainer {
                        resourceArnsBuffer?.append(stringContainer0)
                    }
                }
                resourceArns = resourceArnsBuffer
            } else {
                resourceArns = []
            }
        } else {
            resourceArns = nil
        }
        let resourcePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourcePolicy)
        resourcePolicy = resourcePolicyDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let callerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerArn)
        callerArn = callerArnDecoded
        if containerValues.contains(.contextEntries) {
            struct KeyVal0{struct member{}}
            let contextEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .contextEntries)
            if let contextEntriesWrappedContainer = contextEntriesWrappedContainer {
                let contextEntriesContainer = try contextEntriesWrappedContainer.decodeIfPresent([IamClientTypes.ContextEntry].self, forKey: .member)
                var contextEntriesBuffer:[IamClientTypes.ContextEntry]? = nil
                if let contextEntriesContainer = contextEntriesContainer {
                    contextEntriesBuffer = [IamClientTypes.ContextEntry]()
                    for structureContainer0 in contextEntriesContainer {
                        contextEntriesBuffer?.append(structureContainer0)
                    }
                }
                contextEntries = contextEntriesBuffer
            } else {
                contextEntries = []
            }
        } else {
            contextEntries = nil
        }
        let resourceHandlingOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceHandlingOption)
        resourceHandlingOption = resourceHandlingOptionDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}
