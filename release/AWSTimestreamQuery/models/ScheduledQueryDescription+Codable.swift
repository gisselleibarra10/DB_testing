// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TimestreamQueryClientTypes.ScheduledQueryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case errorReportConfiguration = "ErrorReportConfiguration"
        case kmsKeyId = "KmsKeyId"
        case lastRunSummary = "LastRunSummary"
        case name = "Name"
        case nextInvocationTime = "NextInvocationTime"
        case notificationConfiguration = "NotificationConfiguration"
        case previousInvocationTime = "PreviousInvocationTime"
        case queryString = "QueryString"
        case recentlyFailedRuns = "RecentlyFailedRuns"
        case scheduleConfiguration = "ScheduleConfiguration"
        case scheduledQueryExecutionRoleArn = "ScheduledQueryExecutionRoleArn"
        case state = "State"
        case targetConfiguration = "TargetConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let errorReportConfiguration = self.errorReportConfiguration {
            try encodeContainer.encode(errorReportConfiguration, forKey: .errorReportConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastRunSummary = self.lastRunSummary {
            try encodeContainer.encode(lastRunSummary, forKey: .lastRunSummary)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextInvocationTime = self.nextInvocationTime {
            try encodeContainer.encode(nextInvocationTime.timeIntervalSince1970, forKey: .nextInvocationTime)
        }
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let previousInvocationTime = self.previousInvocationTime {
            try encodeContainer.encode(previousInvocationTime.timeIntervalSince1970, forKey: .previousInvocationTime)
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
        if let recentlyFailedRuns = recentlyFailedRuns {
            var recentlyFailedRunsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recentlyFailedRuns)
            for scheduledqueryrunsummarylist0 in recentlyFailedRuns {
                try recentlyFailedRunsContainer.encode(scheduledqueryrunsummarylist0)
            }
        }
        if let scheduleConfiguration = self.scheduleConfiguration {
            try encodeContainer.encode(scheduleConfiguration, forKey: .scheduleConfiguration)
        }
        if let scheduledQueryExecutionRoleArn = self.scheduledQueryExecutionRoleArn {
            try encodeContainer.encode(scheduledQueryExecutionRoleArn, forKey: .scheduledQueryExecutionRoleArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let targetConfiguration = self.targetConfiguration {
            try encodeContainer.encode(targetConfiguration, forKey: .targetConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryState.self, forKey: .state)
        state = stateDecoded
        let previousInvocationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .previousInvocationTime)
        previousInvocationTime = previousInvocationTimeDecoded
        let nextInvocationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .nextInvocationTime)
        nextInvocationTime = nextInvocationTimeDecoded
        let scheduleConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduleConfiguration.self, forKey: .scheduleConfiguration)
        scheduleConfiguration = scheduleConfigurationDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let targetConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.TargetConfiguration.self, forKey: .targetConfiguration)
        targetConfiguration = targetConfigurationDecoded
        let scheduledQueryExecutionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduledQueryExecutionRoleArn)
        scheduledQueryExecutionRoleArn = scheduledQueryExecutionRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let errorReportConfigurationDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ErrorReportConfiguration.self, forKey: .errorReportConfiguration)
        errorReportConfiguration = errorReportConfigurationDecoded
        let lastRunSummaryDecoded = try containerValues.decodeIfPresent(TimestreamQueryClientTypes.ScheduledQueryRunSummary.self, forKey: .lastRunSummary)
        lastRunSummary = lastRunSummaryDecoded
        let recentlyFailedRunsContainer = try containerValues.decodeIfPresent([TimestreamQueryClientTypes.ScheduledQueryRunSummary?].self, forKey: .recentlyFailedRuns)
        var recentlyFailedRunsDecoded0:[TimestreamQueryClientTypes.ScheduledQueryRunSummary]? = nil
        if let recentlyFailedRunsContainer = recentlyFailedRunsContainer {
            recentlyFailedRunsDecoded0 = [TimestreamQueryClientTypes.ScheduledQueryRunSummary]()
            for structure0 in recentlyFailedRunsContainer {
                if let structure0 = structure0 {
                    recentlyFailedRunsDecoded0?.append(structure0)
                }
            }
        }
        recentlyFailedRuns = recentlyFailedRunsDecoded0
    }
}
