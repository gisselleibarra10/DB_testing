// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateCacheClusterInputBody: Swift.Equatable {
    let cacheClusterId: Swift.String?
    let replicationGroupId: Swift.String?
    let aZMode: ElastiCacheClientTypes.AZMode?
    let preferredAvailabilityZone: Swift.String?
    let preferredAvailabilityZones: [Swift.String]?
    let numCacheNodes: Swift.Int?
    let cacheNodeType: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let cacheParameterGroupName: Swift.String?
    let cacheSubnetGroupName: Swift.String?
    let cacheSecurityGroupNames: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [ElastiCacheClientTypes.Tag]?
    let snapshotArns: [Swift.String]?
    let snapshotName: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let port: Swift.Int?
    let notificationTopicArn: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let snapshotRetentionLimit: Swift.Int?
    let snapshotWindow: Swift.String?
    let authToken: Swift.String?
    let outpostMode: ElastiCacheClientTypes.OutpostMode?
    let preferredOutpostArn: Swift.String?
    let preferredOutpostArns: [Swift.String]?
    let logDeliveryConfigurations: [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]?
    let transitEncryptionEnabled: Swift.Bool?
}

extension CreateCacheClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aZMode = "AZMode"
        case authToken = "AuthToken"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case cacheClusterId = "CacheClusterId"
        case cacheNodeType = "CacheNodeType"
        case cacheParameterGroupName = "CacheParameterGroupName"
        case cacheSecurityGroupNames = "CacheSecurityGroupNames"
        case cacheSubnetGroupName = "CacheSubnetGroupName"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case logDeliveryConfigurations = "LogDeliveryConfigurations"
        case notificationTopicArn = "NotificationTopicArn"
        case numCacheNodes = "NumCacheNodes"
        case outpostMode = "OutpostMode"
        case port = "Port"
        case preferredAvailabilityZone = "PreferredAvailabilityZone"
        case preferredAvailabilityZones = "PreferredAvailabilityZones"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case preferredOutpostArn = "PreferredOutpostArn"
        case preferredOutpostArns = "PreferredOutpostArns"
        case replicationGroupId = "ReplicationGroupId"
        case securityGroupIds = "SecurityGroupIds"
        case snapshotArns = "SnapshotArns"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case tags = "Tags"
        case transitEncryptionEnabled = "TransitEncryptionEnabled"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheClusterId)
        cacheClusterId = cacheClusterIdDecoded
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let aZModeDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.AZMode.self, forKey: .aZMode)
        aZMode = aZModeDecoded
        let preferredAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredAvailabilityZone)
        preferredAvailabilityZone = preferredAvailabilityZoneDecoded
        if containerValues.contains(.preferredAvailabilityZones) {
            struct KeyVal0{struct PreferredAvailabilityZone{}}
            let preferredAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PreferredAvailabilityZone>.CodingKeys.self, forKey: .preferredAvailabilityZones)
            if let preferredAvailabilityZonesWrappedContainer = preferredAvailabilityZonesWrappedContainer {
                let preferredAvailabilityZonesContainer = try preferredAvailabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var preferredAvailabilityZonesBuffer:[Swift.String]? = nil
                if let preferredAvailabilityZonesContainer = preferredAvailabilityZonesContainer {
                    preferredAvailabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in preferredAvailabilityZonesContainer {
                        preferredAvailabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                preferredAvailabilityZones = preferredAvailabilityZonesBuffer
            } else {
                preferredAvailabilityZones = []
            }
        } else {
            preferredAvailabilityZones = nil
        }
        let numCacheNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numCacheNodes)
        numCacheNodes = numCacheNodesDecoded
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let cacheParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheParameterGroupName)
        cacheParameterGroupName = cacheParameterGroupNameDecoded
        let cacheSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheSubnetGroupName)
        cacheSubnetGroupName = cacheSubnetGroupNameDecoded
        if containerValues.contains(.cacheSecurityGroupNames) {
            struct KeyVal0{struct CacheSecurityGroupName{}}
            let cacheSecurityGroupNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheSecurityGroupName>.CodingKeys.self, forKey: .cacheSecurityGroupNames)
            if let cacheSecurityGroupNamesWrappedContainer = cacheSecurityGroupNamesWrappedContainer {
                let cacheSecurityGroupNamesContainer = try cacheSecurityGroupNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var cacheSecurityGroupNamesBuffer:[Swift.String]? = nil
                if let cacheSecurityGroupNamesContainer = cacheSecurityGroupNamesContainer {
                    cacheSecurityGroupNamesBuffer = [Swift.String]()
                    for stringContainer0 in cacheSecurityGroupNamesContainer {
                        cacheSecurityGroupNamesBuffer?.append(stringContainer0)
                    }
                }
                cacheSecurityGroupNames = cacheSecurityGroupNamesBuffer
            } else {
                cacheSecurityGroupNames = []
            }
        } else {
            cacheSecurityGroupNames = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElastiCacheClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElastiCacheClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.snapshotArns) {
            struct KeyVal0{struct SnapshotArn{}}
            let snapshotArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotArn>.CodingKeys.self, forKey: .snapshotArns)
            if let snapshotArnsWrappedContainer = snapshotArnsWrappedContainer {
                let snapshotArnsContainer = try snapshotArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var snapshotArnsBuffer:[Swift.String]? = nil
                if let snapshotArnsContainer = snapshotArnsContainer {
                    snapshotArnsBuffer = [Swift.String]()
                    for stringContainer0 in snapshotArnsContainer {
                        snapshotArnsBuffer?.append(stringContainer0)
                    }
                }
                snapshotArns = snapshotArnsBuffer
            } else {
                snapshotArns = []
            }
        } else {
            snapshotArns = nil
        }
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let authTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authToken)
        authToken = authTokenDecoded
        let outpostModeDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.OutpostMode.self, forKey: .outpostMode)
        outpostMode = outpostModeDecoded
        let preferredOutpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredOutpostArn)
        preferredOutpostArn = preferredOutpostArnDecoded
        if containerValues.contains(.preferredOutpostArns) {
            struct KeyVal0{struct PreferredOutpostArn{}}
            let preferredOutpostArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PreferredOutpostArn>.CodingKeys.self, forKey: .preferredOutpostArns)
            if let preferredOutpostArnsWrappedContainer = preferredOutpostArnsWrappedContainer {
                let preferredOutpostArnsContainer = try preferredOutpostArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var preferredOutpostArnsBuffer:[Swift.String]? = nil
                if let preferredOutpostArnsContainer = preferredOutpostArnsContainer {
                    preferredOutpostArnsBuffer = [Swift.String]()
                    for stringContainer0 in preferredOutpostArnsContainer {
                        preferredOutpostArnsBuffer?.append(stringContainer0)
                    }
                }
                preferredOutpostArns = preferredOutpostArnsBuffer
            } else {
                preferredOutpostArns = []
            }
        } else {
            preferredOutpostArns = nil
        }
        if containerValues.contains(.logDeliveryConfigurations) {
            struct KeyVal0{struct LogDeliveryConfigurationRequest{}}
            let logDeliveryConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LogDeliveryConfigurationRequest>.CodingKeys.self, forKey: .logDeliveryConfigurations)
            if let logDeliveryConfigurationsWrappedContainer = logDeliveryConfigurationsWrappedContainer {
                let logDeliveryConfigurationsContainer = try logDeliveryConfigurationsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.LogDeliveryConfigurationRequest].self, forKey: .member)
                var logDeliveryConfigurationsBuffer:[ElastiCacheClientTypes.LogDeliveryConfigurationRequest]? = nil
                if let logDeliveryConfigurationsContainer = logDeliveryConfigurationsContainer {
                    logDeliveryConfigurationsBuffer = [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]()
                    for structureContainer0 in logDeliveryConfigurationsContainer {
                        logDeliveryConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                logDeliveryConfigurations = logDeliveryConfigurationsBuffer
            } else {
                logDeliveryConfigurations = []
            }
        } else {
            logDeliveryConfigurations = nil
        }
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
    }
}
