// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateReplicationGroupInputBody: Swift.Equatable {
    let replicationGroupId: Swift.String?
    let replicationGroupDescription: Swift.String?
    let globalReplicationGroupId: Swift.String?
    let primaryClusterId: Swift.String?
    let automaticFailoverEnabled: Swift.Bool?
    let multiAZEnabled: Swift.Bool?
    let numCacheClusters: Swift.Int?
    let preferredCacheClusterAZs: [Swift.String]?
    let numNodeGroups: Swift.Int?
    let replicasPerNodeGroup: Swift.Int?
    let nodeGroupConfiguration: [ElastiCacheClientTypes.NodeGroupConfiguration]?
    let cacheNodeType: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let cacheParameterGroupName: Swift.String?
    let cacheSubnetGroupName: Swift.String?
    let cacheSecurityGroupNames: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let tags: [ElastiCacheClientTypes.Tag]?
    let snapshotArns: [Swift.String]?
    let snapshotName: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let port: Swift.Int?
    let notificationTopicArn: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let snapshotRetentionLimit: Swift.Int?
    let snapshotWindow: Swift.String?
    let authToken: Swift.String?
    let transitEncryptionEnabled: Swift.Bool?
    let atRestEncryptionEnabled: Swift.Bool?
    let kmsKeyId: Swift.String?
    let userGroupIds: [Swift.String]?
    let logDeliveryConfigurations: [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]?
    let dataTieringEnabled: Swift.Bool?
}

extension CreateReplicationGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atRestEncryptionEnabled = "AtRestEncryptionEnabled"
        case authToken = "AuthToken"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticFailoverEnabled = "AutomaticFailoverEnabled"
        case cacheNodeType = "CacheNodeType"
        case cacheParameterGroupName = "CacheParameterGroupName"
        case cacheSecurityGroupNames = "CacheSecurityGroupNames"
        case cacheSubnetGroupName = "CacheSubnetGroupName"
        case dataTieringEnabled = "DataTieringEnabled"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case globalReplicationGroupId = "GlobalReplicationGroupId"
        case kmsKeyId = "KmsKeyId"
        case logDeliveryConfigurations = "LogDeliveryConfigurations"
        case multiAZEnabled = "MultiAZEnabled"
        case nodeGroupConfiguration = "NodeGroupConfiguration"
        case notificationTopicArn = "NotificationTopicArn"
        case numCacheClusters = "NumCacheClusters"
        case numNodeGroups = "NumNodeGroups"
        case port = "Port"
        case preferredCacheClusterAZs = "PreferredCacheClusterAZs"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case primaryClusterId = "PrimaryClusterId"
        case replicasPerNodeGroup = "ReplicasPerNodeGroup"
        case replicationGroupDescription = "ReplicationGroupDescription"
        case replicationGroupId = "ReplicationGroupId"
        case securityGroupIds = "SecurityGroupIds"
        case snapshotArns = "SnapshotArns"
        case snapshotName = "SnapshotName"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case tags = "Tags"
        case transitEncryptionEnabled = "TransitEncryptionEnabled"
        case userGroupIds = "UserGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let replicationGroupDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationGroupDescription)
        replicationGroupDescription = replicationGroupDescriptionDecoded
        let globalReplicationGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .globalReplicationGroupId)
        globalReplicationGroupId = globalReplicationGroupIdDecoded
        let primaryClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primaryClusterId)
        primaryClusterId = primaryClusterIdDecoded
        let automaticFailoverEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .automaticFailoverEnabled)
        automaticFailoverEnabled = automaticFailoverEnabledDecoded
        let multiAZEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZEnabled)
        multiAZEnabled = multiAZEnabledDecoded
        let numCacheClustersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numCacheClusters)
        numCacheClusters = numCacheClustersDecoded
        if containerValues.contains(.preferredCacheClusterAZs) {
            struct KeyVal0{struct AvailabilityZone{}}
            let preferredCacheClusterAZsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .preferredCacheClusterAZs)
            if let preferredCacheClusterAZsWrappedContainer = preferredCacheClusterAZsWrappedContainer {
                let preferredCacheClusterAZsContainer = try preferredCacheClusterAZsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var preferredCacheClusterAZsBuffer:[Swift.String]? = nil
                if let preferredCacheClusterAZsContainer = preferredCacheClusterAZsContainer {
                    preferredCacheClusterAZsBuffer = [Swift.String]()
                    for stringContainer0 in preferredCacheClusterAZsContainer {
                        preferredCacheClusterAZsBuffer?.append(stringContainer0)
                    }
                }
                preferredCacheClusterAZs = preferredCacheClusterAZsBuffer
            } else {
                preferredCacheClusterAZs = []
            }
        } else {
            preferredCacheClusterAZs = nil
        }
        let numNodeGroupsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numNodeGroups)
        numNodeGroups = numNodeGroupsDecoded
        let replicasPerNodeGroupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicasPerNodeGroup)
        replicasPerNodeGroup = replicasPerNodeGroupDecoded
        if containerValues.contains(.nodeGroupConfiguration) {
            struct KeyVal0{struct NodeGroupConfiguration{}}
            let nodeGroupConfigurationWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeGroupConfiguration>.CodingKeys.self, forKey: .nodeGroupConfiguration)
            if let nodeGroupConfigurationWrappedContainer = nodeGroupConfigurationWrappedContainer {
                let nodeGroupConfigurationContainer = try nodeGroupConfigurationWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.NodeGroupConfiguration].self, forKey: .member)
                var nodeGroupConfigurationBuffer:[ElastiCacheClientTypes.NodeGroupConfiguration]? = nil
                if let nodeGroupConfigurationContainer = nodeGroupConfigurationContainer {
                    nodeGroupConfigurationBuffer = [ElastiCacheClientTypes.NodeGroupConfiguration]()
                    for structureContainer0 in nodeGroupConfigurationContainer {
                        nodeGroupConfigurationBuffer?.append(structureContainer0)
                    }
                }
                nodeGroupConfiguration = nodeGroupConfigurationBuffer
            } else {
                nodeGroupConfiguration = []
            }
        } else {
            nodeGroupConfiguration = nil
        }
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let cacheParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheParameterGroupName)
        cacheParameterGroupName = cacheParameterGroupNameDecoded
        let cacheSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheSubnetGroupName)
        cacheSubnetGroupName = cacheSubnetGroupNameDecoded
        if containerValues.contains(.cacheSecurityGroupNames) {
            struct KeyVal0{struct CacheSecurityGroupName{}}
            let cacheSecurityGroupNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheSecurityGroupName>.CodingKeys.self, forKey: .cacheSecurityGroupNames)
            if let cacheSecurityGroupNamesWrappedContainer = cacheSecurityGroupNamesWrappedContainer {
                let cacheSecurityGroupNamesContainer = try cacheSecurityGroupNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var cacheSecurityGroupNamesBuffer:[Swift.String]? = nil
                if let cacheSecurityGroupNamesContainer = cacheSecurityGroupNamesContainer {
                    cacheSecurityGroupNamesBuffer = [Swift.String]()
                    for stringContainer0 in cacheSecurityGroupNamesContainer {
                        cacheSecurityGroupNamesBuffer?.append(stringContainer0)
                    }
                }
                cacheSecurityGroupNames = cacheSecurityGroupNamesBuffer
            } else {
                cacheSecurityGroupNames = []
            }
        } else {
            cacheSecurityGroupNames = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[ElastiCacheClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [ElastiCacheClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.snapshotArns) {
            struct KeyVal0{struct SnapshotArn{}}
            let snapshotArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SnapshotArn>.CodingKeys.self, forKey: .snapshotArns)
            if let snapshotArnsWrappedContainer = snapshotArnsWrappedContainer {
                let snapshotArnsContainer = try snapshotArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var snapshotArnsBuffer:[Swift.String]? = nil
                if let snapshotArnsContainer = snapshotArnsContainer {
                    snapshotArnsBuffer = [Swift.String]()
                    for stringContainer0 in snapshotArnsContainer {
                        snapshotArnsBuffer?.append(stringContainer0)
                    }
                }
                snapshotArns = snapshotArnsBuffer
            } else {
                snapshotArns = []
            }
        } else {
            snapshotArns = nil
        }
        let snapshotNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotName)
        snapshotName = snapshotNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let authTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authToken)
        authToken = authTokenDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        if containerValues.contains(.userGroupIds) {
            struct KeyVal0{struct member{}}
            let userGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userGroupIds)
            if let userGroupIdsWrappedContainer = userGroupIdsWrappedContainer {
                let userGroupIdsContainer = try userGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var userGroupIdsBuffer:[Swift.String]? = nil
                if let userGroupIdsContainer = userGroupIdsContainer {
                    userGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in userGroupIdsContainer {
                        userGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                userGroupIds = userGroupIdsBuffer
            } else {
                userGroupIds = []
            }
        } else {
            userGroupIds = nil
        }
        if containerValues.contains(.logDeliveryConfigurations) {
            struct KeyVal0{struct LogDeliveryConfigurationRequest{}}
            let logDeliveryConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LogDeliveryConfigurationRequest>.CodingKeys.self, forKey: .logDeliveryConfigurations)
            if let logDeliveryConfigurationsWrappedContainer = logDeliveryConfigurationsWrappedContainer {
                let logDeliveryConfigurationsContainer = try logDeliveryConfigurationsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.LogDeliveryConfigurationRequest].self, forKey: .member)
                var logDeliveryConfigurationsBuffer:[ElastiCacheClientTypes.LogDeliveryConfigurationRequest]? = nil
                if let logDeliveryConfigurationsContainer = logDeliveryConfigurationsContainer {
                    logDeliveryConfigurationsBuffer = [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]()
                    for structureContainer0 in logDeliveryConfigurationsContainer {
                        logDeliveryConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                logDeliveryConfigurations = logDeliveryConfigurationsBuffer
            } else {
                logDeliveryConfigurations = []
            }
        } else {
            logDeliveryConfigurations = nil
        }
        let dataTieringEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataTieringEnabled)
        dataTieringEnabled = dataTieringEnabledDecoded
    }
}
