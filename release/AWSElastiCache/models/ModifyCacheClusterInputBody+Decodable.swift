// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ModifyCacheClusterInputBody: Swift.Equatable {
    let cacheClusterId: Swift.String?
    let numCacheNodes: Swift.Int?
    let cacheNodeIdsToRemove: [Swift.String]?
    let aZMode: ElastiCacheClientTypes.AZMode?
    let newAvailabilityZones: [Swift.String]?
    let cacheSecurityGroupNames: [Swift.String]?
    let securityGroupIds: [Swift.String]?
    let preferredMaintenanceWindow: Swift.String?
    let notificationTopicArn: Swift.String?
    let cacheParameterGroupName: Swift.String?
    let notificationTopicStatus: Swift.String?
    let applyImmediately: Swift.Bool
    let engineVersion: Swift.String?
    let autoMinorVersionUpgrade: Swift.Bool?
    let snapshotRetentionLimit: Swift.Int?
    let snapshotWindow: Swift.String?
    let cacheNodeType: Swift.String?
    let authToken: Swift.String?
    let authTokenUpdateStrategy: ElastiCacheClientTypes.AuthTokenUpdateStrategyType?
    let logDeliveryConfigurations: [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]?
}

extension ModifyCacheClusterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aZMode = "AZMode"
        case applyImmediately = "ApplyImmediately"
        case authToken = "AuthToken"
        case authTokenUpdateStrategy = "AuthTokenUpdateStrategy"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case cacheClusterId = "CacheClusterId"
        case cacheNodeIdsToRemove = "CacheNodeIdsToRemove"
        case cacheNodeType = "CacheNodeType"
        case cacheParameterGroupName = "CacheParameterGroupName"
        case cacheSecurityGroupNames = "CacheSecurityGroupNames"
        case engineVersion = "EngineVersion"
        case logDeliveryConfigurations = "LogDeliveryConfigurations"
        case newAvailabilityZones = "NewAvailabilityZones"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case numCacheNodes = "NumCacheNodes"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cacheClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheClusterId)
        cacheClusterId = cacheClusterIdDecoded
        let numCacheNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numCacheNodes)
        numCacheNodes = numCacheNodesDecoded
        if containerValues.contains(.cacheNodeIdsToRemove) {
            struct KeyVal0{struct CacheNodeId{}}
            let cacheNodeIdsToRemoveWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheNodeId>.CodingKeys.self, forKey: .cacheNodeIdsToRemove)
            if let cacheNodeIdsToRemoveWrappedContainer = cacheNodeIdsToRemoveWrappedContainer {
                let cacheNodeIdsToRemoveContainer = try cacheNodeIdsToRemoveWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var cacheNodeIdsToRemoveBuffer:[Swift.String]? = nil
                if let cacheNodeIdsToRemoveContainer = cacheNodeIdsToRemoveContainer {
                    cacheNodeIdsToRemoveBuffer = [Swift.String]()
                    for stringContainer0 in cacheNodeIdsToRemoveContainer {
                        cacheNodeIdsToRemoveBuffer?.append(stringContainer0)
                    }
                }
                cacheNodeIdsToRemove = cacheNodeIdsToRemoveBuffer
            } else {
                cacheNodeIdsToRemove = []
            }
        } else {
            cacheNodeIdsToRemove = nil
        }
        let aZModeDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.AZMode.self, forKey: .aZMode)
        aZMode = aZModeDecoded
        if containerValues.contains(.newAvailabilityZones) {
            struct KeyVal0{struct PreferredAvailabilityZone{}}
            let newAvailabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PreferredAvailabilityZone>.CodingKeys.self, forKey: .newAvailabilityZones)
            if let newAvailabilityZonesWrappedContainer = newAvailabilityZonesWrappedContainer {
                let newAvailabilityZonesContainer = try newAvailabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var newAvailabilityZonesBuffer:[Swift.String]? = nil
                if let newAvailabilityZonesContainer = newAvailabilityZonesContainer {
                    newAvailabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in newAvailabilityZonesContainer {
                        newAvailabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                newAvailabilityZones = newAvailabilityZonesBuffer
            } else {
                newAvailabilityZones = []
            }
        } else {
            newAvailabilityZones = nil
        }
        if containerValues.contains(.cacheSecurityGroupNames) {
            struct KeyVal0{struct CacheSecurityGroupName{}}
            let cacheSecurityGroupNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheSecurityGroupName>.CodingKeys.self, forKey: .cacheSecurityGroupNames)
            if let cacheSecurityGroupNamesWrappedContainer = cacheSecurityGroupNamesWrappedContainer {
                let cacheSecurityGroupNamesContainer = try cacheSecurityGroupNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var cacheSecurityGroupNamesBuffer:[Swift.String]? = nil
                if let cacheSecurityGroupNamesContainer = cacheSecurityGroupNamesContainer {
                    cacheSecurityGroupNamesBuffer = [Swift.String]()
                    for stringContainer0 in cacheSecurityGroupNamesContainer {
                        cacheSecurityGroupNamesBuffer?.append(stringContainer0)
                    }
                }
                cacheSecurityGroupNames = cacheSecurityGroupNamesBuffer
            } else {
                cacheSecurityGroupNames = []
            }
        } else {
            cacheSecurityGroupNames = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let cacheParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheParameterGroupName)
        cacheParameterGroupName = cacheParameterGroupNameDecoded
        let notificationTopicStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationTopicStatus)
        notificationTopicStatus = notificationTopicStatusDecoded
        let applyImmediatelyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .applyImmediately)
        applyImmediately = applyImmediatelyDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let authTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authToken)
        authToken = authTokenDecoded
        let authTokenUpdateStrategyDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.AuthTokenUpdateStrategyType.self, forKey: .authTokenUpdateStrategy)
        authTokenUpdateStrategy = authTokenUpdateStrategyDecoded
        if containerValues.contains(.logDeliveryConfigurations) {
            struct KeyVal0{struct LogDeliveryConfigurationRequest{}}
            let logDeliveryConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LogDeliveryConfigurationRequest>.CodingKeys.self, forKey: .logDeliveryConfigurations)
            if let logDeliveryConfigurationsWrappedContainer = logDeliveryConfigurationsWrappedContainer {
                let logDeliveryConfigurationsContainer = try logDeliveryConfigurationsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.LogDeliveryConfigurationRequest].self, forKey: .member)
                var logDeliveryConfigurationsBuffer:[ElastiCacheClientTypes.LogDeliveryConfigurationRequest]? = nil
                if let logDeliveryConfigurationsContainer = logDeliveryConfigurationsContainer {
                    logDeliveryConfigurationsBuffer = [ElastiCacheClientTypes.LogDeliveryConfigurationRequest]()
                    for structureContainer0 in logDeliveryConfigurationsContainer {
                        logDeliveryConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                logDeliveryConfigurations = logDeliveryConfigurationsBuffer
            } else {
                logDeliveryConfigurations = []
            }
        } else {
            logDeliveryConfigurations = nil
        }
    }
}
