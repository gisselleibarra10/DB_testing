// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ElastiCacheClientTypes.ReplicationGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case atRestEncryptionEnabled = "AtRestEncryptionEnabled"
        case authTokenEnabled = "AuthTokenEnabled"
        case authTokenLastModifiedDate = "AuthTokenLastModifiedDate"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticFailover = "AutomaticFailover"
        case cacheNodeType = "CacheNodeType"
        case clusterEnabled = "ClusterEnabled"
        case configurationEndpoint = "ConfigurationEndpoint"
        case dataTiering = "DataTiering"
        case description = "Description"
        case globalReplicationGroupInfo = "GlobalReplicationGroupInfo"
        case kmsKeyId = "KmsKeyId"
        case logDeliveryConfigurations = "LogDeliveryConfigurations"
        case memberClusters = "MemberClusters"
        case memberClustersOutpostArns = "MemberClustersOutpostArns"
        case multiAZ = "MultiAZ"
        case nodeGroups = "NodeGroups"
        case pendingModifiedValues = "PendingModifiedValues"
        case replicationGroupCreateTime = "ReplicationGroupCreateTime"
        case replicationGroupId = "ReplicationGroupId"
        case snapshotRetentionLimit = "SnapshotRetentionLimit"
        case snapshotWindow = "SnapshotWindow"
        case snapshottingClusterId = "SnapshottingClusterId"
        case status = "Status"
        case transitEncryptionEnabled = "TransitEncryptionEnabled"
        case userGroupIds = "UserGroupIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aRN = aRN {
            try container.encode(aRN, forKey: ClientRuntime.Key("ARN"))
        }
        if let atRestEncryptionEnabled = atRestEncryptionEnabled {
            try container.encode(atRestEncryptionEnabled, forKey: ClientRuntime.Key("AtRestEncryptionEnabled"))
        }
        if let authTokenEnabled = authTokenEnabled {
            try container.encode(authTokenEnabled, forKey: ClientRuntime.Key("AuthTokenEnabled"))
        }
        if let authTokenLastModifiedDate = authTokenLastModifiedDate {
            try container.encode(ClientRuntime.TimestampWrapper(authTokenLastModifiedDate, format: .dateTime), forKey: ClientRuntime.Key("authTokenLastModifiedDate"))
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automaticFailover = automaticFailover {
            try container.encode(automaticFailover, forKey: ClientRuntime.Key("AutomaticFailover"))
        }
        if let cacheNodeType = cacheNodeType {
            try container.encode(cacheNodeType, forKey: ClientRuntime.Key("CacheNodeType"))
        }
        if let clusterEnabled = clusterEnabled {
            try container.encode(clusterEnabled, forKey: ClientRuntime.Key("ClusterEnabled"))
        }
        if let configurationEndpoint = configurationEndpoint {
            try container.encode(configurationEndpoint, forKey: ClientRuntime.Key("ConfigurationEndpoint"))
        }
        if let dataTiering = dataTiering {
            try container.encode(dataTiering, forKey: ClientRuntime.Key("DataTiering"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let globalReplicationGroupInfo = globalReplicationGroupInfo {
            try container.encode(globalReplicationGroupInfo, forKey: ClientRuntime.Key("GlobalReplicationGroupInfo"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let logDeliveryConfigurations = logDeliveryConfigurations {
            var logDeliveryConfigurationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LogDeliveryConfigurations"))
            for (index0, logdeliveryconfiguration0) in logDeliveryConfigurations.enumerated() {
                try logDeliveryConfigurationsContainer.encode(logdeliveryconfiguration0, forKey: ClientRuntime.Key("LogDeliveryConfiguration.\(index0.advanced(by: 1))"))
            }
        }
        if let memberClusters = memberClusters {
            var memberClustersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MemberClusters"))
            for (index0, string0) in memberClusters.enumerated() {
                try memberClustersContainer.encode(string0, forKey: ClientRuntime.Key("ClusterId.\(index0.advanced(by: 1))"))
            }
        }
        if let memberClustersOutpostArns = memberClustersOutpostArns {
            var memberClustersOutpostArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MemberClustersOutpostArns"))
            for (index0, string0) in memberClustersOutpostArns.enumerated() {
                try memberClustersOutpostArnsContainer.encode(string0, forKey: ClientRuntime.Key("ReplicationGroupOutpostArn.\(index0.advanced(by: 1))"))
            }
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let nodeGroups = nodeGroups {
            var nodeGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NodeGroups"))
            for (index0, nodegroup0) in nodeGroups.enumerated() {
                try nodeGroupsContainer.encode(nodegroup0, forKey: ClientRuntime.Key("NodeGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let replicationGroupCreateTime = replicationGroupCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(replicationGroupCreateTime, format: .dateTime), forKey: ClientRuntime.Key("replicationGroupCreateTime"))
        }
        if let replicationGroupId = replicationGroupId {
            try container.encode(replicationGroupId, forKey: ClientRuntime.Key("ReplicationGroupId"))
        }
        if let snapshotRetentionLimit = snapshotRetentionLimit {
            try container.encode(snapshotRetentionLimit, forKey: ClientRuntime.Key("SnapshotRetentionLimit"))
        }
        if let snapshotWindow = snapshotWindow {
            try container.encode(snapshotWindow, forKey: ClientRuntime.Key("SnapshotWindow"))
        }
        if let snapshottingClusterId = snapshottingClusterId {
            try container.encode(snapshottingClusterId, forKey: ClientRuntime.Key("SnapshottingClusterId"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let transitEncryptionEnabled = transitEncryptionEnabled {
            try container.encode(transitEncryptionEnabled, forKey: ClientRuntime.Key("TransitEncryptionEnabled"))
        }
        if let userGroupIds = userGroupIds {
            var userGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("UserGroupIds"))
            for (index0, usergroupid0) in userGroupIds.enumerated() {
                try userGroupIdsContainer.encode(usergroupid0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationGroupId)
        replicationGroupId = replicationGroupIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let globalReplicationGroupInfoDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.GlobalReplicationGroupInfo.self, forKey: .globalReplicationGroupInfo)
        globalReplicationGroupInfo = globalReplicationGroupInfoDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.ReplicationGroupPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        if containerValues.contains(.memberClusters) {
            struct KeyVal0{struct ClusterId{}}
            let memberClustersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterId>.CodingKeys.self, forKey: .memberClusters)
            if let memberClustersWrappedContainer = memberClustersWrappedContainer {
                let memberClustersContainer = try memberClustersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var memberClustersBuffer:[Swift.String]? = nil
                if let memberClustersContainer = memberClustersContainer {
                    memberClustersBuffer = [Swift.String]()
                    for stringContainer0 in memberClustersContainer {
                        memberClustersBuffer?.append(stringContainer0)
                    }
                }
                memberClusters = memberClustersBuffer
            } else {
                memberClusters = []
            }
        } else {
            memberClusters = nil
        }
        if containerValues.contains(.nodeGroups) {
            struct KeyVal0{struct NodeGroup{}}
            let nodeGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeGroup>.CodingKeys.self, forKey: .nodeGroups)
            if let nodeGroupsWrappedContainer = nodeGroupsWrappedContainer {
                let nodeGroupsContainer = try nodeGroupsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.NodeGroup].self, forKey: .member)
                var nodeGroupsBuffer:[ElastiCacheClientTypes.NodeGroup]? = nil
                if let nodeGroupsContainer = nodeGroupsContainer {
                    nodeGroupsBuffer = [ElastiCacheClientTypes.NodeGroup]()
                    for structureContainer0 in nodeGroupsContainer {
                        nodeGroupsBuffer?.append(structureContainer0)
                    }
                }
                nodeGroups = nodeGroupsBuffer
            } else {
                nodeGroups = []
            }
        } else {
            nodeGroups = nil
        }
        let snapshottingClusterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshottingClusterId)
        snapshottingClusterId = snapshottingClusterIdDecoded
        let automaticFailoverDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.AutomaticFailoverStatus.self, forKey: .automaticFailover)
        automaticFailover = automaticFailoverDecoded
        let multiAZDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.MultiAZStatus.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let configurationEndpointDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.Endpoint.self, forKey: .configurationEndpoint)
        configurationEndpoint = configurationEndpointDecoded
        let snapshotRetentionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .snapshotRetentionLimit)
        snapshotRetentionLimit = snapshotRetentionLimitDecoded
        let snapshotWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotWindow)
        snapshotWindow = snapshotWindowDecoded
        let clusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .clusterEnabled)
        clusterEnabled = clusterEnabledDecoded
        let cacheNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNodeType)
        cacheNodeType = cacheNodeTypeDecoded
        let authTokenEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authTokenEnabled)
        authTokenEnabled = authTokenEnabledDecoded
        let authTokenLastModifiedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authTokenLastModifiedDate)
        var authTokenLastModifiedDateBuffer:ClientRuntime.Date? = nil
        if let authTokenLastModifiedDateDecoded = authTokenLastModifiedDateDecoded {
            authTokenLastModifiedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(authTokenLastModifiedDateDecoded, format: .dateTime)
        }
        authTokenLastModifiedDate = authTokenLastModifiedDateBuffer
        let transitEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        if containerValues.contains(.memberClustersOutpostArns) {
            struct KeyVal0{struct ReplicationGroupOutpostArn{}}
            let memberClustersOutpostArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReplicationGroupOutpostArn>.CodingKeys.self, forKey: .memberClustersOutpostArns)
            if let memberClustersOutpostArnsWrappedContainer = memberClustersOutpostArnsWrappedContainer {
                let memberClustersOutpostArnsContainer = try memberClustersOutpostArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var memberClustersOutpostArnsBuffer:[Swift.String]? = nil
                if let memberClustersOutpostArnsContainer = memberClustersOutpostArnsContainer {
                    memberClustersOutpostArnsBuffer = [Swift.String]()
                    for stringContainer0 in memberClustersOutpostArnsContainer {
                        memberClustersOutpostArnsBuffer?.append(stringContainer0)
                    }
                }
                memberClustersOutpostArns = memberClustersOutpostArnsBuffer
            } else {
                memberClustersOutpostArns = []
            }
        } else {
            memberClustersOutpostArns = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        if containerValues.contains(.userGroupIds) {
            struct KeyVal0{struct member{}}
            let userGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .userGroupIds)
            if let userGroupIdsWrappedContainer = userGroupIdsWrappedContainer {
                let userGroupIdsContainer = try userGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var userGroupIdsBuffer:[Swift.String]? = nil
                if let userGroupIdsContainer = userGroupIdsContainer {
                    userGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in userGroupIdsContainer {
                        userGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                userGroupIds = userGroupIdsBuffer
            } else {
                userGroupIds = []
            }
        } else {
            userGroupIds = nil
        }
        if containerValues.contains(.logDeliveryConfigurations) {
            struct KeyVal0{struct LogDeliveryConfiguration{}}
            let logDeliveryConfigurationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LogDeliveryConfiguration>.CodingKeys.self, forKey: .logDeliveryConfigurations)
            if let logDeliveryConfigurationsWrappedContainer = logDeliveryConfigurationsWrappedContainer {
                let logDeliveryConfigurationsContainer = try logDeliveryConfigurationsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.LogDeliveryConfiguration].self, forKey: .member)
                var logDeliveryConfigurationsBuffer:[ElastiCacheClientTypes.LogDeliveryConfiguration]? = nil
                if let logDeliveryConfigurationsContainer = logDeliveryConfigurationsContainer {
                    logDeliveryConfigurationsBuffer = [ElastiCacheClientTypes.LogDeliveryConfiguration]()
                    for structureContainer0 in logDeliveryConfigurationsContainer {
                        logDeliveryConfigurationsBuffer?.append(structureContainer0)
                    }
                }
                logDeliveryConfigurations = logDeliveryConfigurationsBuffer
            } else {
                logDeliveryConfigurations = []
            }
        } else {
            logDeliveryConfigurations = nil
        }
        let replicationGroupCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationGroupCreateTime)
        var replicationGroupCreateTimeBuffer:ClientRuntime.Date? = nil
        if let replicationGroupCreateTimeDecoded = replicationGroupCreateTimeDecoded {
            replicationGroupCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(replicationGroupCreateTimeDecoded, format: .dateTime)
        }
        replicationGroupCreateTime = replicationGroupCreateTimeBuffer
        let dataTieringDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.DataTieringStatus.self, forKey: .dataTiering)
        dataTiering = dataTieringDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
    }
}
