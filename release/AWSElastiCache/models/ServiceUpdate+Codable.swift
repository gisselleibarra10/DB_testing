// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ElastiCacheClientTypes.ServiceUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoUpdateAfterRecommendedApplyByDate = "AutoUpdateAfterRecommendedApplyByDate"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case estimatedUpdateTime = "EstimatedUpdateTime"
        case serviceUpdateDescription = "ServiceUpdateDescription"
        case serviceUpdateEndDate = "ServiceUpdateEndDate"
        case serviceUpdateName = "ServiceUpdateName"
        case serviceUpdateRecommendedApplyByDate = "ServiceUpdateRecommendedApplyByDate"
        case serviceUpdateReleaseDate = "ServiceUpdateReleaseDate"
        case serviceUpdateSeverity = "ServiceUpdateSeverity"
        case serviceUpdateStatus = "ServiceUpdateStatus"
        case serviceUpdateType = "ServiceUpdateType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoUpdateAfterRecommendedApplyByDate = autoUpdateAfterRecommendedApplyByDate {
            try container.encode(autoUpdateAfterRecommendedApplyByDate, forKey: ClientRuntime.Key("AutoUpdateAfterRecommendedApplyByDate"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let estimatedUpdateTime = estimatedUpdateTime {
            try container.encode(estimatedUpdateTime, forKey: ClientRuntime.Key("EstimatedUpdateTime"))
        }
        if let serviceUpdateDescription = serviceUpdateDescription {
            try container.encode(serviceUpdateDescription, forKey: ClientRuntime.Key("ServiceUpdateDescription"))
        }
        if let serviceUpdateEndDate = serviceUpdateEndDate {
            try container.encode(ClientRuntime.TimestampWrapper(serviceUpdateEndDate, format: .dateTime), forKey: ClientRuntime.Key("serviceUpdateEndDate"))
        }
        if let serviceUpdateName = serviceUpdateName {
            try container.encode(serviceUpdateName, forKey: ClientRuntime.Key("ServiceUpdateName"))
        }
        if let serviceUpdateRecommendedApplyByDate = serviceUpdateRecommendedApplyByDate {
            try container.encode(ClientRuntime.TimestampWrapper(serviceUpdateRecommendedApplyByDate, format: .dateTime), forKey: ClientRuntime.Key("serviceUpdateRecommendedApplyByDate"))
        }
        if let serviceUpdateReleaseDate = serviceUpdateReleaseDate {
            try container.encode(ClientRuntime.TimestampWrapper(serviceUpdateReleaseDate, format: .dateTime), forKey: ClientRuntime.Key("serviceUpdateReleaseDate"))
        }
        if let serviceUpdateSeverity = serviceUpdateSeverity {
            try container.encode(serviceUpdateSeverity, forKey: ClientRuntime.Key("ServiceUpdateSeverity"))
        }
        if let serviceUpdateStatus = serviceUpdateStatus {
            try container.encode(serviceUpdateStatus, forKey: ClientRuntime.Key("ServiceUpdateStatus"))
        }
        if let serviceUpdateType = serviceUpdateType {
            try container.encode(serviceUpdateType, forKey: ClientRuntime.Key("ServiceUpdateType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceUpdateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateName)
        serviceUpdateName = serviceUpdateNameDecoded
        let serviceUpdateReleaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateReleaseDate)
        var serviceUpdateReleaseDateBuffer:ClientRuntime.Date? = nil
        if let serviceUpdateReleaseDateDecoded = serviceUpdateReleaseDateDecoded {
            serviceUpdateReleaseDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(serviceUpdateReleaseDateDecoded, format: .dateTime)
        }
        serviceUpdateReleaseDate = serviceUpdateReleaseDateBuffer
        let serviceUpdateEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateEndDate)
        var serviceUpdateEndDateBuffer:ClientRuntime.Date? = nil
        if let serviceUpdateEndDateDecoded = serviceUpdateEndDateDecoded {
            serviceUpdateEndDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(serviceUpdateEndDateDecoded, format: .dateTime)
        }
        serviceUpdateEndDate = serviceUpdateEndDateBuffer
        let serviceUpdateSeverityDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.ServiceUpdateSeverity.self, forKey: .serviceUpdateSeverity)
        serviceUpdateSeverity = serviceUpdateSeverityDecoded
        let serviceUpdateRecommendedApplyByDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateRecommendedApplyByDate)
        var serviceUpdateRecommendedApplyByDateBuffer:ClientRuntime.Date? = nil
        if let serviceUpdateRecommendedApplyByDateDecoded = serviceUpdateRecommendedApplyByDateDecoded {
            serviceUpdateRecommendedApplyByDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(serviceUpdateRecommendedApplyByDateDecoded, format: .dateTime)
        }
        serviceUpdateRecommendedApplyByDate = serviceUpdateRecommendedApplyByDateBuffer
        let serviceUpdateStatusDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.ServiceUpdateStatus.self, forKey: .serviceUpdateStatus)
        serviceUpdateStatus = serviceUpdateStatusDecoded
        let serviceUpdateDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUpdateDescription)
        serviceUpdateDescription = serviceUpdateDescriptionDecoded
        let serviceUpdateTypeDecoded = try containerValues.decodeIfPresent(ElastiCacheClientTypes.ServiceUpdateType.self, forKey: .serviceUpdateType)
        serviceUpdateType = serviceUpdateTypeDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let autoUpdateAfterRecommendedApplyByDateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdateAfterRecommendedApplyByDate)
        autoUpdateAfterRecommendedApplyByDate = autoUpdateAfterRecommendedApplyByDateDecoded
        let estimatedUpdateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedUpdateTime)
        estimatedUpdateTime = estimatedUpdateTimeDecoded
    }
}
