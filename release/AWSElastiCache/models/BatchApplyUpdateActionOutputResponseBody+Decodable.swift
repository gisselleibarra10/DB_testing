// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct BatchApplyUpdateActionOutputResponseBody: Swift.Equatable {
    let processedUpdateActions: [ElastiCacheClientTypes.ProcessedUpdateAction]?
    let unprocessedUpdateActions: [ElastiCacheClientTypes.UnprocessedUpdateAction]?
}

extension BatchApplyUpdateActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processedUpdateActions = "ProcessedUpdateActions"
        case unprocessedUpdateActions = "UnprocessedUpdateActions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("BatchApplyUpdateActionResult"))
        if containerValues.contains(.processedUpdateActions) {
            struct KeyVal0{struct ProcessedUpdateAction{}}
            let processedUpdateActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ProcessedUpdateAction>.CodingKeys.self, forKey: .processedUpdateActions)
            if let processedUpdateActionsWrappedContainer = processedUpdateActionsWrappedContainer {
                let processedUpdateActionsContainer = try processedUpdateActionsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.ProcessedUpdateAction].self, forKey: .member)
                var processedUpdateActionsBuffer:[ElastiCacheClientTypes.ProcessedUpdateAction]? = nil
                if let processedUpdateActionsContainer = processedUpdateActionsContainer {
                    processedUpdateActionsBuffer = [ElastiCacheClientTypes.ProcessedUpdateAction]()
                    for structureContainer0 in processedUpdateActionsContainer {
                        processedUpdateActionsBuffer?.append(structureContainer0)
                    }
                }
                processedUpdateActions = processedUpdateActionsBuffer
            } else {
                processedUpdateActions = []
            }
        } else {
            processedUpdateActions = nil
        }
        if containerValues.contains(.unprocessedUpdateActions) {
            struct KeyVal0{struct UnprocessedUpdateAction{}}
            let unprocessedUpdateActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UnprocessedUpdateAction>.CodingKeys.self, forKey: .unprocessedUpdateActions)
            if let unprocessedUpdateActionsWrappedContainer = unprocessedUpdateActionsWrappedContainer {
                let unprocessedUpdateActionsContainer = try unprocessedUpdateActionsWrappedContainer.decodeIfPresent([ElastiCacheClientTypes.UnprocessedUpdateAction].self, forKey: .member)
                var unprocessedUpdateActionsBuffer:[ElastiCacheClientTypes.UnprocessedUpdateAction]? = nil
                if let unprocessedUpdateActionsContainer = unprocessedUpdateActionsContainer {
                    unprocessedUpdateActionsBuffer = [ElastiCacheClientTypes.UnprocessedUpdateAction]()
                    for structureContainer0 in unprocessedUpdateActionsContainer {
                        unprocessedUpdateActionsBuffer?.append(structureContainer0)
                    }
                }
                unprocessedUpdateActions = unprocessedUpdateActionsBuffer
            } else {
                unprocessedUpdateActions = []
            }
        } else {
            unprocessedUpdateActions = nil
        }
    }
}
