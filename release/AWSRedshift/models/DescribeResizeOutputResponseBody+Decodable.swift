// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct DescribeResizeOutputResponseBody: Swift.Equatable {
    let targetNodeType: Swift.String?
    let targetNumberOfNodes: Swift.Int?
    let targetClusterType: Swift.String?
    let status: Swift.String?
    let importTablesCompleted: [Swift.String]?
    let importTablesInProgress: [Swift.String]?
    let importTablesNotStarted: [Swift.String]?
    let avgResizeRateInMegaBytesPerSecond: Swift.Double?
    let totalResizeDataInMegaBytes: Swift.Int?
    let progressInMegaBytes: Swift.Int?
    let elapsedTimeInSeconds: Swift.Int?
    let estimatedTimeToCompletionInSeconds: Swift.Int?
    let resizeType: Swift.String?
    let message: Swift.String?
    let targetEncryptionType: Swift.String?
    let dataTransferProgressPercent: Swift.Double?
}

extension DescribeResizeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avgResizeRateInMegaBytesPerSecond = "AvgResizeRateInMegaBytesPerSecond"
        case dataTransferProgressPercent = "DataTransferProgressPercent"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case estimatedTimeToCompletionInSeconds = "EstimatedTimeToCompletionInSeconds"
        case importTablesCompleted = "ImportTablesCompleted"
        case importTablesInProgress = "ImportTablesInProgress"
        case importTablesNotStarted = "ImportTablesNotStarted"
        case message = "Message"
        case progressInMegaBytes = "ProgressInMegaBytes"
        case resizeType = "ResizeType"
        case status = "Status"
        case targetClusterType = "TargetClusterType"
        case targetEncryptionType = "TargetEncryptionType"
        case targetNodeType = "TargetNodeType"
        case targetNumberOfNodes = "TargetNumberOfNodes"
        case totalResizeDataInMegaBytes = "TotalResizeDataInMegaBytes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("DescribeResizeResult"))
        let targetNodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetNodeType)
        targetNodeType = targetNodeTypeDecoded
        let targetNumberOfNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetNumberOfNodes)
        targetNumberOfNodes = targetNumberOfNodesDecoded
        let targetClusterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetClusterType)
        targetClusterType = targetClusterTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        if containerValues.contains(.importTablesCompleted) {
            struct KeyVal0{struct member{}}
            let importTablesCompletedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesCompleted)
            if let importTablesCompletedWrappedContainer = importTablesCompletedWrappedContainer {
                let importTablesCompletedContainer = try importTablesCompletedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesCompletedBuffer:[Swift.String]? = nil
                if let importTablesCompletedContainer = importTablesCompletedContainer {
                    importTablesCompletedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesCompletedContainer {
                        importTablesCompletedBuffer?.append(stringContainer0)
                    }
                }
                importTablesCompleted = importTablesCompletedBuffer
            } else {
                importTablesCompleted = []
            }
        } else {
            importTablesCompleted = nil
        }
        if containerValues.contains(.importTablesInProgress) {
            struct KeyVal0{struct member{}}
            let importTablesInProgressWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesInProgress)
            if let importTablesInProgressWrappedContainer = importTablesInProgressWrappedContainer {
                let importTablesInProgressContainer = try importTablesInProgressWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesInProgressBuffer:[Swift.String]? = nil
                if let importTablesInProgressContainer = importTablesInProgressContainer {
                    importTablesInProgressBuffer = [Swift.String]()
                    for stringContainer0 in importTablesInProgressContainer {
                        importTablesInProgressBuffer?.append(stringContainer0)
                    }
                }
                importTablesInProgress = importTablesInProgressBuffer
            } else {
                importTablesInProgress = []
            }
        } else {
            importTablesInProgress = nil
        }
        if containerValues.contains(.importTablesNotStarted) {
            struct KeyVal0{struct member{}}
            let importTablesNotStartedWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .importTablesNotStarted)
            if let importTablesNotStartedWrappedContainer = importTablesNotStartedWrappedContainer {
                let importTablesNotStartedContainer = try importTablesNotStartedWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var importTablesNotStartedBuffer:[Swift.String]? = nil
                if let importTablesNotStartedContainer = importTablesNotStartedContainer {
                    importTablesNotStartedBuffer = [Swift.String]()
                    for stringContainer0 in importTablesNotStartedContainer {
                        importTablesNotStartedBuffer?.append(stringContainer0)
                    }
                }
                importTablesNotStarted = importTablesNotStartedBuffer
            } else {
                importTablesNotStarted = []
            }
        } else {
            importTablesNotStarted = nil
        }
        let avgResizeRateInMegaBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .avgResizeRateInMegaBytesPerSecond)
        avgResizeRateInMegaBytesPerSecond = avgResizeRateInMegaBytesPerSecondDecoded
        let totalResizeDataInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalResizeDataInMegaBytes)
        totalResizeDataInMegaBytes = totalResizeDataInMegaBytesDecoded
        let progressInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .progressInMegaBytes)
        progressInMegaBytes = progressInMegaBytesDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let estimatedTimeToCompletionInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .estimatedTimeToCompletionInSeconds)
        estimatedTimeToCompletionInSeconds = estimatedTimeToCompletionInSecondsDecoded
        let resizeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resizeType)
        resizeType = resizeTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let targetEncryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetEncryptionType)
        targetEncryptionType = targetEncryptionTypeDecoded
        let dataTransferProgressPercentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .dataTransferProgressPercent)
        dataTransferProgressPercent = dataTransferProgressPercentDecoded
    }
}
