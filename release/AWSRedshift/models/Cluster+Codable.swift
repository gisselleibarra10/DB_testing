// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RedshiftClientTypes.Cluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowVersionUpgrade = "AllowVersionUpgrade"
        case aquaConfiguration = "AquaConfiguration"
        case automatedSnapshotRetentionPeriod = "AutomatedSnapshotRetentionPeriod"
        case availabilityZone = "AvailabilityZone"
        case availabilityZoneRelocationStatus = "AvailabilityZoneRelocationStatus"
        case clusterAvailabilityStatus = "ClusterAvailabilityStatus"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterNamespaceArn = "ClusterNamespaceArn"
        case clusterNodes = "ClusterNodes"
        case clusterParameterGroups = "ClusterParameterGroups"
        case clusterPublicKey = "ClusterPublicKey"
        case clusterRevisionNumber = "ClusterRevisionNumber"
        case clusterSecurityGroups = "ClusterSecurityGroups"
        case clusterSnapshotCopyStatus = "ClusterSnapshotCopyStatus"
        case clusterStatus = "ClusterStatus"
        case clusterSubnetGroupName = "ClusterSubnetGroupName"
        case clusterVersion = "ClusterVersion"
        case dBName = "DBName"
        case dataTransferProgress = "DataTransferProgress"
        case defaultIamRoleArn = "DefaultIamRoleArn"
        case deferredMaintenanceWindows = "DeferredMaintenanceWindows"
        case elasticIpStatus = "ElasticIpStatus"
        case elasticResizeNumberOfNodeOptions = "ElasticResizeNumberOfNodeOptions"
        case encrypted = "Encrypted"
        case endpoint = "Endpoint"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case expectedNextSnapshotScheduleTime = "ExpectedNextSnapshotScheduleTime"
        case expectedNextSnapshotScheduleTimeStatus = "ExpectedNextSnapshotScheduleTimeStatus"
        case hsmStatus = "HsmStatus"
        case iamRoles = "IamRoles"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case modifyStatus = "ModifyStatus"
        case nextMaintenanceWindowStartTime = "NextMaintenanceWindowStartTime"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case pendingActions = "PendingActions"
        case pendingModifiedValues = "PendingModifiedValues"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case reservedNodeExchangeStatus = "ReservedNodeExchangeStatus"
        case resizeInfo = "ResizeInfo"
        case restoreStatus = "RestoreStatus"
        case snapshotScheduleIdentifier = "SnapshotScheduleIdentifier"
        case snapshotScheduleState = "SnapshotScheduleState"
        case tags = "Tags"
        case totalStorageCapacityInMegaBytes = "TotalStorageCapacityInMegaBytes"
        case vpcId = "VpcId"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if allowVersionUpgrade != false {
            try container.encode(allowVersionUpgrade, forKey: ClientRuntime.Key("AllowVersionUpgrade"))
        }
        if let aquaConfiguration = aquaConfiguration {
            try container.encode(aquaConfiguration, forKey: ClientRuntime.Key("AquaConfiguration"))
        }
        if automatedSnapshotRetentionPeriod != 0 {
            try container.encode(automatedSnapshotRetentionPeriod, forKey: ClientRuntime.Key("AutomatedSnapshotRetentionPeriod"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneRelocationStatus = availabilityZoneRelocationStatus {
            try container.encode(availabilityZoneRelocationStatus, forKey: ClientRuntime.Key("AvailabilityZoneRelocationStatus"))
        }
        if let clusterAvailabilityStatus = clusterAvailabilityStatus {
            try container.encode(clusterAvailabilityStatus, forKey: ClientRuntime.Key("ClusterAvailabilityStatus"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterNamespaceArn = clusterNamespaceArn {
            try container.encode(clusterNamespaceArn, forKey: ClientRuntime.Key("ClusterNamespaceArn"))
        }
        if let clusterNodes = clusterNodes {
            var clusterNodesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterNodes"))
            for (index0, clusternode0) in clusterNodes.enumerated() {
                try clusterNodesContainer.encode(clusternode0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterParameterGroups = clusterParameterGroups {
            var clusterParameterGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterParameterGroups"))
            for (index0, clusterparametergroupstatus0) in clusterParameterGroups.enumerated() {
                try clusterParameterGroupsContainer.encode(clusterparametergroupstatus0, forKey: ClientRuntime.Key("ClusterParameterGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterPublicKey = clusterPublicKey {
            try container.encode(clusterPublicKey, forKey: ClientRuntime.Key("ClusterPublicKey"))
        }
        if let clusterRevisionNumber = clusterRevisionNumber {
            try container.encode(clusterRevisionNumber, forKey: ClientRuntime.Key("ClusterRevisionNumber"))
        }
        if let clusterSecurityGroups = clusterSecurityGroups {
            var clusterSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ClusterSecurityGroups"))
            for (index0, clustersecuritygroupmembership0) in clusterSecurityGroups.enumerated() {
                try clusterSecurityGroupsContainer.encode(clustersecuritygroupmembership0, forKey: ClientRuntime.Key("ClusterSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let clusterSnapshotCopyStatus = clusterSnapshotCopyStatus {
            try container.encode(clusterSnapshotCopyStatus, forKey: ClientRuntime.Key("ClusterSnapshotCopyStatus"))
        }
        if let clusterStatus = clusterStatus {
            try container.encode(clusterStatus, forKey: ClientRuntime.Key("ClusterStatus"))
        }
        if let clusterSubnetGroupName = clusterSubnetGroupName {
            try container.encode(clusterSubnetGroupName, forKey: ClientRuntime.Key("ClusterSubnetGroupName"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if let dataTransferProgress = dataTransferProgress {
            try container.encode(dataTransferProgress, forKey: ClientRuntime.Key("DataTransferProgress"))
        }
        if let defaultIamRoleArn = defaultIamRoleArn {
            try container.encode(defaultIamRoleArn, forKey: ClientRuntime.Key("DefaultIamRoleArn"))
        }
        if let deferredMaintenanceWindows = deferredMaintenanceWindows {
            var deferredMaintenanceWindowsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DeferredMaintenanceWindows"))
            for (index0, deferredmaintenancewindow0) in deferredMaintenanceWindows.enumerated() {
                try deferredMaintenanceWindowsContainer.encode(deferredmaintenancewindow0, forKey: ClientRuntime.Key("DeferredMaintenanceWindow.\(index0.advanced(by: 1))"))
            }
        }
        if let elasticIpStatus = elasticIpStatus {
            try container.encode(elasticIpStatus, forKey: ClientRuntime.Key("ElasticIpStatus"))
        }
        if let elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptions {
            try container.encode(elasticResizeNumberOfNodeOptions, forKey: ClientRuntime.Key("ElasticResizeNumberOfNodeOptions"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if let expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTime {
            try container.encode(ClientRuntime.TimestampWrapper(expectedNextSnapshotScheduleTime, format: .dateTime), forKey: ClientRuntime.Key("expectedNextSnapshotScheduleTime"))
        }
        if let expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatus {
            try container.encode(expectedNextSnapshotScheduleTimeStatus, forKey: ClientRuntime.Key("ExpectedNextSnapshotScheduleTimeStatus"))
        }
        if let hsmStatus = hsmStatus {
            try container.encode(hsmStatus, forKey: ClientRuntime.Key("HsmStatus"))
        }
        if let iamRoles = iamRoles {
            var iamRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IamRoles"))
            for (index0, clusteriamrole0) in iamRoles.enumerated() {
                try iamRolesContainer.encode(clusteriamrole0, forKey: ClientRuntime.Key("ClusterIamRole.\(index0.advanced(by: 1))"))
            }
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if manualSnapshotRetentionPeriod != 0 {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let modifyStatus = modifyStatus {
            try container.encode(modifyStatus, forKey: ClientRuntime.Key("ModifyStatus"))
        }
        if let nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(nextMaintenanceWindowStartTime, format: .dateTime), forKey: ClientRuntime.Key("nextMaintenanceWindowStartTime"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let pendingActions = pendingActions {
            var pendingActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PendingActions"))
            for (index0, string0) in pendingActions.enumerated() {
                try pendingActionsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if publiclyAccessible != false {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let reservedNodeExchangeStatus = reservedNodeExchangeStatus {
            try container.encode(reservedNodeExchangeStatus, forKey: ClientRuntime.Key("ReservedNodeExchangeStatus"))
        }
        if let resizeInfo = resizeInfo {
            try container.encode(resizeInfo, forKey: ClientRuntime.Key("ResizeInfo"))
        }
        if let restoreStatus = restoreStatus {
            try container.encode(restoreStatus, forKey: ClientRuntime.Key("RestoreStatus"))
        }
        if let snapshotScheduleIdentifier = snapshotScheduleIdentifier {
            try container.encode(snapshotScheduleIdentifier, forKey: ClientRuntime.Key("SnapshotScheduleIdentifier"))
        }
        if let snapshotScheduleState = snapshotScheduleState {
            try container.encode(snapshotScheduleState, forKey: ClientRuntime.Key("SnapshotScheduleState"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytes {
            try container.encode(totalStorageCapacityInMegaBytes, forKey: ClientRuntime.Key("TotalStorageCapacityInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroup.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let clusterStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterStatus)
        clusterStatus = clusterStatusDecoded
        let clusterAvailabilityStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterAvailabilityStatus)
        clusterAvailabilityStatus = clusterAvailabilityStatusDecoded
        let modifyStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifyStatus)
        modifyStatus = modifyStatusDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let automatedSnapshotRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .automatedSnapshotRetentionPeriod)
        automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriodDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decode(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        if containerValues.contains(.clusterSecurityGroups) {
            struct KeyVal0{struct ClusterSecurityGroup{}}
            let clusterSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterSecurityGroup>.CodingKeys.self, forKey: .clusterSecurityGroups)
            if let clusterSecurityGroupsWrappedContainer = clusterSecurityGroupsWrappedContainer {
                let clusterSecurityGroupsContainer = try clusterSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterSecurityGroupMembership].self, forKey: .member)
                var clusterSecurityGroupsBuffer:[RedshiftClientTypes.ClusterSecurityGroupMembership]? = nil
                if let clusterSecurityGroupsContainer = clusterSecurityGroupsContainer {
                    clusterSecurityGroupsBuffer = [RedshiftClientTypes.ClusterSecurityGroupMembership]()
                    for structureContainer0 in clusterSecurityGroupsContainer {
                        clusterSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterSecurityGroups = clusterSecurityGroupsBuffer
            } else {
                clusterSecurityGroups = []
            }
        } else {
            clusterSecurityGroups = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroup{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroup>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RedshiftClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RedshiftClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        if containerValues.contains(.clusterParameterGroups) {
            struct KeyVal0{struct ClusterParameterGroup{}}
            let clusterParameterGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterParameterGroup>.CodingKeys.self, forKey: .clusterParameterGroups)
            if let clusterParameterGroupsWrappedContainer = clusterParameterGroupsWrappedContainer {
                let clusterParameterGroupsContainer = try clusterParameterGroupsWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterParameterGroupStatus].self, forKey: .member)
                var clusterParameterGroupsBuffer:[RedshiftClientTypes.ClusterParameterGroupStatus]? = nil
                if let clusterParameterGroupsContainer = clusterParameterGroupsContainer {
                    clusterParameterGroupsBuffer = [RedshiftClientTypes.ClusterParameterGroupStatus]()
                    for structureContainer0 in clusterParameterGroupsContainer {
                        clusterParameterGroupsBuffer?.append(structureContainer0)
                    }
                }
                clusterParameterGroups = clusterParameterGroupsBuffer
            } else {
                clusterParameterGroups = []
            }
        } else {
            clusterParameterGroups = nil
        }
        let clusterSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterSubnetGroupName)
        clusterSubnetGroupName = clusterSubnetGroupNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.PendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let allowVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .allowVersionUpgrade)
        allowVersionUpgrade = allowVersionUpgradeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let restoreStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.RestoreStatus.self, forKey: .restoreStatus)
        restoreStatus = restoreStatusDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.DataTransferProgress.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let hsmStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.HsmStatus.self, forKey: .hsmStatus)
        hsmStatus = hsmStatusDecoded
        let clusterSnapshotCopyStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ClusterSnapshotCopyStatus.self, forKey: .clusterSnapshotCopyStatus)
        clusterSnapshotCopyStatus = clusterSnapshotCopyStatusDecoded
        let clusterPublicKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterPublicKey)
        clusterPublicKey = clusterPublicKeyDecoded
        if containerValues.contains(.clusterNodes) {
            struct KeyVal0{struct member{}}
            let clusterNodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .clusterNodes)
            if let clusterNodesWrappedContainer = clusterNodesWrappedContainer {
                let clusterNodesContainer = try clusterNodesWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterNode].self, forKey: .member)
                var clusterNodesBuffer:[RedshiftClientTypes.ClusterNode]? = nil
                if let clusterNodesContainer = clusterNodesContainer {
                    clusterNodesBuffer = [RedshiftClientTypes.ClusterNode]()
                    for structureContainer0 in clusterNodesContainer {
                        clusterNodesBuffer?.append(structureContainer0)
                    }
                }
                clusterNodes = clusterNodesBuffer
            } else {
                clusterNodes = []
            }
        } else {
            clusterNodes = nil
        }
        let elasticIpStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ElasticIpStatus.self, forKey: .elasticIpStatus)
        elasticIpStatus = elasticIpStatusDecoded
        let clusterRevisionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterRevisionNumber)
        clusterRevisionNumber = clusterRevisionNumberDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enhancedVpcRoutingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        if containerValues.contains(.iamRoles) {
            struct KeyVal0{struct ClusterIamRole{}}
            let iamRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ClusterIamRole>.CodingKeys.self, forKey: .iamRoles)
            if let iamRolesWrappedContainer = iamRolesWrappedContainer {
                let iamRolesContainer = try iamRolesWrappedContainer.decodeIfPresent([RedshiftClientTypes.ClusterIamRole].self, forKey: .member)
                var iamRolesBuffer:[RedshiftClientTypes.ClusterIamRole]? = nil
                if let iamRolesContainer = iamRolesContainer {
                    iamRolesBuffer = [RedshiftClientTypes.ClusterIamRole]()
                    for structureContainer0 in iamRolesContainer {
                        iamRolesBuffer?.append(structureContainer0)
                    }
                }
                iamRoles = iamRolesBuffer
            } else {
                iamRoles = []
            }
        } else {
            iamRoles = nil
        }
        if containerValues.contains(.pendingActions) {
            struct KeyVal0{struct member{}}
            let pendingActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .pendingActions)
            if let pendingActionsWrappedContainer = pendingActionsWrappedContainer {
                let pendingActionsContainer = try pendingActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var pendingActionsBuffer:[Swift.String]? = nil
                if let pendingActionsContainer = pendingActionsContainer {
                    pendingActionsBuffer = [Swift.String]()
                    for stringContainer0 in pendingActionsContainer {
                        pendingActionsBuffer?.append(stringContainer0)
                    }
                }
                pendingActions = pendingActionsBuffer
            } else {
                pendingActions = []
            }
        } else {
            pendingActions = nil
        }
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let elasticResizeNumberOfNodeOptionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elasticResizeNumberOfNodeOptions)
        elasticResizeNumberOfNodeOptions = elasticResizeNumberOfNodeOptionsDecoded
        if containerValues.contains(.deferredMaintenanceWindows) {
            struct KeyVal0{struct DeferredMaintenanceWindow{}}
            let deferredMaintenanceWindowsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DeferredMaintenanceWindow>.CodingKeys.self, forKey: .deferredMaintenanceWindows)
            if let deferredMaintenanceWindowsWrappedContainer = deferredMaintenanceWindowsWrappedContainer {
                let deferredMaintenanceWindowsContainer = try deferredMaintenanceWindowsWrappedContainer.decodeIfPresent([RedshiftClientTypes.DeferredMaintenanceWindow].self, forKey: .member)
                var deferredMaintenanceWindowsBuffer:[RedshiftClientTypes.DeferredMaintenanceWindow]? = nil
                if let deferredMaintenanceWindowsContainer = deferredMaintenanceWindowsContainer {
                    deferredMaintenanceWindowsBuffer = [RedshiftClientTypes.DeferredMaintenanceWindow]()
                    for structureContainer0 in deferredMaintenanceWindowsContainer {
                        deferredMaintenanceWindowsBuffer?.append(structureContainer0)
                    }
                }
                deferredMaintenanceWindows = deferredMaintenanceWindowsBuffer
            } else {
                deferredMaintenanceWindows = []
            }
        } else {
            deferredMaintenanceWindows = nil
        }
        let snapshotScheduleIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotScheduleIdentifier)
        snapshotScheduleIdentifier = snapshotScheduleIdentifierDecoded
        let snapshotScheduleStateDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ScheduleState.self, forKey: .snapshotScheduleState)
        snapshotScheduleState = snapshotScheduleStateDecoded
        let expectedNextSnapshotScheduleTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTime)
        var expectedNextSnapshotScheduleTimeBuffer:ClientRuntime.Date? = nil
        if let expectedNextSnapshotScheduleTimeDecoded = expectedNextSnapshotScheduleTimeDecoded {
            expectedNextSnapshotScheduleTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(expectedNextSnapshotScheduleTimeDecoded, format: .dateTime)
        }
        expectedNextSnapshotScheduleTime = expectedNextSnapshotScheduleTimeBuffer
        let expectedNextSnapshotScheduleTimeStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedNextSnapshotScheduleTimeStatus)
        expectedNextSnapshotScheduleTimeStatus = expectedNextSnapshotScheduleTimeStatusDecoded
        let nextMaintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMaintenanceWindowStartTime)
        var nextMaintenanceWindowStartTimeBuffer:ClientRuntime.Date? = nil
        if let nextMaintenanceWindowStartTimeDecoded = nextMaintenanceWindowStartTimeDecoded {
            nextMaintenanceWindowStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(nextMaintenanceWindowStartTimeDecoded, format: .dateTime)
        }
        nextMaintenanceWindowStartTime = nextMaintenanceWindowStartTimeBuffer
        let resizeInfoDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ResizeInfo.self, forKey: .resizeInfo)
        resizeInfo = resizeInfoDecoded
        let availabilityZoneRelocationStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneRelocationStatus)
        availabilityZoneRelocationStatus = availabilityZoneRelocationStatusDecoded
        let clusterNamespaceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterNamespaceArn)
        clusterNamespaceArn = clusterNamespaceArnDecoded
        let totalStorageCapacityInMegaBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageCapacityInMegaBytes)
        totalStorageCapacityInMegaBytes = totalStorageCapacityInMegaBytesDecoded
        let aquaConfigurationDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.AquaConfiguration.self, forKey: .aquaConfiguration)
        aquaConfiguration = aquaConfigurationDecoded
        let defaultIamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultIamRoleArn)
        defaultIamRoleArn = defaultIamRoleArnDecoded
        let reservedNodeExchangeStatusDecoded = try containerValues.decodeIfPresent(RedshiftClientTypes.ReservedNodeExchangeStatus.self, forKey: .reservedNodeExchangeStatus)
        reservedNodeExchangeStatus = reservedNodeExchangeStatusDecoded
    }
}
