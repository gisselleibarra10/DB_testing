// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RedshiftClientTypes.Snapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountsWithRestoreAccess = "AccountsWithRestoreAccess"
        case actualIncrementalBackupSizeInMegaBytes = "ActualIncrementalBackupSizeInMegaBytes"
        case availabilityZone = "AvailabilityZone"
        case backupProgressInMegaBytes = "BackupProgressInMegaBytes"
        case clusterCreateTime = "ClusterCreateTime"
        case clusterIdentifier = "ClusterIdentifier"
        case clusterVersion = "ClusterVersion"
        case currentBackupRateInMegaBytesPerSecond = "CurrentBackupRateInMegaBytesPerSecond"
        case dBName = "DBName"
        case elapsedTimeInSeconds = "ElapsedTimeInSeconds"
        case encrypted = "Encrypted"
        case encryptedWithHSM = "EncryptedWithHSM"
        case engineFullVersion = "EngineFullVersion"
        case enhancedVpcRouting = "EnhancedVpcRouting"
        case estimatedSecondsToCompletion = "EstimatedSecondsToCompletion"
        case kmsKeyId = "KmsKeyId"
        case maintenanceTrackName = "MaintenanceTrackName"
        case manualSnapshotRemainingDays = "ManualSnapshotRemainingDays"
        case manualSnapshotRetentionPeriod = "ManualSnapshotRetentionPeriod"
        case masterUsername = "MasterUsername"
        case nodeType = "NodeType"
        case numberOfNodes = "NumberOfNodes"
        case ownerAccount = "OwnerAccount"
        case port = "Port"
        case restorableNodeTypes = "RestorableNodeTypes"
        case snapshotCreateTime = "SnapshotCreateTime"
        case snapshotIdentifier = "SnapshotIdentifier"
        case snapshotRetentionStartTime = "SnapshotRetentionStartTime"
        case snapshotType = "SnapshotType"
        case sourceRegion = "SourceRegion"
        case status = "Status"
        case tags = "Tags"
        case totalBackupSizeInMegaBytes = "TotalBackupSizeInMegaBytes"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let accountsWithRestoreAccess = accountsWithRestoreAccess {
            var accountsWithRestoreAccessContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccountsWithRestoreAccess"))
            for (index0, accountwithrestoreaccess0) in accountsWithRestoreAccess.enumerated() {
                try accountsWithRestoreAccessContainer.encode(accountwithrestoreaccess0, forKey: ClientRuntime.Key("AccountWithRestoreAccess.\(index0.advanced(by: 1))"))
            }
        }
        if actualIncrementalBackupSizeInMegaBytes != 0.0 {
            try container.encode(Swift.String(actualIncrementalBackupSizeInMegaBytes), forKey: ClientRuntime.Key("ActualIncrementalBackupSizeInMegaBytes"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if backupProgressInMegaBytes != 0.0 {
            try container.encode(Swift.String(backupProgressInMegaBytes), forKey: ClientRuntime.Key("BackupProgressInMegaBytes"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let clusterIdentifier = clusterIdentifier {
            try container.encode(clusterIdentifier, forKey: ClientRuntime.Key("ClusterIdentifier"))
        }
        if let clusterVersion = clusterVersion {
            try container.encode(clusterVersion, forKey: ClientRuntime.Key("ClusterVersion"))
        }
        if currentBackupRateInMegaBytesPerSecond != 0.0 {
            try container.encode(Swift.String(currentBackupRateInMegaBytesPerSecond), forKey: ClientRuntime.Key("CurrentBackupRateInMegaBytesPerSecond"))
        }
        if let dBName = dBName {
            try container.encode(dBName, forKey: ClientRuntime.Key("DBName"))
        }
        if elapsedTimeInSeconds != 0 {
            try container.encode(elapsedTimeInSeconds, forKey: ClientRuntime.Key("ElapsedTimeInSeconds"))
        }
        if encrypted != false {
            try container.encode(encrypted, forKey: ClientRuntime.Key("Encrypted"))
        }
        if encryptedWithHSM != false {
            try container.encode(encryptedWithHSM, forKey: ClientRuntime.Key("EncryptedWithHSM"))
        }
        if let engineFullVersion = engineFullVersion {
            try container.encode(engineFullVersion, forKey: ClientRuntime.Key("EngineFullVersion"))
        }
        if enhancedVpcRouting != false {
            try container.encode(enhancedVpcRouting, forKey: ClientRuntime.Key("EnhancedVpcRouting"))
        }
        if estimatedSecondsToCompletion != 0 {
            try container.encode(estimatedSecondsToCompletion, forKey: ClientRuntime.Key("EstimatedSecondsToCompletion"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let maintenanceTrackName = maintenanceTrackName {
            try container.encode(maintenanceTrackName, forKey: ClientRuntime.Key("MaintenanceTrackName"))
        }
        if let manualSnapshotRemainingDays = manualSnapshotRemainingDays {
            try container.encode(manualSnapshotRemainingDays, forKey: ClientRuntime.Key("ManualSnapshotRemainingDays"))
        }
        if let manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod {
            try container.encode(manualSnapshotRetentionPeriod, forKey: ClientRuntime.Key("ManualSnapshotRetentionPeriod"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let nodeType = nodeType {
            try container.encode(nodeType, forKey: ClientRuntime.Key("NodeType"))
        }
        if numberOfNodes != 0 {
            try container.encode(numberOfNodes, forKey: ClientRuntime.Key("NumberOfNodes"))
        }
        if let ownerAccount = ownerAccount {
            try container.encode(ownerAccount, forKey: ClientRuntime.Key("OwnerAccount"))
        }
        if port != 0 {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let restorableNodeTypes = restorableNodeTypes {
            var restorableNodeTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("RestorableNodeTypes"))
            for (index0, string0) in restorableNodeTypes.enumerated() {
                try restorableNodeTypesContainer.encode(string0, forKey: ClientRuntime.Key("NodeType.\(index0.advanced(by: 1))"))
            }
        }
        if let snapshotCreateTime = snapshotCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotCreateTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotCreateTime"))
        }
        if let snapshotIdentifier = snapshotIdentifier {
            try container.encode(snapshotIdentifier, forKey: ClientRuntime.Key("SnapshotIdentifier"))
        }
        if let snapshotRetentionStartTime = snapshotRetentionStartTime {
            try container.encode(ClientRuntime.TimestampWrapper(snapshotRetentionStartTime, format: .dateTime), forKey: ClientRuntime.Key("snapshotRetentionStartTime"))
        }
        if let snapshotType = snapshotType {
            try container.encode(snapshotType, forKey: ClientRuntime.Key("SnapshotType"))
        }
        if let sourceRegion = sourceRegion {
            try container.encode(sourceRegion, forKey: ClientRuntime.Key("SourceRegion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if totalBackupSizeInMegaBytes != 0.0 {
            try container.encode(Swift.String(totalBackupSizeInMegaBytes), forKey: ClientRuntime.Key("TotalBackupSizeInMegaBytes"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotIdentifier)
        snapshotIdentifier = snapshotIdentifierDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let snapshotCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotCreateTime)
        var snapshotCreateTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotCreateTimeDecoded = snapshotCreateTimeDecoded {
            snapshotCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotCreateTimeDecoded, format: .dateTime)
        }
        snapshotCreateTime = snapshotCreateTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let portDecoded = try containerValues.decode(Swift.Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let clusterVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterVersion)
        clusterVersion = clusterVersionDecoded
        let engineFullVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineFullVersion)
        engineFullVersion = engineFullVersionDecoded
        let snapshotTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotType)
        snapshotType = snapshotTypeDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let numberOfNodesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfNodes)
        numberOfNodes = numberOfNodesDecoded
        let dBNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBName)
        dBName = dBNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let encryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedWithHSMDecoded = try containerValues.decode(Swift.Bool.self, forKey: .encryptedWithHSM)
        encryptedWithHSM = encryptedWithHSMDecoded
        if containerValues.contains(.accountsWithRestoreAccess) {
            struct KeyVal0{struct AccountWithRestoreAccess{}}
            let accountsWithRestoreAccessWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AccountWithRestoreAccess>.CodingKeys.self, forKey: .accountsWithRestoreAccess)
            if let accountsWithRestoreAccessWrappedContainer = accountsWithRestoreAccessWrappedContainer {
                let accountsWithRestoreAccessContainer = try accountsWithRestoreAccessWrappedContainer.decodeIfPresent([RedshiftClientTypes.AccountWithRestoreAccess].self, forKey: .member)
                var accountsWithRestoreAccessBuffer:[RedshiftClientTypes.AccountWithRestoreAccess]? = nil
                if let accountsWithRestoreAccessContainer = accountsWithRestoreAccessContainer {
                    accountsWithRestoreAccessBuffer = [RedshiftClientTypes.AccountWithRestoreAccess]()
                    for structureContainer0 in accountsWithRestoreAccessContainer {
                        accountsWithRestoreAccessBuffer?.append(structureContainer0)
                    }
                }
                accountsWithRestoreAccess = accountsWithRestoreAccessBuffer
            } else {
                accountsWithRestoreAccess = []
            }
        } else {
            accountsWithRestoreAccess = nil
        }
        let ownerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccount)
        ownerAccount = ownerAccountDecoded
        let totalBackupSizeInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalBackupSizeInMegaBytes)
        totalBackupSizeInMegaBytes = totalBackupSizeInMegaBytesDecoded
        let actualIncrementalBackupSizeInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .actualIncrementalBackupSizeInMegaBytes)
        actualIncrementalBackupSizeInMegaBytes = actualIncrementalBackupSizeInMegaBytesDecoded
        let backupProgressInMegaBytesDecoded = try containerValues.decode(Swift.Double.self, forKey: .backupProgressInMegaBytes)
        backupProgressInMegaBytes = backupProgressInMegaBytesDecoded
        let currentBackupRateInMegaBytesPerSecondDecoded = try containerValues.decode(Swift.Double.self, forKey: .currentBackupRateInMegaBytesPerSecond)
        currentBackupRateInMegaBytesPerSecond = currentBackupRateInMegaBytesPerSecondDecoded
        let estimatedSecondsToCompletionDecoded = try containerValues.decode(Swift.Int.self, forKey: .estimatedSecondsToCompletion)
        estimatedSecondsToCompletion = estimatedSecondsToCompletionDecoded
        let elapsedTimeInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .elapsedTimeInSeconds)
        elapsedTimeInSeconds = elapsedTimeInSecondsDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RedshiftClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RedshiftClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RedshiftClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        if containerValues.contains(.restorableNodeTypes) {
            struct KeyVal0{struct NodeType{}}
            let restorableNodeTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.NodeType>.CodingKeys.self, forKey: .restorableNodeTypes)
            if let restorableNodeTypesWrappedContainer = restorableNodeTypesWrappedContainer {
                let restorableNodeTypesContainer = try restorableNodeTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var restorableNodeTypesBuffer:[Swift.String]? = nil
                if let restorableNodeTypesContainer = restorableNodeTypesContainer {
                    restorableNodeTypesBuffer = [Swift.String]()
                    for stringContainer0 in restorableNodeTypesContainer {
                        restorableNodeTypesBuffer?.append(stringContainer0)
                    }
                }
                restorableNodeTypes = restorableNodeTypesBuffer
            } else {
                restorableNodeTypes = []
            }
        } else {
            restorableNodeTypes = nil
        }
        let enhancedVpcRoutingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enhancedVpcRouting)
        enhancedVpcRouting = enhancedVpcRoutingDecoded
        let maintenanceTrackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maintenanceTrackName)
        maintenanceTrackName = maintenanceTrackNameDecoded
        let manualSnapshotRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRetentionPeriod)
        manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriodDecoded
        let manualSnapshotRemainingDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .manualSnapshotRemainingDays)
        manualSnapshotRemainingDays = manualSnapshotRemainingDaysDecoded
        let snapshotRetentionStartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotRetentionStartTime)
        var snapshotRetentionStartTimeBuffer:ClientRuntime.Date? = nil
        if let snapshotRetentionStartTimeDecoded = snapshotRetentionStartTimeDecoded {
            snapshotRetentionStartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(snapshotRetentionStartTimeDecoded, format: .dateTime)
        }
        snapshotRetentionStartTime = snapshotRetentionStartTimeBuffer
    }
}
