// Code generated by smithy-swift-codegen. DO NOT EDIT!



extension GlueClientTypes {
    /// Additional connection options for the connector.
    public struct JDBCConnectorOptions: Swift.Equatable {
        /// Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For example, the option "dataTypeMapping":{"FLOAT":"STRING"} maps data fields of JDBC type FLOAT into the Java String type by calling the ResultSet.getString() method of the driver, and uses it to build the Glue record. The ResultSet object is implemented by each driver, so the behavior is specific to the driver you use. Refer to the documentation for your JDBC driver to understand how the driver performs the conversions.
        public var dataTypeMapping: [Swift.String:GlueClientTypes.GlueRecordType]?
        /// Extra condition clause to filter data from source. For example: BillingCity='Mountain View' When using a query instead of a table name, you should validate that the query works with the specified filterPredicate.
        public var filterPredicate: Swift.String?
        /// The name of the job bookmark keys on which to sort.
        public var jobBookmarkKeys: [Swift.String]?
        /// Specifies an ascending or descending sort order.
        public var jobBookmarkKeysSortOrder: Swift.String?
        /// The minimum value of partitionColumn that is used to decide partition stride.
        public var lowerBound: Swift.Int?
        /// The number of partitions. This value, along with lowerBound (inclusive) and upperBound (exclusive), form partition strides for generated WHERE clause expressions that are used to split the partitionColumn.
        public var numPartitions: Swift.Int?
        /// The name of an integer column that is used for partitioning. This option works only when it's included with lowerBound, upperBound, and numPartitions. This option works the same way as in the Spark SQL JDBC reader.
        public var partitionColumn: Swift.String?
        /// The maximum value of partitionColumn that is used to decide partition stride.
        public var upperBound: Swift.Int?

        public init (
            dataTypeMapping: [Swift.String:GlueClientTypes.GlueRecordType]? = nil,
            filterPredicate: Swift.String? = nil,
            jobBookmarkKeys: [Swift.String]? = nil,
            jobBookmarkKeysSortOrder: Swift.String? = nil,
            lowerBound: Swift.Int? = nil,
            numPartitions: Swift.Int? = nil,
            partitionColumn: Swift.String? = nil,
            upperBound: Swift.Int? = nil
        )
        {
            self.dataTypeMapping = dataTypeMapping
            self.filterPredicate = filterPredicate
            self.jobBookmarkKeys = jobBookmarkKeys
            self.jobBookmarkKeysSortOrder = jobBookmarkKeysSortOrder
            self.lowerBound = lowerBound
            self.numPartitions = numPartitions
            self.partitionColumn = partitionColumn
            self.upperBound = upperBound
        }
    }

}
