// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension GlueClientTypes.KafkaStreamingSourceOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assign = "Assign"
        case bootstrapServers = "BootstrapServers"
        case classification = "Classification"
        case connectionName = "ConnectionName"
        case delimiter = "Delimiter"
        case endingOffsets = "EndingOffsets"
        case maxOffsetsPerTrigger = "MaxOffsetsPerTrigger"
        case minPartitions = "MinPartitions"
        case numRetries = "NumRetries"
        case pollTimeoutMs = "PollTimeoutMs"
        case retryIntervalMs = "RetryIntervalMs"
        case securityProtocol = "SecurityProtocol"
        case startingOffsets = "StartingOffsets"
        case subscribePattern = "SubscribePattern"
        case topicName = "TopicName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assign = self.assign {
            try encodeContainer.encode(assign, forKey: .assign)
        }
        if let bootstrapServers = self.bootstrapServers {
            try encodeContainer.encode(bootstrapServers, forKey: .bootstrapServers)
        }
        if let classification = self.classification {
            try encodeContainer.encode(classification, forKey: .classification)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if let endingOffsets = self.endingOffsets {
            try encodeContainer.encode(endingOffsets, forKey: .endingOffsets)
        }
        if let maxOffsetsPerTrigger = self.maxOffsetsPerTrigger {
            try encodeContainer.encode(maxOffsetsPerTrigger, forKey: .maxOffsetsPerTrigger)
        }
        if let minPartitions = self.minPartitions {
            try encodeContainer.encode(minPartitions, forKey: .minPartitions)
        }
        if let numRetries = self.numRetries {
            try encodeContainer.encode(numRetries, forKey: .numRetries)
        }
        if let pollTimeoutMs = self.pollTimeoutMs {
            try encodeContainer.encode(pollTimeoutMs, forKey: .pollTimeoutMs)
        }
        if let retryIntervalMs = self.retryIntervalMs {
            try encodeContainer.encode(retryIntervalMs, forKey: .retryIntervalMs)
        }
        if let securityProtocol = self.securityProtocol {
            try encodeContainer.encode(securityProtocol, forKey: .securityProtocol)
        }
        if let startingOffsets = self.startingOffsets {
            try encodeContainer.encode(startingOffsets, forKey: .startingOffsets)
        }
        if let subscribePattern = self.subscribePattern {
            try encodeContainer.encode(subscribePattern, forKey: .subscribePattern)
        }
        if let topicName = self.topicName {
            try encodeContainer.encode(topicName, forKey: .topicName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bootstrapServersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bootstrapServers)
        bootstrapServers = bootstrapServersDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let topicNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicName)
        topicName = topicNameDecoded
        let assignDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assign)
        assign = assignDecoded
        let subscribePatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscribePattern)
        subscribePattern = subscribePatternDecoded
        let classificationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .classification)
        classification = classificationDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let startingOffsetsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startingOffsets)
        startingOffsets = startingOffsetsDecoded
        let endingOffsetsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endingOffsets)
        endingOffsets = endingOffsetsDecoded
        let pollTimeoutMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pollTimeoutMs)
        pollTimeoutMs = pollTimeoutMsDecoded
        let numRetriesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numRetries)
        numRetries = numRetriesDecoded
        let retryIntervalMsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryIntervalMs)
        retryIntervalMs = retryIntervalMsDecoded
        let maxOffsetsPerTriggerDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxOffsetsPerTrigger)
        maxOffsetsPerTrigger = maxOffsetsPerTriggerDecoded
        let minPartitionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minPartitions)
        minPartitions = minPartitionsDecoded
    }
}
