// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension GlueClientTypes.CodeGenConfigurationNode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregate = "Aggregate"
        case applyMapping = "ApplyMapping"
        case athenaConnectorSource = "AthenaConnectorSource"
        case catalogKafkaSource = "CatalogKafkaSource"
        case catalogKinesisSource = "CatalogKinesisSource"
        case catalogSource = "CatalogSource"
        case catalogTarget = "CatalogTarget"
        case customCode = "CustomCode"
        case directKafkaSource = "DirectKafkaSource"
        case directKinesisSource = "DirectKinesisSource"
        case dropDuplicates = "DropDuplicates"
        case dropFields = "DropFields"
        case dropNullFields = "DropNullFields"
        case dynamoDBCatalogSource = "DynamoDBCatalogSource"
        case fillMissingValues = "FillMissingValues"
        case filter = "Filter"
        case governedCatalogSource = "GovernedCatalogSource"
        case governedCatalogTarget = "GovernedCatalogTarget"
        case jDBCConnectorSource = "JDBCConnectorSource"
        case jDBCConnectorTarget = "JDBCConnectorTarget"
        case join = "Join"
        case merge = "Merge"
        case microsoftSQLServerCatalogSource = "MicrosoftSQLServerCatalogSource"
        case microsoftSQLServerCatalogTarget = "MicrosoftSQLServerCatalogTarget"
        case mySQLCatalogSource = "MySQLCatalogSource"
        case mySQLCatalogTarget = "MySQLCatalogTarget"
        case oracleSQLCatalogSource = "OracleSQLCatalogSource"
        case oracleSQLCatalogTarget = "OracleSQLCatalogTarget"
        case pIIDetection = "PIIDetection"
        case postgreSQLCatalogSource = "PostgreSQLCatalogSource"
        case postgreSQLCatalogTarget = "PostgreSQLCatalogTarget"
        case redshiftSource = "RedshiftSource"
        case redshiftTarget = "RedshiftTarget"
        case relationalCatalogSource = "RelationalCatalogSource"
        case renameField = "RenameField"
        case s3CatalogSource = "S3CatalogSource"
        case s3CatalogTarget = "S3CatalogTarget"
        case s3CsvSource = "S3CsvSource"
        case s3DirectTarget = "S3DirectTarget"
        case s3GlueParquetTarget = "S3GlueParquetTarget"
        case s3JsonSource = "S3JsonSource"
        case s3ParquetSource = "S3ParquetSource"
        case selectFields = "SelectFields"
        case selectFromCollection = "SelectFromCollection"
        case sparkConnectorSource = "SparkConnectorSource"
        case sparkConnectorTarget = "SparkConnectorTarget"
        case sparkSQL = "SparkSQL"
        case spigot = "Spigot"
        case splitFields = "SplitFields"
        case union = "Union"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregate = self.aggregate {
            try encodeContainer.encode(aggregate, forKey: .aggregate)
        }
        if let applyMapping = self.applyMapping {
            try encodeContainer.encode(applyMapping, forKey: .applyMapping)
        }
        if let athenaConnectorSource = self.athenaConnectorSource {
            try encodeContainer.encode(athenaConnectorSource, forKey: .athenaConnectorSource)
        }
        if let catalogKafkaSource = self.catalogKafkaSource {
            try encodeContainer.encode(catalogKafkaSource, forKey: .catalogKafkaSource)
        }
        if let catalogKinesisSource = self.catalogKinesisSource {
            try encodeContainer.encode(catalogKinesisSource, forKey: .catalogKinesisSource)
        }
        if let catalogSource = self.catalogSource {
            try encodeContainer.encode(catalogSource, forKey: .catalogSource)
        }
        if let catalogTarget = self.catalogTarget {
            try encodeContainer.encode(catalogTarget, forKey: .catalogTarget)
        }
        if let customCode = self.customCode {
            try encodeContainer.encode(customCode, forKey: .customCode)
        }
        if let directKafkaSource = self.directKafkaSource {
            try encodeContainer.encode(directKafkaSource, forKey: .directKafkaSource)
        }
        if let directKinesisSource = self.directKinesisSource {
            try encodeContainer.encode(directKinesisSource, forKey: .directKinesisSource)
        }
        if let dropDuplicates = self.dropDuplicates {
            try encodeContainer.encode(dropDuplicates, forKey: .dropDuplicates)
        }
        if let dropFields = self.dropFields {
            try encodeContainer.encode(dropFields, forKey: .dropFields)
        }
        if let dropNullFields = self.dropNullFields {
            try encodeContainer.encode(dropNullFields, forKey: .dropNullFields)
        }
        if let dynamoDBCatalogSource = self.dynamoDBCatalogSource {
            try encodeContainer.encode(dynamoDBCatalogSource, forKey: .dynamoDBCatalogSource)
        }
        if let fillMissingValues = self.fillMissingValues {
            try encodeContainer.encode(fillMissingValues, forKey: .fillMissingValues)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let governedCatalogSource = self.governedCatalogSource {
            try encodeContainer.encode(governedCatalogSource, forKey: .governedCatalogSource)
        }
        if let governedCatalogTarget = self.governedCatalogTarget {
            try encodeContainer.encode(governedCatalogTarget, forKey: .governedCatalogTarget)
        }
        if let jDBCConnectorSource = self.jDBCConnectorSource {
            try encodeContainer.encode(jDBCConnectorSource, forKey: .jDBCConnectorSource)
        }
        if let jDBCConnectorTarget = self.jDBCConnectorTarget {
            try encodeContainer.encode(jDBCConnectorTarget, forKey: .jDBCConnectorTarget)
        }
        if let join = self.join {
            try encodeContainer.encode(join, forKey: .join)
        }
        if let merge = self.merge {
            try encodeContainer.encode(merge, forKey: .merge)
        }
        if let microsoftSQLServerCatalogSource = self.microsoftSQLServerCatalogSource {
            try encodeContainer.encode(microsoftSQLServerCatalogSource, forKey: .microsoftSQLServerCatalogSource)
        }
        if let microsoftSQLServerCatalogTarget = self.microsoftSQLServerCatalogTarget {
            try encodeContainer.encode(microsoftSQLServerCatalogTarget, forKey: .microsoftSQLServerCatalogTarget)
        }
        if let mySQLCatalogSource = self.mySQLCatalogSource {
            try encodeContainer.encode(mySQLCatalogSource, forKey: .mySQLCatalogSource)
        }
        if let mySQLCatalogTarget = self.mySQLCatalogTarget {
            try encodeContainer.encode(mySQLCatalogTarget, forKey: .mySQLCatalogTarget)
        }
        if let oracleSQLCatalogSource = self.oracleSQLCatalogSource {
            try encodeContainer.encode(oracleSQLCatalogSource, forKey: .oracleSQLCatalogSource)
        }
        if let oracleSQLCatalogTarget = self.oracleSQLCatalogTarget {
            try encodeContainer.encode(oracleSQLCatalogTarget, forKey: .oracleSQLCatalogTarget)
        }
        if let pIIDetection = self.pIIDetection {
            try encodeContainer.encode(pIIDetection, forKey: .pIIDetection)
        }
        if let postgreSQLCatalogSource = self.postgreSQLCatalogSource {
            try encodeContainer.encode(postgreSQLCatalogSource, forKey: .postgreSQLCatalogSource)
        }
        if let postgreSQLCatalogTarget = self.postgreSQLCatalogTarget {
            try encodeContainer.encode(postgreSQLCatalogTarget, forKey: .postgreSQLCatalogTarget)
        }
        if let redshiftSource = self.redshiftSource {
            try encodeContainer.encode(redshiftSource, forKey: .redshiftSource)
        }
        if let redshiftTarget = self.redshiftTarget {
            try encodeContainer.encode(redshiftTarget, forKey: .redshiftTarget)
        }
        if let relationalCatalogSource = self.relationalCatalogSource {
            try encodeContainer.encode(relationalCatalogSource, forKey: .relationalCatalogSource)
        }
        if let renameField = self.renameField {
            try encodeContainer.encode(renameField, forKey: .renameField)
        }
        if let s3CatalogSource = self.s3CatalogSource {
            try encodeContainer.encode(s3CatalogSource, forKey: .s3CatalogSource)
        }
        if let s3CatalogTarget = self.s3CatalogTarget {
            try encodeContainer.encode(s3CatalogTarget, forKey: .s3CatalogTarget)
        }
        if let s3CsvSource = self.s3CsvSource {
            try encodeContainer.encode(s3CsvSource, forKey: .s3CsvSource)
        }
        if let s3DirectTarget = self.s3DirectTarget {
            try encodeContainer.encode(s3DirectTarget, forKey: .s3DirectTarget)
        }
        if let s3GlueParquetTarget = self.s3GlueParquetTarget {
            try encodeContainer.encode(s3GlueParquetTarget, forKey: .s3GlueParquetTarget)
        }
        if let s3JsonSource = self.s3JsonSource {
            try encodeContainer.encode(s3JsonSource, forKey: .s3JsonSource)
        }
        if let s3ParquetSource = self.s3ParquetSource {
            try encodeContainer.encode(s3ParquetSource, forKey: .s3ParquetSource)
        }
        if let selectFields = self.selectFields {
            try encodeContainer.encode(selectFields, forKey: .selectFields)
        }
        if let selectFromCollection = self.selectFromCollection {
            try encodeContainer.encode(selectFromCollection, forKey: .selectFromCollection)
        }
        if let sparkConnectorSource = self.sparkConnectorSource {
            try encodeContainer.encode(sparkConnectorSource, forKey: .sparkConnectorSource)
        }
        if let sparkConnectorTarget = self.sparkConnectorTarget {
            try encodeContainer.encode(sparkConnectorTarget, forKey: .sparkConnectorTarget)
        }
        if let sparkSQL = self.sparkSQL {
            try encodeContainer.encode(sparkSQL, forKey: .sparkSQL)
        }
        if let spigot = self.spigot {
            try encodeContainer.encode(spigot, forKey: .spigot)
        }
        if let splitFields = self.splitFields {
            try encodeContainer.encode(splitFields, forKey: .splitFields)
        }
        if let union = self.union {
            try encodeContainer.encode(union, forKey: .union)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let athenaConnectorSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.AthenaConnectorSource.self, forKey: .athenaConnectorSource)
        athenaConnectorSource = athenaConnectorSourceDecoded
        let jDBCConnectorSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.JDBCConnectorSource.self, forKey: .jDBCConnectorSource)
        jDBCConnectorSource = jDBCConnectorSourceDecoded
        let sparkConnectorSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SparkConnectorSource.self, forKey: .sparkConnectorSource)
        sparkConnectorSource = sparkConnectorSourceDecoded
        let catalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.CatalogSource.self, forKey: .catalogSource)
        catalogSource = catalogSourceDecoded
        let redshiftSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.RedshiftSource.self, forKey: .redshiftSource)
        redshiftSource = redshiftSourceDecoded
        let s3CatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3CatalogSource.self, forKey: .s3CatalogSource)
        s3CatalogSource = s3CatalogSourceDecoded
        let s3CsvSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3CsvSource.self, forKey: .s3CsvSource)
        s3CsvSource = s3CsvSourceDecoded
        let s3JsonSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3JsonSource.self, forKey: .s3JsonSource)
        s3JsonSource = s3JsonSourceDecoded
        let s3ParquetSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3ParquetSource.self, forKey: .s3ParquetSource)
        s3ParquetSource = s3ParquetSourceDecoded
        let relationalCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.RelationalCatalogSource.self, forKey: .relationalCatalogSource)
        relationalCatalogSource = relationalCatalogSourceDecoded
        let dynamoDBCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DynamoDBCatalogSource.self, forKey: .dynamoDBCatalogSource)
        dynamoDBCatalogSource = dynamoDBCatalogSourceDecoded
        let jDBCConnectorTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.JDBCConnectorTarget.self, forKey: .jDBCConnectorTarget)
        jDBCConnectorTarget = jDBCConnectorTargetDecoded
        let sparkConnectorTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SparkConnectorTarget.self, forKey: .sparkConnectorTarget)
        sparkConnectorTarget = sparkConnectorTargetDecoded
        let catalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.BasicCatalogTarget.self, forKey: .catalogTarget)
        catalogTarget = catalogTargetDecoded
        let redshiftTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.RedshiftTarget.self, forKey: .redshiftTarget)
        redshiftTarget = redshiftTargetDecoded
        let s3CatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3CatalogTarget.self, forKey: .s3CatalogTarget)
        s3CatalogTarget = s3CatalogTargetDecoded
        let s3GlueParquetTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3GlueParquetTarget.self, forKey: .s3GlueParquetTarget)
        s3GlueParquetTarget = s3GlueParquetTargetDecoded
        let s3DirectTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.S3DirectTarget.self, forKey: .s3DirectTarget)
        s3DirectTarget = s3DirectTargetDecoded
        let applyMappingDecoded = try containerValues.decodeIfPresent(GlueClientTypes.ApplyMapping.self, forKey: .applyMapping)
        applyMapping = applyMappingDecoded
        let selectFieldsDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SelectFields.self, forKey: .selectFields)
        selectFields = selectFieldsDecoded
        let dropFieldsDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DropFields.self, forKey: .dropFields)
        dropFields = dropFieldsDecoded
        let renameFieldDecoded = try containerValues.decodeIfPresent(GlueClientTypes.RenameField.self, forKey: .renameField)
        renameField = renameFieldDecoded
        let spigotDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Spigot.self, forKey: .spigot)
        spigot = spigotDecoded
        let joinDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Join.self, forKey: .join)
        join = joinDecoded
        let splitFieldsDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SplitFields.self, forKey: .splitFields)
        splitFields = splitFieldsDecoded
        let selectFromCollectionDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SelectFromCollection.self, forKey: .selectFromCollection)
        selectFromCollection = selectFromCollectionDecoded
        let fillMissingValuesDecoded = try containerValues.decodeIfPresent(GlueClientTypes.FillMissingValues.self, forKey: .fillMissingValues)
        fillMissingValues = fillMissingValuesDecoded
        let filterDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
        let customCodeDecoded = try containerValues.decodeIfPresent(GlueClientTypes.CustomCode.self, forKey: .customCode)
        customCode = customCodeDecoded
        let sparkSQLDecoded = try containerValues.decodeIfPresent(GlueClientTypes.SparkSQL.self, forKey: .sparkSQL)
        sparkSQL = sparkSQLDecoded
        let directKinesisSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DirectKinesisSource.self, forKey: .directKinesisSource)
        directKinesisSource = directKinesisSourceDecoded
        let directKafkaSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DirectKafkaSource.self, forKey: .directKafkaSource)
        directKafkaSource = directKafkaSourceDecoded
        let catalogKinesisSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.CatalogKinesisSource.self, forKey: .catalogKinesisSource)
        catalogKinesisSource = catalogKinesisSourceDecoded
        let catalogKafkaSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.CatalogKafkaSource.self, forKey: .catalogKafkaSource)
        catalogKafkaSource = catalogKafkaSourceDecoded
        let dropNullFieldsDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DropNullFields.self, forKey: .dropNullFields)
        dropNullFields = dropNullFieldsDecoded
        let mergeDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Merge.self, forKey: .merge)
        merge = mergeDecoded
        let unionDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Union.self, forKey: .union)
        union = unionDecoded
        let pIIDetectionDecoded = try containerValues.decodeIfPresent(GlueClientTypes.PIIDetection.self, forKey: .pIIDetection)
        pIIDetection = pIIDetectionDecoded
        let aggregateDecoded = try containerValues.decodeIfPresent(GlueClientTypes.Aggregate.self, forKey: .aggregate)
        aggregate = aggregateDecoded
        let dropDuplicatesDecoded = try containerValues.decodeIfPresent(GlueClientTypes.DropDuplicates.self, forKey: .dropDuplicates)
        dropDuplicates = dropDuplicatesDecoded
        let governedCatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.GovernedCatalogTarget.self, forKey: .governedCatalogTarget)
        governedCatalogTarget = governedCatalogTargetDecoded
        let governedCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.GovernedCatalogSource.self, forKey: .governedCatalogSource)
        governedCatalogSource = governedCatalogSourceDecoded
        let microsoftSQLServerCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.MicrosoftSQLServerCatalogSource.self, forKey: .microsoftSQLServerCatalogSource)
        microsoftSQLServerCatalogSource = microsoftSQLServerCatalogSourceDecoded
        let mySQLCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.MySQLCatalogSource.self, forKey: .mySQLCatalogSource)
        mySQLCatalogSource = mySQLCatalogSourceDecoded
        let oracleSQLCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.OracleSQLCatalogSource.self, forKey: .oracleSQLCatalogSource)
        oracleSQLCatalogSource = oracleSQLCatalogSourceDecoded
        let postgreSQLCatalogSourceDecoded = try containerValues.decodeIfPresent(GlueClientTypes.PostgreSQLCatalogSource.self, forKey: .postgreSQLCatalogSource)
        postgreSQLCatalogSource = postgreSQLCatalogSourceDecoded
        let microsoftSQLServerCatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.MicrosoftSQLServerCatalogTarget.self, forKey: .microsoftSQLServerCatalogTarget)
        microsoftSQLServerCatalogTarget = microsoftSQLServerCatalogTargetDecoded
        let mySQLCatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.MySQLCatalogTarget.self, forKey: .mySQLCatalogTarget)
        mySQLCatalogTarget = mySQLCatalogTargetDecoded
        let oracleSQLCatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.OracleSQLCatalogTarget.self, forKey: .oracleSQLCatalogTarget)
        oracleSQLCatalogTarget = oracleSQLCatalogTargetDecoded
        let postgreSQLCatalogTargetDecoded = try containerValues.decodeIfPresent(GlueClientTypes.PostgreSQLCatalogTarget.self, forKey: .postgreSQLCatalogTarget)
        postgreSQLCatalogTarget = postgreSQLCatalogTargetDecoded
    }
}
