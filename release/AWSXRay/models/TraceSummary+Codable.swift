// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension XRayClientTypes.TraceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotations = "Annotations"
        case availabilityZones = "AvailabilityZones"
        case duration = "Duration"
        case entryPoint = "EntryPoint"
        case errorRootCauses = "ErrorRootCauses"
        case faultRootCauses = "FaultRootCauses"
        case hasError = "HasError"
        case hasFault = "HasFault"
        case hasThrottle = "HasThrottle"
        case http = "Http"
        case id = "Id"
        case instanceIds = "InstanceIds"
        case isPartial = "IsPartial"
        case matchedEventTime = "MatchedEventTime"
        case resourceARNs = "ResourceARNs"
        case responseTime = "ResponseTime"
        case responseTimeRootCauses = "ResponseTimeRootCauses"
        case revision = "Revision"
        case serviceIds = "ServiceIds"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotations = annotations {
            var annotationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .annotations)
            for (dictKey0, annotations0) in annotations {
                try annotationsContainer.encode(annotations0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for traceavailabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(traceavailabilityzones0)
            }
        }
        if let duration = self.duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let entryPoint = self.entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let errorRootCauses = errorRootCauses {
            var errorRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorRootCauses)
            for errorrootcauses0 in errorRootCauses {
                try errorRootCausesContainer.encode(errorrootcauses0)
            }
        }
        if let faultRootCauses = faultRootCauses {
            var faultRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .faultRootCauses)
            for faultrootcauses0 in faultRootCauses {
                try faultRootCausesContainer.encode(faultrootcauses0)
            }
        }
        if let hasError = self.hasError {
            try encodeContainer.encode(hasError, forKey: .hasError)
        }
        if let hasFault = self.hasFault {
            try encodeContainer.encode(hasFault, forKey: .hasFault)
        }
        if let hasThrottle = self.hasThrottle {
            try encodeContainer.encode(hasThrottle, forKey: .hasThrottle)
        }
        if let http = self.http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for traceinstanceids0 in instanceIds {
                try instanceIdsContainer.encode(traceinstanceids0)
            }
        }
        if let isPartial = self.isPartial {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let matchedEventTime = self.matchedEventTime {
            try encodeContainer.encode(matchedEventTime.timeIntervalSince1970, forKey: .matchedEventTime)
        }
        if let resourceARNs = resourceARNs {
            var resourceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNs)
            for traceresourcearns0 in resourceARNs {
                try resourceARNsContainer.encode(traceresourcearns0)
            }
        }
        if let responseTime = self.responseTime {
            try encodeContainer.encode(responseTime, forKey: .responseTime)
        }
        if let responseTimeRootCauses = responseTimeRootCauses {
            var responseTimeRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeRootCauses)
            for responsetimerootcauses0 in responseTimeRootCauses {
                try responseTimeRootCausesContainer.encode(responsetimerootcauses0)
            }
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceids0 in serviceIds {
                try serviceIdsContainer.encode(serviceids0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for traceusers0 in users {
                try usersContainer.encode(traceusers0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .duration)
        duration = durationDecoded
        let responseTimeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .responseTime)
        responseTime = responseTimeDecoded
        let hasFaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasFault)
        hasFault = hasFaultDecoded
        let hasErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasError)
        hasError = hasErrorDecoded
        let hasThrottleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasThrottle)
        hasThrottle = hasThrottleDecoded
        let isPartialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let httpDecoded = try containerValues.decodeIfPresent(XRayClientTypes.Http.self, forKey: .http)
        http = httpDecoded
        let annotationsContainer = try containerValues.decodeIfPresent([Swift.String: [XRayClientTypes.ValueWithServiceIds?]?].self, forKey: .annotations)
        var annotationsDecoded0: [Swift.String:[XRayClientTypes.ValueWithServiceIds]]? = nil
        if let annotationsContainer = annotationsContainer {
            annotationsDecoded0 = [Swift.String:[XRayClientTypes.ValueWithServiceIds]]()
            for (key0, valueswithserviceids0) in annotationsContainer {
                var valueswithserviceids0Decoded0: [XRayClientTypes.ValueWithServiceIds]? = nil
                if let valueswithserviceids0 = valueswithserviceids0 {
                    valueswithserviceids0Decoded0 = [XRayClientTypes.ValueWithServiceIds]()
                    for structure1 in valueswithserviceids0 {
                        if let structure1 = structure1 {
                            valueswithserviceids0Decoded0?.append(structure1)
                        }
                    }
                }
                annotationsDecoded0?[key0] = valueswithserviceids0Decoded0
            }
        }
        annotations = annotationsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([XRayClientTypes.TraceUser?].self, forKey: .users)
        var usersDecoded0:[XRayClientTypes.TraceUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [XRayClientTypes.TraceUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let serviceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[XRayClientTypes.ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [XRayClientTypes.ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
        let resourceARNsContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResourceARNDetail?].self, forKey: .resourceARNs)
        var resourceARNsDecoded0:[XRayClientTypes.ResourceARNDetail]? = nil
        if let resourceARNsContainer = resourceARNsContainer {
            resourceARNsDecoded0 = [XRayClientTypes.ResourceARNDetail]()
            for structure0 in resourceARNsContainer {
                if let structure0 = structure0 {
                    resourceARNsDecoded0?.append(structure0)
                }
            }
        }
        resourceARNs = resourceARNsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([XRayClientTypes.InstanceIdDetail?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[XRayClientTypes.InstanceIdDetail]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [XRayClientTypes.InstanceIdDetail]()
            for structure0 in instanceIdsContainer {
                if let structure0 = structure0 {
                    instanceIdsDecoded0?.append(structure0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([XRayClientTypes.AvailabilityZoneDetail?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[XRayClientTypes.AvailabilityZoneDetail]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [XRayClientTypes.AvailabilityZoneDetail]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let entryPointDecoded = try containerValues.decodeIfPresent(XRayClientTypes.ServiceId.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let faultRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.FaultRootCause?].self, forKey: .faultRootCauses)
        var faultRootCausesDecoded0:[XRayClientTypes.FaultRootCause]? = nil
        if let faultRootCausesContainer = faultRootCausesContainer {
            faultRootCausesDecoded0 = [XRayClientTypes.FaultRootCause]()
            for structure0 in faultRootCausesContainer {
                if let structure0 = structure0 {
                    faultRootCausesDecoded0?.append(structure0)
                }
            }
        }
        faultRootCauses = faultRootCausesDecoded0
        let errorRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ErrorRootCause?].self, forKey: .errorRootCauses)
        var errorRootCausesDecoded0:[XRayClientTypes.ErrorRootCause]? = nil
        if let errorRootCausesContainer = errorRootCausesContainer {
            errorRootCausesDecoded0 = [XRayClientTypes.ErrorRootCause]()
            for structure0 in errorRootCausesContainer {
                if let structure0 = structure0 {
                    errorRootCausesDecoded0?.append(structure0)
                }
            }
        }
        errorRootCauses = errorRootCausesDecoded0
        let responseTimeRootCausesContainer = try containerValues.decodeIfPresent([XRayClientTypes.ResponseTimeRootCause?].self, forKey: .responseTimeRootCauses)
        var responseTimeRootCausesDecoded0:[XRayClientTypes.ResponseTimeRootCause]? = nil
        if let responseTimeRootCausesContainer = responseTimeRootCausesContainer {
            responseTimeRootCausesDecoded0 = [XRayClientTypes.ResponseTimeRootCause]()
            for structure0 in responseTimeRootCausesContainer {
                if let structure0 = structure0 {
                    responseTimeRootCausesDecoded0?.append(structure0)
                }
            }
        }
        responseTimeRootCauses = responseTimeRootCausesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .revision) ?? 0
        revision = revisionDecoded
        let matchedEventTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .matchedEventTime)
        matchedEventTime = matchedEventTimeDecoded
    }
}
