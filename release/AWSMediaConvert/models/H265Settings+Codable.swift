// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MediaConvertClientTypes.H265Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adaptiveQuantization = "adaptiveQuantization"
        case alternateTransferFunctionSei = "alternateTransferFunctionSei"
        case bitrate = "bitrate"
        case codecLevel = "codecLevel"
        case codecProfile = "codecProfile"
        case dynamicSubGop = "dynamicSubGop"
        case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
        case framerateControl = "framerateControl"
        case framerateConversionAlgorithm = "framerateConversionAlgorithm"
        case framerateDenominator = "framerateDenominator"
        case framerateNumerator = "framerateNumerator"
        case gopBReference = "gopBReference"
        case gopClosedCadence = "gopClosedCadence"
        case gopSize = "gopSize"
        case gopSizeUnits = "gopSizeUnits"
        case hrdBufferInitialFillPercentage = "hrdBufferInitialFillPercentage"
        case hrdBufferSize = "hrdBufferSize"
        case interlaceMode = "interlaceMode"
        case maxBitrate = "maxBitrate"
        case minIInterval = "minIInterval"
        case numberBFramesBetweenReferenceFrames = "numberBFramesBetweenReferenceFrames"
        case numberReferenceFrames = "numberReferenceFrames"
        case parControl = "parControl"
        case parDenominator = "parDenominator"
        case parNumerator = "parNumerator"
        case qualityTuningLevel = "qualityTuningLevel"
        case qvbrSettings = "qvbrSettings"
        case rateControlMode = "rateControlMode"
        case sampleAdaptiveOffsetFilterMode = "sampleAdaptiveOffsetFilterMode"
        case scanTypeConversionMode = "scanTypeConversionMode"
        case sceneChangeDetect = "sceneChangeDetect"
        case slices = "slices"
        case slowPal = "slowPal"
        case spatialAdaptiveQuantization = "spatialAdaptiveQuantization"
        case telecine = "telecine"
        case temporalAdaptiveQuantization = "temporalAdaptiveQuantization"
        case temporalIds = "temporalIds"
        case tiles = "tiles"
        case unregisteredSeiTimecode = "unregisteredSeiTimecode"
        case writeMp4PackagingType = "writeMp4PackagingType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adaptiveQuantization = self.adaptiveQuantization {
            try encodeContainer.encode(adaptiveQuantization.rawValue, forKey: .adaptiveQuantization)
        }
        if let alternateTransferFunctionSei = self.alternateTransferFunctionSei {
            try encodeContainer.encode(alternateTransferFunctionSei.rawValue, forKey: .alternateTransferFunctionSei)
        }
        if let bitrate = self.bitrate {
            try encodeContainer.encode(bitrate, forKey: .bitrate)
        }
        if let codecLevel = self.codecLevel {
            try encodeContainer.encode(codecLevel.rawValue, forKey: .codecLevel)
        }
        if let codecProfile = self.codecProfile {
            try encodeContainer.encode(codecProfile.rawValue, forKey: .codecProfile)
        }
        if let dynamicSubGop = self.dynamicSubGop {
            try encodeContainer.encode(dynamicSubGop.rawValue, forKey: .dynamicSubGop)
        }
        if let flickerAdaptiveQuantization = self.flickerAdaptiveQuantization {
            try encodeContainer.encode(flickerAdaptiveQuantization.rawValue, forKey: .flickerAdaptiveQuantization)
        }
        if let framerateControl = self.framerateControl {
            try encodeContainer.encode(framerateControl.rawValue, forKey: .framerateControl)
        }
        if let framerateConversionAlgorithm = self.framerateConversionAlgorithm {
            try encodeContainer.encode(framerateConversionAlgorithm.rawValue, forKey: .framerateConversionAlgorithm)
        }
        if let framerateDenominator = self.framerateDenominator {
            try encodeContainer.encode(framerateDenominator, forKey: .framerateDenominator)
        }
        if let framerateNumerator = self.framerateNumerator {
            try encodeContainer.encode(framerateNumerator, forKey: .framerateNumerator)
        }
        if let gopBReference = self.gopBReference {
            try encodeContainer.encode(gopBReference.rawValue, forKey: .gopBReference)
        }
        if let gopClosedCadence = self.gopClosedCadence {
            try encodeContainer.encode(gopClosedCadence, forKey: .gopClosedCadence)
        }
        if let gopSize = self.gopSize {
            try encodeContainer.encode(gopSize, forKey: .gopSize)
        }
        if let gopSizeUnits = self.gopSizeUnits {
            try encodeContainer.encode(gopSizeUnits.rawValue, forKey: .gopSizeUnits)
        }
        if let hrdBufferInitialFillPercentage = self.hrdBufferInitialFillPercentage {
            try encodeContainer.encode(hrdBufferInitialFillPercentage, forKey: .hrdBufferInitialFillPercentage)
        }
        if let hrdBufferSize = self.hrdBufferSize {
            try encodeContainer.encode(hrdBufferSize, forKey: .hrdBufferSize)
        }
        if let interlaceMode = self.interlaceMode {
            try encodeContainer.encode(interlaceMode.rawValue, forKey: .interlaceMode)
        }
        if let maxBitrate = self.maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let minIInterval = self.minIInterval {
            try encodeContainer.encode(minIInterval, forKey: .minIInterval)
        }
        if let numberBFramesBetweenReferenceFrames = self.numberBFramesBetweenReferenceFrames {
            try encodeContainer.encode(numberBFramesBetweenReferenceFrames, forKey: .numberBFramesBetweenReferenceFrames)
        }
        if let numberReferenceFrames = self.numberReferenceFrames {
            try encodeContainer.encode(numberReferenceFrames, forKey: .numberReferenceFrames)
        }
        if let parControl = self.parControl {
            try encodeContainer.encode(parControl.rawValue, forKey: .parControl)
        }
        if let parDenominator = self.parDenominator {
            try encodeContainer.encode(parDenominator, forKey: .parDenominator)
        }
        if let parNumerator = self.parNumerator {
            try encodeContainer.encode(parNumerator, forKey: .parNumerator)
        }
        if let qualityTuningLevel = self.qualityTuningLevel {
            try encodeContainer.encode(qualityTuningLevel.rawValue, forKey: .qualityTuningLevel)
        }
        if let qvbrSettings = self.qvbrSettings {
            try encodeContainer.encode(qvbrSettings, forKey: .qvbrSettings)
        }
        if let rateControlMode = self.rateControlMode {
            try encodeContainer.encode(rateControlMode.rawValue, forKey: .rateControlMode)
        }
        if let sampleAdaptiveOffsetFilterMode = self.sampleAdaptiveOffsetFilterMode {
            try encodeContainer.encode(sampleAdaptiveOffsetFilterMode.rawValue, forKey: .sampleAdaptiveOffsetFilterMode)
        }
        if let scanTypeConversionMode = self.scanTypeConversionMode {
            try encodeContainer.encode(scanTypeConversionMode.rawValue, forKey: .scanTypeConversionMode)
        }
        if let sceneChangeDetect = self.sceneChangeDetect {
            try encodeContainer.encode(sceneChangeDetect.rawValue, forKey: .sceneChangeDetect)
        }
        if let slices = self.slices {
            try encodeContainer.encode(slices, forKey: .slices)
        }
        if let slowPal = self.slowPal {
            try encodeContainer.encode(slowPal.rawValue, forKey: .slowPal)
        }
        if let spatialAdaptiveQuantization = self.spatialAdaptiveQuantization {
            try encodeContainer.encode(spatialAdaptiveQuantization.rawValue, forKey: .spatialAdaptiveQuantization)
        }
        if let telecine = self.telecine {
            try encodeContainer.encode(telecine.rawValue, forKey: .telecine)
        }
        if let temporalAdaptiveQuantization = self.temporalAdaptiveQuantization {
            try encodeContainer.encode(temporalAdaptiveQuantization.rawValue, forKey: .temporalAdaptiveQuantization)
        }
        if let temporalIds = self.temporalIds {
            try encodeContainer.encode(temporalIds.rawValue, forKey: .temporalIds)
        }
        if let tiles = self.tiles {
            try encodeContainer.encode(tiles.rawValue, forKey: .tiles)
        }
        if let unregisteredSeiTimecode = self.unregisteredSeiTimecode {
            try encodeContainer.encode(unregisteredSeiTimecode.rawValue, forKey: .unregisteredSeiTimecode)
        }
        if let writeMp4PackagingType = self.writeMp4PackagingType {
            try encodeContainer.encode(writeMp4PackagingType.rawValue, forKey: .writeMp4PackagingType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265AdaptiveQuantization.self, forKey: .adaptiveQuantization)
        adaptiveQuantization = adaptiveQuantizationDecoded
        let alternateTransferFunctionSeiDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265AlternateTransferFunctionSei.self, forKey: .alternateTransferFunctionSei)
        alternateTransferFunctionSei = alternateTransferFunctionSeiDecoded
        let bitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bitrate)
        bitrate = bitrateDecoded
        let codecLevelDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265CodecLevel.self, forKey: .codecLevel)
        codecLevel = codecLevelDecoded
        let codecProfileDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265CodecProfile.self, forKey: .codecProfile)
        codecProfile = codecProfileDecoded
        let dynamicSubGopDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265DynamicSubGop.self, forKey: .dynamicSubGop)
        dynamicSubGop = dynamicSubGopDecoded
        let flickerAdaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265FlickerAdaptiveQuantization.self, forKey: .flickerAdaptiveQuantization)
        flickerAdaptiveQuantization = flickerAdaptiveQuantizationDecoded
        let framerateControlDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265FramerateControl.self, forKey: .framerateControl)
        framerateControl = framerateControlDecoded
        let framerateConversionAlgorithmDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265FramerateConversionAlgorithm.self, forKey: .framerateConversionAlgorithm)
        framerateConversionAlgorithm = framerateConversionAlgorithmDecoded
        let framerateDenominatorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .framerateDenominator)
        framerateDenominator = framerateDenominatorDecoded
        let framerateNumeratorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .framerateNumerator)
        framerateNumerator = framerateNumeratorDecoded
        let gopBReferenceDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265GopBReference.self, forKey: .gopBReference)
        gopBReference = gopBReferenceDecoded
        let gopClosedCadenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gopClosedCadence)
        gopClosedCadence = gopClosedCadenceDecoded
        let gopSizeDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .gopSize)
        gopSize = gopSizeDecoded
        let gopSizeUnitsDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265GopSizeUnits.self, forKey: .gopSizeUnits)
        gopSizeUnits = gopSizeUnitsDecoded
        let hrdBufferInitialFillPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hrdBufferInitialFillPercentage)
        hrdBufferInitialFillPercentage = hrdBufferInitialFillPercentageDecoded
        let hrdBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hrdBufferSize)
        hrdBufferSize = hrdBufferSizeDecoded
        let interlaceModeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265InterlaceMode.self, forKey: .interlaceMode)
        interlaceMode = interlaceModeDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let minIIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minIInterval)
        minIInterval = minIIntervalDecoded
        let numberBFramesBetweenReferenceFramesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberBFramesBetweenReferenceFrames)
        numberBFramesBetweenReferenceFrames = numberBFramesBetweenReferenceFramesDecoded
        let numberReferenceFramesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberReferenceFrames)
        numberReferenceFrames = numberReferenceFramesDecoded
        let parControlDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265ParControl.self, forKey: .parControl)
        parControl = parControlDecoded
        let parDenominatorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parDenominator)
        parDenominator = parDenominatorDecoded
        let parNumeratorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .parNumerator)
        parNumerator = parNumeratorDecoded
        let qualityTuningLevelDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265QualityTuningLevel.self, forKey: .qualityTuningLevel)
        qualityTuningLevel = qualityTuningLevelDecoded
        let qvbrSettingsDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265QvbrSettings.self, forKey: .qvbrSettings)
        qvbrSettings = qvbrSettingsDecoded
        let rateControlModeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265RateControlMode.self, forKey: .rateControlMode)
        rateControlMode = rateControlModeDecoded
        let sampleAdaptiveOffsetFilterModeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265SampleAdaptiveOffsetFilterMode.self, forKey: .sampleAdaptiveOffsetFilterMode)
        sampleAdaptiveOffsetFilterMode = sampleAdaptiveOffsetFilterModeDecoded
        let scanTypeConversionModeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265ScanTypeConversionMode.self, forKey: .scanTypeConversionMode)
        scanTypeConversionMode = scanTypeConversionModeDecoded
        let sceneChangeDetectDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265SceneChangeDetect.self, forKey: .sceneChangeDetect)
        sceneChangeDetect = sceneChangeDetectDecoded
        let slicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .slices)
        slices = slicesDecoded
        let slowPalDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265SlowPal.self, forKey: .slowPal)
        slowPal = slowPalDecoded
        let spatialAdaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265SpatialAdaptiveQuantization.self, forKey: .spatialAdaptiveQuantization)
        spatialAdaptiveQuantization = spatialAdaptiveQuantizationDecoded
        let telecineDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265Telecine.self, forKey: .telecine)
        telecine = telecineDecoded
        let temporalAdaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265TemporalAdaptiveQuantization.self, forKey: .temporalAdaptiveQuantization)
        temporalAdaptiveQuantization = temporalAdaptiveQuantizationDecoded
        let temporalIdsDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265TemporalIds.self, forKey: .temporalIds)
        temporalIds = temporalIdsDecoded
        let tilesDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265Tiles.self, forKey: .tiles)
        tiles = tilesDecoded
        let unregisteredSeiTimecodeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265UnregisteredSeiTimecode.self, forKey: .unregisteredSeiTimecode)
        unregisteredSeiTimecode = unregisteredSeiTimecodeDecoded
        let writeMp4PackagingTypeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.H265WriteMp4PackagingType.self, forKey: .writeMp4PackagingType)
        writeMp4PackagingType = writeMp4PackagingTypeDecoded
    }
}
