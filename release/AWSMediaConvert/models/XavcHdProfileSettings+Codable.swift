// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MediaConvertClientTypes.XavcHdProfileSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitrateClass = "bitrateClass"
        case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
        case gopBReference = "gopBReference"
        case gopClosedCadence = "gopClosedCadence"
        case hrdBufferSize = "hrdBufferSize"
        case interlaceMode = "interlaceMode"
        case qualityTuningLevel = "qualityTuningLevel"
        case slices = "slices"
        case telecine = "telecine"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitrateClass = self.bitrateClass {
            try encodeContainer.encode(bitrateClass.rawValue, forKey: .bitrateClass)
        }
        if let flickerAdaptiveQuantization = self.flickerAdaptiveQuantization {
            try encodeContainer.encode(flickerAdaptiveQuantization.rawValue, forKey: .flickerAdaptiveQuantization)
        }
        if let gopBReference = self.gopBReference {
            try encodeContainer.encode(gopBReference.rawValue, forKey: .gopBReference)
        }
        if let gopClosedCadence = self.gopClosedCadence {
            try encodeContainer.encode(gopClosedCadence, forKey: .gopClosedCadence)
        }
        if let hrdBufferSize = self.hrdBufferSize {
            try encodeContainer.encode(hrdBufferSize, forKey: .hrdBufferSize)
        }
        if let interlaceMode = self.interlaceMode {
            try encodeContainer.encode(interlaceMode.rawValue, forKey: .interlaceMode)
        }
        if let qualityTuningLevel = self.qualityTuningLevel {
            try encodeContainer.encode(qualityTuningLevel.rawValue, forKey: .qualityTuningLevel)
        }
        if let slices = self.slices {
            try encodeContainer.encode(slices, forKey: .slices)
        }
        if let telecine = self.telecine {
            try encodeContainer.encode(telecine.rawValue, forKey: .telecine)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bitrateClassDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcHdProfileBitrateClass.self, forKey: .bitrateClass)
        bitrateClass = bitrateClassDecoded
        let flickerAdaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcFlickerAdaptiveQuantization.self, forKey: .flickerAdaptiveQuantization)
        flickerAdaptiveQuantization = flickerAdaptiveQuantizationDecoded
        let gopBReferenceDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcGopBReference.self, forKey: .gopBReference)
        gopBReference = gopBReferenceDecoded
        let gopClosedCadenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gopClosedCadence)
        gopClosedCadence = gopClosedCadenceDecoded
        let hrdBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hrdBufferSize)
        hrdBufferSize = hrdBufferSizeDecoded
        let interlaceModeDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcInterlaceMode.self, forKey: .interlaceMode)
        interlaceMode = interlaceModeDecoded
        let qualityTuningLevelDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcHdProfileQualityTuningLevel.self, forKey: .qualityTuningLevel)
        qualityTuningLevel = qualityTuningLevelDecoded
        let slicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .slices)
        slices = slicesDecoded
        let telecineDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcHdProfileTelecine.self, forKey: .telecine)
        telecine = telecineDecoded
    }
}
