// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension MediaConvertClientTypes.Xavc4kProfileSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitrateClass = "bitrateClass"
        case codecProfile = "codecProfile"
        case flickerAdaptiveQuantization = "flickerAdaptiveQuantization"
        case gopBReference = "gopBReference"
        case gopClosedCadence = "gopClosedCadence"
        case hrdBufferSize = "hrdBufferSize"
        case qualityTuningLevel = "qualityTuningLevel"
        case slices = "slices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitrateClass = self.bitrateClass {
            try encodeContainer.encode(bitrateClass.rawValue, forKey: .bitrateClass)
        }
        if let codecProfile = self.codecProfile {
            try encodeContainer.encode(codecProfile.rawValue, forKey: .codecProfile)
        }
        if let flickerAdaptiveQuantization = self.flickerAdaptiveQuantization {
            try encodeContainer.encode(flickerAdaptiveQuantization.rawValue, forKey: .flickerAdaptiveQuantization)
        }
        if let gopBReference = self.gopBReference {
            try encodeContainer.encode(gopBReference.rawValue, forKey: .gopBReference)
        }
        if let gopClosedCadence = self.gopClosedCadence {
            try encodeContainer.encode(gopClosedCadence, forKey: .gopClosedCadence)
        }
        if let hrdBufferSize = self.hrdBufferSize {
            try encodeContainer.encode(hrdBufferSize, forKey: .hrdBufferSize)
        }
        if let qualityTuningLevel = self.qualityTuningLevel {
            try encodeContainer.encode(qualityTuningLevel.rawValue, forKey: .qualityTuningLevel)
        }
        if let slices = self.slices {
            try encodeContainer.encode(slices, forKey: .slices)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bitrateClassDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.Xavc4kProfileBitrateClass.self, forKey: .bitrateClass)
        bitrateClass = bitrateClassDecoded
        let codecProfileDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.Xavc4kProfileCodecProfile.self, forKey: .codecProfile)
        codecProfile = codecProfileDecoded
        let flickerAdaptiveQuantizationDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcFlickerAdaptiveQuantization.self, forKey: .flickerAdaptiveQuantization)
        flickerAdaptiveQuantization = flickerAdaptiveQuantizationDecoded
        let gopBReferenceDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.XavcGopBReference.self, forKey: .gopBReference)
        gopBReference = gopBReferenceDecoded
        let gopClosedCadenceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gopClosedCadence)
        gopClosedCadence = gopClosedCadenceDecoded
        let hrdBufferSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hrdBufferSize)
        hrdBufferSize = hrdBufferSizeDecoded
        let qualityTuningLevelDecoded = try containerValues.decodeIfPresent(MediaConvertClientTypes.Xavc4kProfileQualityTuningLevel.self, forKey: .qualityTuningLevel)
        qualityTuningLevel = qualityTuningLevelDecoded
        let slicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .slices)
        slices = slicesDecoded
    }
}
