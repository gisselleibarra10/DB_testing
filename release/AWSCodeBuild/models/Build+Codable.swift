// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CodeBuildClientTypes.Build: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case artifacts
        case buildBatchArn
        case buildComplete
        case buildNumber
        case buildStatus
        case cache
        case currentPhase
        case debugSession
        case encryptionKey
        case endTime
        case environment
        case exportedEnvironmentVariables
        case fileSystemLocations
        case id
        case initiator
        case logs
        case networkInterface
        case phases
        case projectName
        case queuedTimeoutInMinutes
        case reportArns
        case resolvedSourceVersion
        case secondaryArtifacts
        case secondarySourceVersions
        case secondarySources
        case serviceRole
        case source
        case sourceVersion
        case startTime
        case timeoutInMinutes
        case vpcConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let artifacts = self.artifacts {
            try encodeContainer.encode(artifacts, forKey: .artifacts)
        }
        if let buildBatchArn = self.buildBatchArn {
            try encodeContainer.encode(buildBatchArn, forKey: .buildBatchArn)
        }
        if buildComplete != false {
            try encodeContainer.encode(buildComplete, forKey: .buildComplete)
        }
        if let buildNumber = self.buildNumber {
            try encodeContainer.encode(buildNumber, forKey: .buildNumber)
        }
        if let buildStatus = self.buildStatus {
            try encodeContainer.encode(buildStatus.rawValue, forKey: .buildStatus)
        }
        if let cache = self.cache {
            try encodeContainer.encode(cache, forKey: .cache)
        }
        if let currentPhase = self.currentPhase {
            try encodeContainer.encode(currentPhase, forKey: .currentPhase)
        }
        if let debugSession = self.debugSession {
            try encodeContainer.encode(debugSession, forKey: .debugSession)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let exportedEnvironmentVariables = exportedEnvironmentVariables {
            var exportedEnvironmentVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exportedEnvironmentVariables)
            for exportedenvironmentvariables0 in exportedEnvironmentVariables {
                try exportedEnvironmentVariablesContainer.encode(exportedenvironmentvariables0)
            }
        }
        if let fileSystemLocations = fileSystemLocations {
            var fileSystemLocationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemLocations)
            for projectfilesystemlocations0 in fileSystemLocations {
                try fileSystemLocationsContainer.encode(projectfilesystemlocations0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let initiator = self.initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if let logs = self.logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let networkInterface = self.networkInterface {
            try encodeContainer.encode(networkInterface, forKey: .networkInterface)
        }
        if let phases = phases {
            var phasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phases)
            for buildphases0 in phases {
                try phasesContainer.encode(buildphases0)
            }
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let queuedTimeoutInMinutes = self.queuedTimeoutInMinutes {
            try encodeContainer.encode(queuedTimeoutInMinutes, forKey: .queuedTimeoutInMinutes)
        }
        if let reportArns = reportArns {
            var reportArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reportArns)
            for buildreportarns0 in reportArns {
                try reportArnsContainer.encode(buildreportarns0)
            }
        }
        if let resolvedSourceVersion = self.resolvedSourceVersion {
            try encodeContainer.encode(resolvedSourceVersion, forKey: .resolvedSourceVersion)
        }
        if let secondaryArtifacts = secondaryArtifacts {
            var secondaryArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryArtifacts)
            for buildartifactslist0 in secondaryArtifacts {
                try secondaryArtifactsContainer.encode(buildartifactslist0)
            }
        }
        if let secondarySourceVersions = secondarySourceVersions {
            var secondarySourceVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySourceVersions)
            for projectsecondarysourceversions0 in secondarySourceVersions {
                try secondarySourceVersionsContainer.encode(projectsecondarysourceversions0)
            }
        }
        if let secondarySources = secondarySources {
            var secondarySourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondarySources)
            for projectsources0 in secondarySources {
                try secondarySourcesContainer.encode(projectsources0)
            }
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let timeoutInMinutes = self.timeoutInMinutes {
            try encodeContainer.encode(timeoutInMinutes, forKey: .timeoutInMinutes)
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let buildNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .buildNumber)
        buildNumber = buildNumberDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let currentPhaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPhase)
        currentPhase = currentPhaseDecoded
        let buildStatusDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.StatusType.self, forKey: .buildStatus)
        buildStatus = buildStatusDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let resolvedSourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolvedSourceVersion)
        resolvedSourceVersion = resolvedSourceVersionDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let phasesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildPhase?].self, forKey: .phases)
        var phasesDecoded0:[CodeBuildClientTypes.BuildPhase]? = nil
        if let phasesContainer = phasesContainer {
            phasesDecoded0 = [CodeBuildClientTypes.BuildPhase]()
            for structure0 in phasesContainer {
                if let structure0 = structure0 {
                    phasesDecoded0?.append(structure0)
                }
            }
        }
        phases = phasesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectSource.self, forKey: .source)
        source = sourceDecoded
        let secondarySourcesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSource?].self, forKey: .secondarySources)
        var secondarySourcesDecoded0:[CodeBuildClientTypes.ProjectSource]? = nil
        if let secondarySourcesContainer = secondarySourcesContainer {
            secondarySourcesDecoded0 = [CodeBuildClientTypes.ProjectSource]()
            for structure0 in secondarySourcesContainer {
                if let structure0 = structure0 {
                    secondarySourcesDecoded0?.append(structure0)
                }
            }
        }
        secondarySources = secondarySourcesDecoded0
        let secondarySourceVersionsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectSourceVersion?].self, forKey: .secondarySourceVersions)
        var secondarySourceVersionsDecoded0:[CodeBuildClientTypes.ProjectSourceVersion]? = nil
        if let secondarySourceVersionsContainer = secondarySourceVersionsContainer {
            secondarySourceVersionsDecoded0 = [CodeBuildClientTypes.ProjectSourceVersion]()
            for structure0 in secondarySourceVersionsContainer {
                if let structure0 = structure0 {
                    secondarySourceVersionsDecoded0?.append(structure0)
                }
            }
        }
        secondarySourceVersions = secondarySourceVersionsDecoded0
        let artifactsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.BuildArtifacts.self, forKey: .artifacts)
        artifacts = artifactsDecoded
        let secondaryArtifactsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.BuildArtifacts?].self, forKey: .secondaryArtifacts)
        var secondaryArtifactsDecoded0:[CodeBuildClientTypes.BuildArtifacts]? = nil
        if let secondaryArtifactsContainer = secondaryArtifactsContainer {
            secondaryArtifactsDecoded0 = [CodeBuildClientTypes.BuildArtifacts]()
            for structure0 in secondaryArtifactsContainer {
                if let structure0 = structure0 {
                    secondaryArtifactsDecoded0?.append(structure0)
                }
            }
        }
        secondaryArtifacts = secondaryArtifactsDecoded0
        let cacheDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectCache.self, forKey: .cache)
        cache = cacheDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.ProjectEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let logsDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.LogsLocation.self, forKey: .logs)
        logs = logsDecoded
        let timeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMinutes)
        timeoutInMinutes = timeoutInMinutesDecoded
        let queuedTimeoutInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .queuedTimeoutInMinutes)
        queuedTimeoutInMinutes = queuedTimeoutInMinutesDecoded
        let buildCompleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .buildComplete) ?? false
        buildComplete = buildCompleteDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initiator)
        initiator = initiatorDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let networkInterfaceDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.NetworkInterface.self, forKey: .networkInterface)
        networkInterface = networkInterfaceDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let exportedEnvironmentVariablesContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ExportedEnvironmentVariable?].self, forKey: .exportedEnvironmentVariables)
        var exportedEnvironmentVariablesDecoded0:[CodeBuildClientTypes.ExportedEnvironmentVariable]? = nil
        if let exportedEnvironmentVariablesContainer = exportedEnvironmentVariablesContainer {
            exportedEnvironmentVariablesDecoded0 = [CodeBuildClientTypes.ExportedEnvironmentVariable]()
            for structure0 in exportedEnvironmentVariablesContainer {
                if let structure0 = structure0 {
                    exportedEnvironmentVariablesDecoded0?.append(structure0)
                }
            }
        }
        exportedEnvironmentVariables = exportedEnvironmentVariablesDecoded0
        let reportArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .reportArns)
        var reportArnsDecoded0:[Swift.String]? = nil
        if let reportArnsContainer = reportArnsContainer {
            reportArnsDecoded0 = [Swift.String]()
            for string0 in reportArnsContainer {
                if let string0 = string0 {
                    reportArnsDecoded0?.append(string0)
                }
            }
        }
        reportArns = reportArnsDecoded0
        let fileSystemLocationsContainer = try containerValues.decodeIfPresent([CodeBuildClientTypes.ProjectFileSystemLocation?].self, forKey: .fileSystemLocations)
        var fileSystemLocationsDecoded0:[CodeBuildClientTypes.ProjectFileSystemLocation]? = nil
        if let fileSystemLocationsContainer = fileSystemLocationsContainer {
            fileSystemLocationsDecoded0 = [CodeBuildClientTypes.ProjectFileSystemLocation]()
            for structure0 in fileSystemLocationsContainer {
                if let structure0 = structure0 {
                    fileSystemLocationsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemLocations = fileSystemLocationsDecoded0
        let debugSessionDecoded = try containerValues.decodeIfPresent(CodeBuildClientTypes.DebugSession.self, forKey: .debugSession)
        debugSession = debugSessionDecoded
        let buildBatchArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildBatchArn)
        buildBatchArn = buildBatchArnDecoded
    }
}
