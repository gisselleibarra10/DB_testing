// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CloudWatchClientTypes.CompositeAlarm: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsEnabled = "ActionsEnabled"
        case actionsSuppressedBy = "ActionsSuppressedBy"
        case actionsSuppressedReason = "ActionsSuppressedReason"
        case actionsSuppressor = "ActionsSuppressor"
        case actionsSuppressorExtensionPeriod = "ActionsSuppressorExtensionPeriod"
        case actionsSuppressorWaitPeriod = "ActionsSuppressorWaitPeriod"
        case alarmActions = "AlarmActions"
        case alarmArn = "AlarmArn"
        case alarmConfigurationUpdatedTimestamp = "AlarmConfigurationUpdatedTimestamp"
        case alarmDescription = "AlarmDescription"
        case alarmName = "AlarmName"
        case alarmRule = "AlarmRule"
        case insufficientDataActions = "InsufficientDataActions"
        case oKActions = "OKActions"
        case stateReason = "StateReason"
        case stateReasonData = "StateReasonData"
        case stateTransitionedTimestamp = "StateTransitionedTimestamp"
        case stateUpdatedTimestamp = "StateUpdatedTimestamp"
        case stateValue = "StateValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let actionsEnabled = actionsEnabled {
            try container.encode(actionsEnabled, forKey: ClientRuntime.Key("ActionsEnabled"))
        }
        if let actionsSuppressedBy = actionsSuppressedBy {
            try container.encode(actionsSuppressedBy, forKey: ClientRuntime.Key("ActionsSuppressedBy"))
        }
        if let actionsSuppressedReason = actionsSuppressedReason {
            try container.encode(actionsSuppressedReason, forKey: ClientRuntime.Key("ActionsSuppressedReason"))
        }
        if let actionsSuppressor = actionsSuppressor {
            try container.encode(actionsSuppressor, forKey: ClientRuntime.Key("ActionsSuppressor"))
        }
        if let actionsSuppressorExtensionPeriod = actionsSuppressorExtensionPeriod {
            try container.encode(actionsSuppressorExtensionPeriod, forKey: ClientRuntime.Key("ActionsSuppressorExtensionPeriod"))
        }
        if let actionsSuppressorWaitPeriod = actionsSuppressorWaitPeriod {
            try container.encode(actionsSuppressorWaitPeriod, forKey: ClientRuntime.Key("ActionsSuppressorWaitPeriod"))
        }
        if let alarmActions = alarmActions {
            var alarmActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AlarmActions"))
            for (index0, resourcename0) in alarmActions.enumerated() {
                try alarmActionsContainer.encode(resourcename0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let alarmArn = alarmArn {
            try container.encode(alarmArn, forKey: ClientRuntime.Key("AlarmArn"))
        }
        if let alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestamp {
            try container.encode(ClientRuntime.TimestampWrapper(alarmConfigurationUpdatedTimestamp, format: .dateTime), forKey: ClientRuntime.Key("alarmConfigurationUpdatedTimestamp"))
        }
        if let alarmDescription = alarmDescription {
            try container.encode(alarmDescription, forKey: ClientRuntime.Key("AlarmDescription"))
        }
        if let alarmName = alarmName {
            try container.encode(alarmName, forKey: ClientRuntime.Key("AlarmName"))
        }
        if let alarmRule = alarmRule {
            try container.encode(alarmRule, forKey: ClientRuntime.Key("AlarmRule"))
        }
        if let insufficientDataActions = insufficientDataActions {
            var insufficientDataActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InsufficientDataActions"))
            for (index0, resourcename0) in insufficientDataActions.enumerated() {
                try insufficientDataActionsContainer.encode(resourcename0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let oKActions = oKActions {
            var oKActionsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("OKActions"))
            for (index0, resourcename0) in oKActions.enumerated() {
                try oKActionsContainer.encode(resourcename0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: ClientRuntime.Key("StateReason"))
        }
        if let stateReasonData = stateReasonData {
            try container.encode(stateReasonData, forKey: ClientRuntime.Key("StateReasonData"))
        }
        if let stateTransitionedTimestamp = stateTransitionedTimestamp {
            try container.encode(ClientRuntime.TimestampWrapper(stateTransitionedTimestamp, format: .dateTime), forKey: ClientRuntime.Key("stateTransitionedTimestamp"))
        }
        if let stateUpdatedTimestamp = stateUpdatedTimestamp {
            try container.encode(ClientRuntime.TimestampWrapper(stateUpdatedTimestamp, format: .dateTime), forKey: ClientRuntime.Key("stateUpdatedTimestamp"))
        }
        if let stateValue = stateValue {
            try container.encode(stateValue, forKey: ClientRuntime.Key("StateValue"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .actionsEnabled)
        actionsEnabled = actionsEnabledDecoded
        if containerValues.contains(.alarmActions) {
            struct KeyVal0{struct member{}}
            let alarmActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alarmActions)
            if let alarmActionsWrappedContainer = alarmActionsWrappedContainer {
                let alarmActionsContainer = try alarmActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var alarmActionsBuffer:[Swift.String]? = nil
                if let alarmActionsContainer = alarmActionsContainer {
                    alarmActionsBuffer = [Swift.String]()
                    for stringContainer0 in alarmActionsContainer {
                        alarmActionsBuffer?.append(stringContainer0)
                    }
                }
                alarmActions = alarmActionsBuffer
            } else {
                alarmActions = []
            }
        } else {
            alarmActions = nil
        }
        let alarmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmConfigurationUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmConfigurationUpdatedTimestamp)
        var alarmConfigurationUpdatedTimestampBuffer:ClientRuntime.Date? = nil
        if let alarmConfigurationUpdatedTimestampDecoded = alarmConfigurationUpdatedTimestampDecoded {
            alarmConfigurationUpdatedTimestampBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(alarmConfigurationUpdatedTimestampDecoded, format: .dateTime)
        }
        alarmConfigurationUpdatedTimestamp = alarmConfigurationUpdatedTimestampBuffer
        let alarmDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmDescription)
        alarmDescription = alarmDescriptionDecoded
        let alarmNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let alarmRuleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRule)
        alarmRule = alarmRuleDecoded
        if containerValues.contains(.insufficientDataActions) {
            struct KeyVal0{struct member{}}
            let insufficientDataActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .insufficientDataActions)
            if let insufficientDataActionsWrappedContainer = insufficientDataActionsWrappedContainer {
                let insufficientDataActionsContainer = try insufficientDataActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var insufficientDataActionsBuffer:[Swift.String]? = nil
                if let insufficientDataActionsContainer = insufficientDataActionsContainer {
                    insufficientDataActionsBuffer = [Swift.String]()
                    for stringContainer0 in insufficientDataActionsContainer {
                        insufficientDataActionsBuffer?.append(stringContainer0)
                    }
                }
                insufficientDataActions = insufficientDataActionsBuffer
            } else {
                insufficientDataActions = []
            }
        } else {
            insufficientDataActions = nil
        }
        if containerValues.contains(.oKActions) {
            struct KeyVal0{struct member{}}
            let oKActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .oKActions)
            if let oKActionsWrappedContainer = oKActionsWrappedContainer {
                let oKActionsContainer = try oKActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var oKActionsBuffer:[Swift.String]? = nil
                if let oKActionsContainer = oKActionsContainer {
                    oKActionsBuffer = [Swift.String]()
                    for stringContainer0 in oKActionsContainer {
                        oKActionsBuffer?.append(stringContainer0)
                    }
                }
                oKActions = oKActionsBuffer
            } else {
                oKActions = []
            }
        } else {
            oKActions = nil
        }
        let stateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateReasonData)
        stateReasonData = stateReasonDataDecoded
        let stateUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateUpdatedTimestamp)
        var stateUpdatedTimestampBuffer:ClientRuntime.Date? = nil
        if let stateUpdatedTimestampDecoded = stateUpdatedTimestampDecoded {
            stateUpdatedTimestampBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(stateUpdatedTimestampDecoded, format: .dateTime)
        }
        stateUpdatedTimestamp = stateUpdatedTimestampBuffer
        let stateValueDecoded = try containerValues.decodeIfPresent(CloudWatchClientTypes.StateValue.self, forKey: .stateValue)
        stateValue = stateValueDecoded
        let stateTransitionedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionedTimestamp)
        var stateTransitionedTimestampBuffer:ClientRuntime.Date? = nil
        if let stateTransitionedTimestampDecoded = stateTransitionedTimestampDecoded {
            stateTransitionedTimestampBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(stateTransitionedTimestampDecoded, format: .dateTime)
        }
        stateTransitionedTimestamp = stateTransitionedTimestampBuffer
        let actionsSuppressedByDecoded = try containerValues.decodeIfPresent(CloudWatchClientTypes.ActionsSuppressedBy.self, forKey: .actionsSuppressedBy)
        actionsSuppressedBy = actionsSuppressedByDecoded
        let actionsSuppressedReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionsSuppressedReason)
        actionsSuppressedReason = actionsSuppressedReasonDecoded
        let actionsSuppressorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionsSuppressor)
        actionsSuppressor = actionsSuppressorDecoded
        let actionsSuppressorWaitPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionsSuppressorWaitPeriod)
        actionsSuppressorWaitPeriod = actionsSuppressorWaitPeriodDecoded
        let actionsSuppressorExtensionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .actionsSuppressorExtensionPeriod)
        actionsSuppressorExtensionPeriod = actionsSuppressorExtensionPeriodDecoded
    }
}
