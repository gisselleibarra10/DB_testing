// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct PutMetricAlarmInputBody: Swift.Equatable {
    let alarmName: Swift.String?
    let alarmDescription: Swift.String?
    let actionsEnabled: Swift.Bool?
    let oKActions: [Swift.String]?
    let alarmActions: [Swift.String]?
    let insufficientDataActions: [Swift.String]?
    let metricName: Swift.String?
    let namespace: Swift.String?
    let statistic: CloudWatchClientTypes.Statistic?
    let extendedStatistic: Swift.String?
    let dimensions: [CloudWatchClientTypes.Dimension]?
    let period: Swift.Int?
    let unit: CloudWatchClientTypes.StandardUnit?
    let evaluationPeriods: Swift.Int?
    let datapointsToAlarm: Swift.Int?
    let threshold: Swift.Double?
    let comparisonOperator: CloudWatchClientTypes.ComparisonOperator?
    let treatMissingData: Swift.String?
    let evaluateLowSampleCountPercentile: Swift.String?
    let metrics: [CloudWatchClientTypes.MetricDataQuery]?
    let tags: [CloudWatchClientTypes.Tag]?
    let thresholdMetricId: Swift.String?
}

extension PutMetricAlarmInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionsEnabled = "ActionsEnabled"
        case alarmActions = "AlarmActions"
        case alarmDescription = "AlarmDescription"
        case alarmName = "AlarmName"
        case comparisonOperator = "ComparisonOperator"
        case datapointsToAlarm = "DatapointsToAlarm"
        case dimensions = "Dimensions"
        case evaluateLowSampleCountPercentile = "EvaluateLowSampleCountPercentile"
        case evaluationPeriods = "EvaluationPeriods"
        case extendedStatistic = "ExtendedStatistic"
        case insufficientDataActions = "InsufficientDataActions"
        case metricName = "MetricName"
        case metrics = "Metrics"
        case namespace = "Namespace"
        case oKActions = "OKActions"
        case period = "Period"
        case statistic = "Statistic"
        case tags = "Tags"
        case threshold = "Threshold"
        case thresholdMetricId = "ThresholdMetricId"
        case treatMissingData = "TreatMissingData"
        case unit = "Unit"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmName)
        alarmName = alarmNameDecoded
        let alarmDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmDescription)
        alarmDescription = alarmDescriptionDecoded
        let actionsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .actionsEnabled)
        actionsEnabled = actionsEnabledDecoded
        if containerValues.contains(.oKActions) {
            struct KeyVal0{struct member{}}
            let oKActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .oKActions)
            if let oKActionsWrappedContainer = oKActionsWrappedContainer {
                let oKActionsContainer = try oKActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var oKActionsBuffer:[Swift.String]? = nil
                if let oKActionsContainer = oKActionsContainer {
                    oKActionsBuffer = [Swift.String]()
                    for stringContainer0 in oKActionsContainer {
                        oKActionsBuffer?.append(stringContainer0)
                    }
                }
                oKActions = oKActionsBuffer
            } else {
                oKActions = []
            }
        } else {
            oKActions = nil
        }
        if containerValues.contains(.alarmActions) {
            struct KeyVal0{struct member{}}
            let alarmActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alarmActions)
            if let alarmActionsWrappedContainer = alarmActionsWrappedContainer {
                let alarmActionsContainer = try alarmActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var alarmActionsBuffer:[Swift.String]? = nil
                if let alarmActionsContainer = alarmActionsContainer {
                    alarmActionsBuffer = [Swift.String]()
                    for stringContainer0 in alarmActionsContainer {
                        alarmActionsBuffer?.append(stringContainer0)
                    }
                }
                alarmActions = alarmActionsBuffer
            } else {
                alarmActions = []
            }
        } else {
            alarmActions = nil
        }
        if containerValues.contains(.insufficientDataActions) {
            struct KeyVal0{struct member{}}
            let insufficientDataActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .insufficientDataActions)
            if let insufficientDataActionsWrappedContainer = insufficientDataActionsWrappedContainer {
                let insufficientDataActionsContainer = try insufficientDataActionsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var insufficientDataActionsBuffer:[Swift.String]? = nil
                if let insufficientDataActionsContainer = insufficientDataActionsContainer {
                    insufficientDataActionsBuffer = [Swift.String]()
                    for stringContainer0 in insufficientDataActionsContainer {
                        insufficientDataActionsBuffer?.append(stringContainer0)
                    }
                }
                insufficientDataActions = insufficientDataActionsBuffer
            } else {
                insufficientDataActions = []
            }
        } else {
            insufficientDataActions = nil
        }
        let metricNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let statisticDecoded = try containerValues.decodeIfPresent(CloudWatchClientTypes.Statistic.self, forKey: .statistic)
        statistic = statisticDecoded
        let extendedStatisticDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .extendedStatistic)
        extendedStatistic = extendedStatisticDecoded
        if containerValues.contains(.dimensions) {
            struct KeyVal0{struct member{}}
            let dimensionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .dimensions)
            if let dimensionsWrappedContainer = dimensionsWrappedContainer {
                let dimensionsContainer = try dimensionsWrappedContainer.decodeIfPresent([CloudWatchClientTypes.Dimension].self, forKey: .member)
                var dimensionsBuffer:[CloudWatchClientTypes.Dimension]? = nil
                if let dimensionsContainer = dimensionsContainer {
                    dimensionsBuffer = [CloudWatchClientTypes.Dimension]()
                    for structureContainer0 in dimensionsContainer {
                        dimensionsBuffer?.append(structureContainer0)
                    }
                }
                dimensions = dimensionsBuffer
            } else {
                dimensions = []
            }
        } else {
            dimensions = nil
        }
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
        let unitDecoded = try containerValues.decodeIfPresent(CloudWatchClientTypes.StandardUnit.self, forKey: .unit)
        unit = unitDecoded
        let evaluationPeriodsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .evaluationPeriods)
        evaluationPeriods = evaluationPeriodsDecoded
        let datapointsToAlarmDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .datapointsToAlarm)
        datapointsToAlarm = datapointsToAlarmDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(CloudWatchClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let treatMissingDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .treatMissingData)
        treatMissingData = treatMissingDataDecoded
        let evaluateLowSampleCountPercentileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluateLowSampleCountPercentile)
        evaluateLowSampleCountPercentile = evaluateLowSampleCountPercentileDecoded
        if containerValues.contains(.metrics) {
            struct KeyVal0{struct member{}}
            let metricsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .metrics)
            if let metricsWrappedContainer = metricsWrappedContainer {
                let metricsContainer = try metricsWrappedContainer.decodeIfPresent([CloudWatchClientTypes.MetricDataQuery].self, forKey: .member)
                var metricsBuffer:[CloudWatchClientTypes.MetricDataQuery]? = nil
                if let metricsContainer = metricsContainer {
                    metricsBuffer = [CloudWatchClientTypes.MetricDataQuery]()
                    for structureContainer0 in metricsContainer {
                        metricsBuffer?.append(structureContainer0)
                    }
                }
                metrics = metricsBuffer
            } else {
                metrics = []
            }
        } else {
            metrics = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([CloudWatchClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[CloudWatchClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [CloudWatchClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let thresholdMetricIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thresholdMetricId)
        thresholdMetricId = thresholdMetricIdDecoded
    }
}
