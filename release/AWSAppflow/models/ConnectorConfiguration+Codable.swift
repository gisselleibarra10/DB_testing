// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AppflowClientTypes.ConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfig
        case canUseAsDestination
        case canUseAsSource
        case connectorArn
        case connectorDescription
        case connectorLabel
        case connectorMetadata
        case connectorModes
        case connectorName
        case connectorOwner
        case connectorProvisioningConfig
        case connectorProvisioningType
        case connectorRuntimeSettings
        case connectorType
        case connectorVersion
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case logoURL
        case registeredAt
        case registeredBy
        case supportedApiVersions
        case supportedDestinationConnectors
        case supportedOperators
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
        case supportedWriteOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfig = self.authenticationConfig {
            try encodeContainer.encode(authenticationConfig, forKey: .authenticationConfig)
        }
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorArn = self.connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let connectorDescription = self.connectorDescription {
            try encodeContainer.encode(connectorDescription, forKey: .connectorDescription)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorMetadata = self.connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if let connectorModes = connectorModes {
            var connectorModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorModes)
            for connectormodelist0 in connectorModes {
                try connectorModesContainer.encode(connectormodelist0)
            }
        }
        if let connectorName = self.connectorName {
            try encodeContainer.encode(connectorName, forKey: .connectorName)
        }
        if let connectorOwner = self.connectorOwner {
            try encodeContainer.encode(connectorOwner, forKey: .connectorOwner)
        }
        if let connectorProvisioningConfig = self.connectorProvisioningConfig {
            try encodeContainer.encode(connectorProvisioningConfig, forKey: .connectorProvisioningConfig)
        }
        if let connectorProvisioningType = self.connectorProvisioningType {
            try encodeContainer.encode(connectorProvisioningType.rawValue, forKey: .connectorProvisioningType)
        }
        if let connectorRuntimeSettings = connectorRuntimeSettings {
            var connectorRuntimeSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorRuntimeSettings)
            for connectorruntimesettinglist0 in connectorRuntimeSettings {
                try connectorRuntimeSettingsContainer.encode(connectorruntimesettinglist0)
            }
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let connectorVersion = self.connectorVersion {
            try encodeContainer.encode(connectorVersion, forKey: .connectorVersion)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let logoURL = self.logoURL {
            try encodeContainer.encode(logoURL, forKey: .logoURL)
        }
        if let registeredAt = self.registeredAt {
            try encodeContainer.encode(registeredAt.timeIntervalSince1970, forKey: .registeredAt)
        }
        if let registeredBy = self.registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let supportedApiVersions = supportedApiVersions {
            var supportedApiVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedApiVersions)
            for supportedapiversionlist0 in supportedApiVersions {
                try supportedApiVersionsContainer.encode(supportedapiversionlist0)
            }
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortypelist0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortypelist0.rawValue)
            }
        }
        if let supportedOperators = supportedOperators {
            var supportedOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOperators)
            for supportedoperatorlist0 in supportedOperators {
                try supportedOperatorsContainer.encode(supportedoperatorlist0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulingfrequencytypelist0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulingfrequencytypelist0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertypelist0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertypelist0.rawValue)
            }
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for supportedwriteoperationlist0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(supportedwriteoperationlist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUseAsSource) ?? false
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUseAsDestination) ?? false
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [AppflowClientTypes.ConnectorType]()
            for string0 in supportedDestinationConnectorsContainer {
                if let string0 = string0 {
                    supportedDestinationConnectorsDecoded0?.append(string0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[AppflowClientTypes.ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [AppflowClientTypes.ScheduleFrequencyType]()
            for string0 in supportedSchedulingFrequenciesContainer {
                if let string0 = string0 {
                    supportedSchedulingFrequenciesDecoded0?.append(string0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrivateLinkEnabled) ?? false
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrivateLinkEndpointUrlRequired) ?? false
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[AppflowClientTypes.TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [AppflowClientTypes.TriggerType]()
            for string0 in supportedTriggerTypesContainer {
                if let string0 = string0 {
                    supportedTriggerTypesDecoded0?.append(string0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorOwner)
        connectorOwner = connectorOwnerDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorVersion)
        connectorVersion = connectorVersionDecoded
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorModesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorModes)
        var connectorModesDecoded0:[Swift.String]? = nil
        if let connectorModesContainer = connectorModesContainer {
            connectorModesDecoded0 = [Swift.String]()
            for string0 in connectorModesContainer {
                if let string0 = string0 {
                    connectorModesDecoded0?.append(string0)
                }
            }
        }
        connectorModes = connectorModesDecoded0
        let authenticationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AuthenticationConfig.self, forKey: .authenticationConfig)
        authenticationConfig = authenticationConfigDecoded
        let connectorRuntimeSettingsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorRuntimeSetting?].self, forKey: .connectorRuntimeSettings)
        var connectorRuntimeSettingsDecoded0:[AppflowClientTypes.ConnectorRuntimeSetting]? = nil
        if let connectorRuntimeSettingsContainer = connectorRuntimeSettingsContainer {
            connectorRuntimeSettingsDecoded0 = [AppflowClientTypes.ConnectorRuntimeSetting]()
            for structure0 in connectorRuntimeSettingsContainer {
                if let structure0 = structure0 {
                    connectorRuntimeSettingsDecoded0?.append(structure0)
                }
            }
        }
        connectorRuntimeSettings = connectorRuntimeSettingsDecoded0
        let supportedApiVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedApiVersions)
        var supportedApiVersionsDecoded0:[Swift.String]? = nil
        if let supportedApiVersionsContainer = supportedApiVersionsContainer {
            supportedApiVersionsDecoded0 = [Swift.String]()
            for string0 in supportedApiVersionsContainer {
                if let string0 = string0 {
                    supportedApiVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedApiVersions = supportedApiVersionsDecoded0
        let supportedOperatorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Operators?].self, forKey: .supportedOperators)
        var supportedOperatorsDecoded0:[AppflowClientTypes.Operators]? = nil
        if let supportedOperatorsContainer = supportedOperatorsContainer {
            supportedOperatorsDecoded0 = [AppflowClientTypes.Operators]()
            for string0 in supportedOperatorsContainer {
                if let string0 = string0 {
                    supportedOperatorsDecoded0?.append(string0)
                }
            }
        }
        supportedOperators = supportedOperatorsDecoded0
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[AppflowClientTypes.WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [AppflowClientTypes.WriteOperationType]()
            for string0 in supportedWriteOperationsContainer {
                if let string0 = string0 {
                    supportedWriteOperationsDecoded0?.append(string0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
        let connectorProvisioningTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningType.self, forKey: .connectorProvisioningType)
        connectorProvisioningType = connectorProvisioningTypeDecoded
        let connectorProvisioningConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningConfig.self, forKey: .connectorProvisioningConfig)
        connectorProvisioningConfig = connectorProvisioningConfigDecoded
        let logoURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoURL)
        logoURL = logoURLDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
    }
}
