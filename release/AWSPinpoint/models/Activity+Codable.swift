// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PinpointClientTypes.Activity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cUSTOM = "CUSTOM"
        case conditionalSplit = "ConditionalSplit"
        case contactCenter = "ContactCenter"
        case description = "Description"
        case eMAIL = "EMAIL"
        case holdout = "Holdout"
        case multiCondition = "MultiCondition"
        case pUSH = "PUSH"
        case randomSplit = "RandomSplit"
        case sMS = "SMS"
        case wait = "Wait"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cUSTOM = self.cUSTOM {
            try encodeContainer.encode(cUSTOM, forKey: .cUSTOM)
        }
        if let conditionalSplit = self.conditionalSplit {
            try encodeContainer.encode(conditionalSplit, forKey: .conditionalSplit)
        }
        if let contactCenter = self.contactCenter {
            try encodeContainer.encode(contactCenter, forKey: .contactCenter)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eMAIL = self.eMAIL {
            try encodeContainer.encode(eMAIL, forKey: .eMAIL)
        }
        if let holdout = self.holdout {
            try encodeContainer.encode(holdout, forKey: .holdout)
        }
        if let multiCondition = self.multiCondition {
            try encodeContainer.encode(multiCondition, forKey: .multiCondition)
        }
        if let pUSH = self.pUSH {
            try encodeContainer.encode(pUSH, forKey: .pUSH)
        }
        if let randomSplit = self.randomSplit {
            try encodeContainer.encode(randomSplit, forKey: .randomSplit)
        }
        if let sMS = self.sMS {
            try encodeContainer.encode(sMS, forKey: .sMS)
        }
        if let wait = self.wait {
            try encodeContainer.encode(wait, forKey: .wait)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cUSTOMDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.CustomMessageActivity.self, forKey: .cUSTOM)
        cUSTOM = cUSTOMDecoded
        let conditionalSplitDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.ConditionalSplitActivity.self, forKey: .conditionalSplit)
        conditionalSplit = conditionalSplitDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eMAILDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.EmailMessageActivity.self, forKey: .eMAIL)
        eMAIL = eMAILDecoded
        let holdoutDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.HoldoutActivity.self, forKey: .holdout)
        holdout = holdoutDecoded
        let multiConditionDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.MultiConditionalSplitActivity.self, forKey: .multiCondition)
        multiCondition = multiConditionDecoded
        let pUSHDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.PushMessageActivity.self, forKey: .pUSH)
        pUSH = pUSHDecoded
        let randomSplitDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.RandomSplitActivity.self, forKey: .randomSplit)
        randomSplit = randomSplitDecoded
        let sMSDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.SMSMessageActivity.self, forKey: .sMS)
        sMS = sMSDecoded
        let waitDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.WaitActivity.self, forKey: .wait)
        wait = waitDecoded
        let contactCenterDecoded = try containerValues.decodeIfPresent(PinpointClientTypes.ContactCenterActivity.self, forKey: .contactCenter)
        contactCenter = contactCenterDecoded
    }
}
