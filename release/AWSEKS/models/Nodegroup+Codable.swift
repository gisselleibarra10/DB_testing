// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EksClientTypes.Nodegroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiType
        case capacityType
        case clusterName
        case createdAt
        case diskSize
        case health
        case instanceTypes
        case labels
        case launchTemplate
        case modifiedAt
        case nodeRole
        case nodegroupArn
        case nodegroupName
        case releaseVersion
        case remoteAccess
        case resources
        case scalingConfig
        case status
        case subnets
        case tags
        case taints
        case updateConfig
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiType = self.amiType {
            try encodeContainer.encode(amiType.rawValue, forKey: .amiType)
        }
        if let capacityType = self.capacityType {
            try encodeContainer.encode(capacityType.rawValue, forKey: .capacityType)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let diskSize = self.diskSize {
            try encodeContainer.encode(diskSize, forKey: .diskSize)
        }
        if let health = self.health {
            try encodeContainer.encode(health, forKey: .health)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for stringlist0 in instanceTypes {
                try instanceTypesContainer.encode(stringlist0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .labels)
            for (dictKey0, labelsmap0) in labels {
                try labelsContainer.encode(labelsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let launchTemplate = self.launchTemplate {
            try encodeContainer.encode(launchTemplate, forKey: .launchTemplate)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encode(modifiedAt.timeIntervalSince1970, forKey: .modifiedAt)
        }
        if let nodeRole = self.nodeRole {
            try encodeContainer.encode(nodeRole, forKey: .nodeRole)
        }
        if let nodegroupArn = self.nodegroupArn {
            try encodeContainer.encode(nodegroupArn, forKey: .nodegroupArn)
        }
        if let nodegroupName = self.nodegroupName {
            try encodeContainer.encode(nodegroupName, forKey: .nodegroupName)
        }
        if let releaseVersion = self.releaseVersion {
            try encodeContainer.encode(releaseVersion, forKey: .releaseVersion)
        }
        if let remoteAccess = self.remoteAccess {
            try encodeContainer.encode(remoteAccess, forKey: .remoteAccess)
        }
        if let resources = self.resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let scalingConfig = self.scalingConfig {
            try encodeContainer.encode(scalingConfig, forKey: .scalingConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for stringlist0 in subnets {
                try subnetsContainer.encode(stringlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taints = taints {
            var taintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taints)
            for taintslist0 in taints {
                try taintsContainer.encode(taintslist0)
            }
        }
        if let updateConfig = self.updateConfig {
            try encodeContainer.encode(updateConfig, forKey: .updateConfig)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodegroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodegroupName)
        nodegroupName = nodegroupNameDecoded
        let nodegroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodegroupArn)
        nodegroupArn = nodegroupArnDecoded
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let releaseVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseVersion)
        releaseVersion = releaseVersionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EksClientTypes.NodegroupStatus.self, forKey: .status)
        status = statusDecoded
        let capacityTypeDecoded = try containerValues.decodeIfPresent(EksClientTypes.CapacityTypes.self, forKey: .capacityType)
        capacityType = capacityTypeDecoded
        let scalingConfigDecoded = try containerValues.decodeIfPresent(EksClientTypes.NodegroupScalingConfig.self, forKey: .scalingConfig)
        scalingConfig = scalingConfigDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let remoteAccessDecoded = try containerValues.decodeIfPresent(EksClientTypes.RemoteAccessConfig.self, forKey: .remoteAccess)
        remoteAccess = remoteAccessDecoded
        let amiTypeDecoded = try containerValues.decodeIfPresent(EksClientTypes.AMITypes.self, forKey: .amiType)
        amiType = amiTypeDecoded
        let nodeRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeRole)
        nodeRole = nodeRoleDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .labels)
        var labelsDecoded0: [Swift.String:Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, labelvalue0) in labelsContainer {
                if let labelvalue0 = labelvalue0 {
                    labelsDecoded0?[key0] = labelvalue0
                }
            }
        }
        labels = labelsDecoded0
        let taintsContainer = try containerValues.decodeIfPresent([EksClientTypes.Taint?].self, forKey: .taints)
        var taintsDecoded0:[EksClientTypes.Taint]? = nil
        if let taintsContainer = taintsContainer {
            taintsDecoded0 = [EksClientTypes.Taint]()
            for structure0 in taintsContainer {
                if let structure0 = structure0 {
                    taintsDecoded0?.append(structure0)
                }
            }
        }
        taints = taintsDecoded0
        let resourcesDecoded = try containerValues.decodeIfPresent(EksClientTypes.NodegroupResources.self, forKey: .resources)
        resources = resourcesDecoded
        let diskSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .diskSize)
        diskSize = diskSizeDecoded
        let healthDecoded = try containerValues.decodeIfPresent(EksClientTypes.NodegroupHealth.self, forKey: .health)
        health = healthDecoded
        let updateConfigDecoded = try containerValues.decodeIfPresent(EksClientTypes.NodegroupUpdateConfig.self, forKey: .updateConfig)
        updateConfig = updateConfigDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(EksClientTypes.LaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}
