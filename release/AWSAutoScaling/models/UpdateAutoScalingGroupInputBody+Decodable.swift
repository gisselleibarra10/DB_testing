// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct UpdateAutoScalingGroupInputBody: Swift.Equatable {
    let autoScalingGroupName: Swift.String?
    let launchConfigurationName: Swift.String?
    let launchTemplate: AutoScalingClientTypes.LaunchTemplateSpecification?
    let mixedInstancesPolicy: AutoScalingClientTypes.MixedInstancesPolicy?
    let minSize: Swift.Int?
    let maxSize: Swift.Int?
    let desiredCapacity: Swift.Int?
    let defaultCooldown: Swift.Int?
    let availabilityZones: [Swift.String]?
    let healthCheckType: Swift.String?
    let healthCheckGracePeriod: Swift.Int?
    let placementGroup: Swift.String?
    let vPCZoneIdentifier: Swift.String?
    let terminationPolicies: [Swift.String]?
    let newInstancesProtectedFromScaleIn: Swift.Bool?
    let serviceLinkedRoleARN: Swift.String?
    let maxInstanceLifetime: Swift.Int?
    let capacityRebalance: Swift.Bool?
    let context: Swift.String?
    let desiredCapacityType: Swift.String?
    let defaultInstanceWarmup: Swift.Int?
}

extension UpdateAutoScalingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingGroupName = "AutoScalingGroupName"
        case availabilityZones = "AvailabilityZones"
        case capacityRebalance = "CapacityRebalance"
        case context = "Context"
        case defaultCooldown = "DefaultCooldown"
        case defaultInstanceWarmup = "DefaultInstanceWarmup"
        case desiredCapacity = "DesiredCapacity"
        case desiredCapacityType = "DesiredCapacityType"
        case healthCheckGracePeriod = "HealthCheckGracePeriod"
        case healthCheckType = "HealthCheckType"
        case launchConfigurationName = "LaunchConfigurationName"
        case launchTemplate = "LaunchTemplate"
        case maxInstanceLifetime = "MaxInstanceLifetime"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case mixedInstancesPolicy = "MixedInstancesPolicy"
        case newInstancesProtectedFromScaleIn = "NewInstancesProtectedFromScaleIn"
        case placementGroup = "PlacementGroup"
        case serviceLinkedRoleARN = "ServiceLinkedRoleARN"
        case terminationPolicies = "TerminationPolicies"
        case vPCZoneIdentifier = "VPCZoneIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroupName)
        autoScalingGroupName = autoScalingGroupNameDecoded
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.LaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let mixedInstancesPolicyDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.MixedInstancesPolicy.self, forKey: .mixedInstancesPolicy)
        mixedInstancesPolicy = mixedInstancesPolicyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let desiredCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
        let defaultCooldownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultCooldown)
        defaultCooldown = defaultCooldownDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let healthCheckTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckType)
        healthCheckType = healthCheckTypeDecoded
        let healthCheckGracePeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckGracePeriod)
        healthCheckGracePeriod = healthCheckGracePeriodDecoded
        let placementGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementGroup)
        placementGroup = placementGroupDecoded
        let vPCZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCZoneIdentifier)
        vPCZoneIdentifier = vPCZoneIdentifierDecoded
        if containerValues.contains(.terminationPolicies) {
            struct KeyVal0{struct member{}}
            let terminationPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .terminationPolicies)
            if let terminationPoliciesWrappedContainer = terminationPoliciesWrappedContainer {
                let terminationPoliciesContainer = try terminationPoliciesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var terminationPoliciesBuffer:[Swift.String]? = nil
                if let terminationPoliciesContainer = terminationPoliciesContainer {
                    terminationPoliciesBuffer = [Swift.String]()
                    for stringContainer0 in terminationPoliciesContainer {
                        terminationPoliciesBuffer?.append(stringContainer0)
                    }
                }
                terminationPolicies = terminationPoliciesBuffer
            } else {
                terminationPolicies = []
            }
        } else {
            terminationPolicies = nil
        }
        let newInstancesProtectedFromScaleInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .newInstancesProtectedFromScaleIn)
        newInstancesProtectedFromScaleIn = newInstancesProtectedFromScaleInDecoded
        let serviceLinkedRoleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceLinkedRoleARN)
        serviceLinkedRoleARN = serviceLinkedRoleARNDecoded
        let maxInstanceLifetimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxInstanceLifetime)
        maxInstanceLifetime = maxInstanceLifetimeDecoded
        let capacityRebalanceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .capacityRebalance)
        capacityRebalance = capacityRebalanceDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
        let desiredCapacityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredCapacityType)
        desiredCapacityType = desiredCapacityTypeDecoded
        let defaultInstanceWarmupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultInstanceWarmup)
        defaultInstanceWarmup = defaultInstanceWarmupDecoded
    }
}
