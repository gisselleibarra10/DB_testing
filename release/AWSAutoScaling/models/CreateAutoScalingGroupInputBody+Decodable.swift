// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateAutoScalingGroupInputBody: Swift.Equatable {
    let autoScalingGroupName: Swift.String?
    let launchConfigurationName: Swift.String?
    let launchTemplate: AutoScalingClientTypes.LaunchTemplateSpecification?
    let mixedInstancesPolicy: AutoScalingClientTypes.MixedInstancesPolicy?
    let instanceId: Swift.String?
    let minSize: Swift.Int?
    let maxSize: Swift.Int?
    let desiredCapacity: Swift.Int?
    let defaultCooldown: Swift.Int?
    let availabilityZones: [Swift.String]?
    let loadBalancerNames: [Swift.String]?
    let targetGroupARNs: [Swift.String]?
    let healthCheckType: Swift.String?
    let healthCheckGracePeriod: Swift.Int?
    let placementGroup: Swift.String?
    let vPCZoneIdentifier: Swift.String?
    let terminationPolicies: [Swift.String]?
    let newInstancesProtectedFromScaleIn: Swift.Bool?
    let capacityRebalance: Swift.Bool?
    let lifecycleHookSpecificationList: [AutoScalingClientTypes.LifecycleHookSpecification]?
    let tags: [AutoScalingClientTypes.Tag]?
    let serviceLinkedRoleARN: Swift.String?
    let maxInstanceLifetime: Swift.Int?
    let context: Swift.String?
    let desiredCapacityType: Swift.String?
    let defaultInstanceWarmup: Swift.Int?
}

extension CreateAutoScalingGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingGroupName = "AutoScalingGroupName"
        case availabilityZones = "AvailabilityZones"
        case capacityRebalance = "CapacityRebalance"
        case context = "Context"
        case defaultCooldown = "DefaultCooldown"
        case defaultInstanceWarmup = "DefaultInstanceWarmup"
        case desiredCapacity = "DesiredCapacity"
        case desiredCapacityType = "DesiredCapacityType"
        case healthCheckGracePeriod = "HealthCheckGracePeriod"
        case healthCheckType = "HealthCheckType"
        case instanceId = "InstanceId"
        case launchConfigurationName = "LaunchConfigurationName"
        case launchTemplate = "LaunchTemplate"
        case lifecycleHookSpecificationList = "LifecycleHookSpecificationList"
        case loadBalancerNames = "LoadBalancerNames"
        case maxInstanceLifetime = "MaxInstanceLifetime"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case mixedInstancesPolicy = "MixedInstancesPolicy"
        case newInstancesProtectedFromScaleIn = "NewInstancesProtectedFromScaleIn"
        case placementGroup = "PlacementGroup"
        case serviceLinkedRoleARN = "ServiceLinkedRoleARN"
        case tags = "Tags"
        case targetGroupARNs = "TargetGroupARNs"
        case terminationPolicies = "TerminationPolicies"
        case vPCZoneIdentifier = "VPCZoneIdentifier"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingGroupName)
        autoScalingGroupName = autoScalingGroupNameDecoded
        let launchConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationName)
        launchConfigurationName = launchConfigurationNameDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.LaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let mixedInstancesPolicyDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.MixedInstancesPolicy.self, forKey: .mixedInstancesPolicy)
        mixedInstancesPolicy = mixedInstancesPolicyDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let desiredCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredCapacity)
        desiredCapacity = desiredCapacityDecoded
        let defaultCooldownDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultCooldown)
        defaultCooldown = defaultCooldownDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.loadBalancerNames) {
            struct KeyVal0{struct member{}}
            let loadBalancerNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerNames)
            if let loadBalancerNamesWrappedContainer = loadBalancerNamesWrappedContainer {
                let loadBalancerNamesContainer = try loadBalancerNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var loadBalancerNamesBuffer:[Swift.String]? = nil
                if let loadBalancerNamesContainer = loadBalancerNamesContainer {
                    loadBalancerNamesBuffer = [Swift.String]()
                    for stringContainer0 in loadBalancerNamesContainer {
                        loadBalancerNamesBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerNames = loadBalancerNamesBuffer
            } else {
                loadBalancerNames = []
            }
        } else {
            loadBalancerNames = nil
        }
        if containerValues.contains(.targetGroupARNs) {
            struct KeyVal0{struct member{}}
            let targetGroupARNsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroupARNs)
            if let targetGroupARNsWrappedContainer = targetGroupARNsWrappedContainer {
                let targetGroupARNsContainer = try targetGroupARNsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var targetGroupARNsBuffer:[Swift.String]? = nil
                if let targetGroupARNsContainer = targetGroupARNsContainer {
                    targetGroupARNsBuffer = [Swift.String]()
                    for stringContainer0 in targetGroupARNsContainer {
                        targetGroupARNsBuffer?.append(stringContainer0)
                    }
                }
                targetGroupARNs = targetGroupARNsBuffer
            } else {
                targetGroupARNs = []
            }
        } else {
            targetGroupARNs = nil
        }
        let healthCheckTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckType)
        healthCheckType = healthCheckTypeDecoded
        let healthCheckGracePeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthCheckGracePeriod)
        healthCheckGracePeriod = healthCheckGracePeriodDecoded
        let placementGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementGroup)
        placementGroup = placementGroupDecoded
        let vPCZoneIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vPCZoneIdentifier)
        vPCZoneIdentifier = vPCZoneIdentifierDecoded
        if containerValues.contains(.terminationPolicies) {
            struct KeyVal0{struct member{}}
            let terminationPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .terminationPolicies)
            if let terminationPoliciesWrappedContainer = terminationPoliciesWrappedContainer {
                let terminationPoliciesContainer = try terminationPoliciesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var terminationPoliciesBuffer:[Swift.String]? = nil
                if let terminationPoliciesContainer = terminationPoliciesContainer {
                    terminationPoliciesBuffer = [Swift.String]()
                    for stringContainer0 in terminationPoliciesContainer {
                        terminationPoliciesBuffer?.append(stringContainer0)
                    }
                }
                terminationPolicies = terminationPoliciesBuffer
            } else {
                terminationPolicies = []
            }
        } else {
            terminationPolicies = nil
        }
        let newInstancesProtectedFromScaleInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .newInstancesProtectedFromScaleIn)
        newInstancesProtectedFromScaleIn = newInstancesProtectedFromScaleInDecoded
        let capacityRebalanceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .capacityRebalance)
        capacityRebalance = capacityRebalanceDecoded
        if containerValues.contains(.lifecycleHookSpecificationList) {
            struct KeyVal0{struct member{}}
            let lifecycleHookSpecificationListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .lifecycleHookSpecificationList)
            if let lifecycleHookSpecificationListWrappedContainer = lifecycleHookSpecificationListWrappedContainer {
                let lifecycleHookSpecificationListContainer = try lifecycleHookSpecificationListWrappedContainer.decodeIfPresent([AutoScalingClientTypes.LifecycleHookSpecification].self, forKey: .member)
                var lifecycleHookSpecificationListBuffer:[AutoScalingClientTypes.LifecycleHookSpecification]? = nil
                if let lifecycleHookSpecificationListContainer = lifecycleHookSpecificationListContainer {
                    lifecycleHookSpecificationListBuffer = [AutoScalingClientTypes.LifecycleHookSpecification]()
                    for structureContainer0 in lifecycleHookSpecificationListContainer {
                        lifecycleHookSpecificationListBuffer?.append(structureContainer0)
                    }
                }
                lifecycleHookSpecificationList = lifecycleHookSpecificationListBuffer
            } else {
                lifecycleHookSpecificationList = []
            }
        } else {
            lifecycleHookSpecificationList = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([AutoScalingClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[AutoScalingClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [AutoScalingClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let serviceLinkedRoleARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceLinkedRoleARN)
        serviceLinkedRoleARN = serviceLinkedRoleARNDecoded
        let maxInstanceLifetimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxInstanceLifetime)
        maxInstanceLifetime = maxInstanceLifetimeDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
        let desiredCapacityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredCapacityType)
        desiredCapacityType = desiredCapacityTypeDecoded
        let defaultInstanceWarmupDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .defaultInstanceWarmup)
        defaultInstanceWarmup = defaultInstanceWarmupDecoded
    }
}
