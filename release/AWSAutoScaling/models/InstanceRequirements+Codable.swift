// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AutoScalingClientTypes.InstanceRequirements: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorCount = "AcceleratorCount"
        case acceleratorManufacturers = "AcceleratorManufacturers"
        case acceleratorNames = "AcceleratorNames"
        case acceleratorTotalMemoryMiB = "AcceleratorTotalMemoryMiB"
        case acceleratorTypes = "AcceleratorTypes"
        case bareMetal = "BareMetal"
        case baselineEbsBandwidthMbps = "BaselineEbsBandwidthMbps"
        case burstablePerformance = "BurstablePerformance"
        case cpuManufacturers = "CpuManufacturers"
        case excludedInstanceTypes = "ExcludedInstanceTypes"
        case instanceGenerations = "InstanceGenerations"
        case localStorage = "LocalStorage"
        case localStorageTypes = "LocalStorageTypes"
        case memoryGiBPerVCpu = "MemoryGiBPerVCpu"
        case memoryMiB = "MemoryMiB"
        case networkInterfaceCount = "NetworkInterfaceCount"
        case onDemandMaxPricePercentageOverLowestPrice = "OnDemandMaxPricePercentageOverLowestPrice"
        case requireHibernateSupport = "RequireHibernateSupport"
        case spotMaxPricePercentageOverLowestPrice = "SpotMaxPricePercentageOverLowestPrice"
        case totalLocalStorageGB = "TotalLocalStorageGB"
        case vCpuCount = "VCpuCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let acceleratorCount = acceleratorCount {
            try container.encode(acceleratorCount, forKey: ClientRuntime.Key("AcceleratorCount"))
        }
        if let acceleratorManufacturers = acceleratorManufacturers {
            var acceleratorManufacturersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorManufacturers"))
            for (index0, acceleratormanufacturer0) in acceleratorManufacturers.enumerated() {
                try acceleratorManufacturersContainer.encode(acceleratormanufacturer0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let acceleratorNames = acceleratorNames {
            var acceleratorNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorNames"))
            for (index0, acceleratorname0) in acceleratorNames.enumerated() {
                try acceleratorNamesContainer.encode(acceleratorname0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB {
            try container.encode(acceleratorTotalMemoryMiB, forKey: ClientRuntime.Key("AcceleratorTotalMemoryMiB"))
        }
        if let acceleratorTypes = acceleratorTypes {
            var acceleratorTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorTypes"))
            for (index0, acceleratortype0) in acceleratorTypes.enumerated() {
                try acceleratorTypesContainer.encode(acceleratortype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let bareMetal = bareMetal {
            try container.encode(bareMetal, forKey: ClientRuntime.Key("BareMetal"))
        }
        if let baselineEbsBandwidthMbps = baselineEbsBandwidthMbps {
            try container.encode(baselineEbsBandwidthMbps, forKey: ClientRuntime.Key("BaselineEbsBandwidthMbps"))
        }
        if let burstablePerformance = burstablePerformance {
            try container.encode(burstablePerformance, forKey: ClientRuntime.Key("BurstablePerformance"))
        }
        if let cpuManufacturers = cpuManufacturers {
            var cpuManufacturersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CpuManufacturers"))
            for (index0, cpumanufacturer0) in cpuManufacturers.enumerated() {
                try cpuManufacturersContainer.encode(cpumanufacturer0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let excludedInstanceTypes = excludedInstanceTypes {
            var excludedInstanceTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedInstanceTypes"))
            for (index0, excludedinstance0) in excludedInstanceTypes.enumerated() {
                try excludedInstanceTypesContainer.encode(excludedinstance0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let instanceGenerations = instanceGenerations {
            var instanceGenerationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceGenerations"))
            for (index0, instancegeneration0) in instanceGenerations.enumerated() {
                try instanceGenerationsContainer.encode(instancegeneration0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let localStorage = localStorage {
            try container.encode(localStorage, forKey: ClientRuntime.Key("LocalStorage"))
        }
        if let localStorageTypes = localStorageTypes {
            var localStorageTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LocalStorageTypes"))
            for (index0, localstoragetype0) in localStorageTypes.enumerated() {
                try localStorageTypesContainer.encode(localstoragetype0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let memoryGiBPerVCpu = memoryGiBPerVCpu {
            try container.encode(memoryGiBPerVCpu, forKey: ClientRuntime.Key("MemoryGiBPerVCpu"))
        }
        if let memoryMiB = memoryMiB {
            try container.encode(memoryMiB, forKey: ClientRuntime.Key("MemoryMiB"))
        }
        if let networkInterfaceCount = networkInterfaceCount {
            try container.encode(networkInterfaceCount, forKey: ClientRuntime.Key("NetworkInterfaceCount"))
        }
        if let onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice {
            try container.encode(onDemandMaxPricePercentageOverLowestPrice, forKey: ClientRuntime.Key("OnDemandMaxPricePercentageOverLowestPrice"))
        }
        if let requireHibernateSupport = requireHibernateSupport {
            try container.encode(requireHibernateSupport, forKey: ClientRuntime.Key("RequireHibernateSupport"))
        }
        if let spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice {
            try container.encode(spotMaxPricePercentageOverLowestPrice, forKey: ClientRuntime.Key("SpotMaxPricePercentageOverLowestPrice"))
        }
        if let totalLocalStorageGB = totalLocalStorageGB {
            try container.encode(totalLocalStorageGB, forKey: ClientRuntime.Key("TotalLocalStorageGB"))
        }
        if let vCpuCount = vCpuCount {
            try container.encode(vCpuCount, forKey: ClientRuntime.Key("VCpuCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCpuCountDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.VCpuCountRequest.self, forKey: .vCpuCount)
        vCpuCount = vCpuCountDecoded
        let memoryMiBDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.MemoryMiBRequest.self, forKey: .memoryMiB)
        memoryMiB = memoryMiBDecoded
        if containerValues.contains(.cpuManufacturers) {
            struct KeyVal0{struct member{}}
            let cpuManufacturersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .cpuManufacturers)
            if let cpuManufacturersWrappedContainer = cpuManufacturersWrappedContainer {
                let cpuManufacturersContainer = try cpuManufacturersWrappedContainer.decodeIfPresent([AutoScalingClientTypes.CpuManufacturer].self, forKey: .member)
                var cpuManufacturersBuffer:[AutoScalingClientTypes.CpuManufacturer]? = nil
                if let cpuManufacturersContainer = cpuManufacturersContainer {
                    cpuManufacturersBuffer = [AutoScalingClientTypes.CpuManufacturer]()
                    for stringContainer0 in cpuManufacturersContainer {
                        cpuManufacturersBuffer?.append(stringContainer0)
                    }
                }
                cpuManufacturers = cpuManufacturersBuffer
            } else {
                cpuManufacturers = []
            }
        } else {
            cpuManufacturers = nil
        }
        let memoryGiBPerVCpuDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.MemoryGiBPerVCpuRequest.self, forKey: .memoryGiBPerVCpu)
        memoryGiBPerVCpu = memoryGiBPerVCpuDecoded
        if containerValues.contains(.excludedInstanceTypes) {
            struct KeyVal0{struct member{}}
            let excludedInstanceTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .excludedInstanceTypes)
            if let excludedInstanceTypesWrappedContainer = excludedInstanceTypesWrappedContainer {
                let excludedInstanceTypesContainer = try excludedInstanceTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedInstanceTypesBuffer:[Swift.String]? = nil
                if let excludedInstanceTypesContainer = excludedInstanceTypesContainer {
                    excludedInstanceTypesBuffer = [Swift.String]()
                    for stringContainer0 in excludedInstanceTypesContainer {
                        excludedInstanceTypesBuffer?.append(stringContainer0)
                    }
                }
                excludedInstanceTypes = excludedInstanceTypesBuffer
            } else {
                excludedInstanceTypes = []
            }
        } else {
            excludedInstanceTypes = nil
        }
        if containerValues.contains(.instanceGenerations) {
            struct KeyVal0{struct member{}}
            let instanceGenerationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instanceGenerations)
            if let instanceGenerationsWrappedContainer = instanceGenerationsWrappedContainer {
                let instanceGenerationsContainer = try instanceGenerationsWrappedContainer.decodeIfPresent([AutoScalingClientTypes.InstanceGeneration].self, forKey: .member)
                var instanceGenerationsBuffer:[AutoScalingClientTypes.InstanceGeneration]? = nil
                if let instanceGenerationsContainer = instanceGenerationsContainer {
                    instanceGenerationsBuffer = [AutoScalingClientTypes.InstanceGeneration]()
                    for stringContainer0 in instanceGenerationsContainer {
                        instanceGenerationsBuffer?.append(stringContainer0)
                    }
                }
                instanceGenerations = instanceGenerationsBuffer
            } else {
                instanceGenerations = []
            }
        } else {
            instanceGenerations = nil
        }
        let spotMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spotMaxPricePercentageOverLowestPrice)
        spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPriceDecoded
        let onDemandMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandMaxPricePercentageOverLowestPrice)
        onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPriceDecoded
        let bareMetalDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.BareMetal.self, forKey: .bareMetal)
        bareMetal = bareMetalDecoded
        let burstablePerformanceDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.BurstablePerformance.self, forKey: .burstablePerformance)
        burstablePerformance = burstablePerformanceDecoded
        let requireHibernateSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireHibernateSupport)
        requireHibernateSupport = requireHibernateSupportDecoded
        let networkInterfaceCountDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.NetworkInterfaceCountRequest.self, forKey: .networkInterfaceCount)
        networkInterfaceCount = networkInterfaceCountDecoded
        let localStorageDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.LocalStorage.self, forKey: .localStorage)
        localStorage = localStorageDecoded
        if containerValues.contains(.localStorageTypes) {
            struct KeyVal0{struct member{}}
            let localStorageTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .localStorageTypes)
            if let localStorageTypesWrappedContainer = localStorageTypesWrappedContainer {
                let localStorageTypesContainer = try localStorageTypesWrappedContainer.decodeIfPresent([AutoScalingClientTypes.LocalStorageType].self, forKey: .member)
                var localStorageTypesBuffer:[AutoScalingClientTypes.LocalStorageType]? = nil
                if let localStorageTypesContainer = localStorageTypesContainer {
                    localStorageTypesBuffer = [AutoScalingClientTypes.LocalStorageType]()
                    for stringContainer0 in localStorageTypesContainer {
                        localStorageTypesBuffer?.append(stringContainer0)
                    }
                }
                localStorageTypes = localStorageTypesBuffer
            } else {
                localStorageTypes = []
            }
        } else {
            localStorageTypes = nil
        }
        let totalLocalStorageGBDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.TotalLocalStorageGBRequest.self, forKey: .totalLocalStorageGB)
        totalLocalStorageGB = totalLocalStorageGBDecoded
        let baselineEbsBandwidthMbpsDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.BaselineEbsBandwidthMbpsRequest.self, forKey: .baselineEbsBandwidthMbps)
        baselineEbsBandwidthMbps = baselineEbsBandwidthMbpsDecoded
        if containerValues.contains(.acceleratorTypes) {
            struct KeyVal0{struct member{}}
            let acceleratorTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .acceleratorTypes)
            if let acceleratorTypesWrappedContainer = acceleratorTypesWrappedContainer {
                let acceleratorTypesContainer = try acceleratorTypesWrappedContainer.decodeIfPresent([AutoScalingClientTypes.AcceleratorType].self, forKey: .member)
                var acceleratorTypesBuffer:[AutoScalingClientTypes.AcceleratorType]? = nil
                if let acceleratorTypesContainer = acceleratorTypesContainer {
                    acceleratorTypesBuffer = [AutoScalingClientTypes.AcceleratorType]()
                    for stringContainer0 in acceleratorTypesContainer {
                        acceleratorTypesBuffer?.append(stringContainer0)
                    }
                }
                acceleratorTypes = acceleratorTypesBuffer
            } else {
                acceleratorTypes = []
            }
        } else {
            acceleratorTypes = nil
        }
        let acceleratorCountDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.AcceleratorCountRequest.self, forKey: .acceleratorCount)
        acceleratorCount = acceleratorCountDecoded
        if containerValues.contains(.acceleratorManufacturers) {
            struct KeyVal0{struct member{}}
            let acceleratorManufacturersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .acceleratorManufacturers)
            if let acceleratorManufacturersWrappedContainer = acceleratorManufacturersWrappedContainer {
                let acceleratorManufacturersContainer = try acceleratorManufacturersWrappedContainer.decodeIfPresent([AutoScalingClientTypes.AcceleratorManufacturer].self, forKey: .member)
                var acceleratorManufacturersBuffer:[AutoScalingClientTypes.AcceleratorManufacturer]? = nil
                if let acceleratorManufacturersContainer = acceleratorManufacturersContainer {
                    acceleratorManufacturersBuffer = [AutoScalingClientTypes.AcceleratorManufacturer]()
                    for stringContainer0 in acceleratorManufacturersContainer {
                        acceleratorManufacturersBuffer?.append(stringContainer0)
                    }
                }
                acceleratorManufacturers = acceleratorManufacturersBuffer
            } else {
                acceleratorManufacturers = []
            }
        } else {
            acceleratorManufacturers = nil
        }
        if containerValues.contains(.acceleratorNames) {
            struct KeyVal0{struct member{}}
            let acceleratorNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .acceleratorNames)
            if let acceleratorNamesWrappedContainer = acceleratorNamesWrappedContainer {
                let acceleratorNamesContainer = try acceleratorNamesWrappedContainer.decodeIfPresent([AutoScalingClientTypes.AcceleratorName].self, forKey: .member)
                var acceleratorNamesBuffer:[AutoScalingClientTypes.AcceleratorName]? = nil
                if let acceleratorNamesContainer = acceleratorNamesContainer {
                    acceleratorNamesBuffer = [AutoScalingClientTypes.AcceleratorName]()
                    for stringContainer0 in acceleratorNamesContainer {
                        acceleratorNamesBuffer?.append(stringContainer0)
                    }
                }
                acceleratorNames = acceleratorNamesBuffer
            } else {
                acceleratorNames = []
            }
        } else {
            acceleratorNames = nil
        }
        let acceleratorTotalMemoryMiBDecoded = try containerValues.decodeIfPresent(AutoScalingClientTypes.AcceleratorTotalMemoryMiBRequest.self, forKey: .acceleratorTotalMemoryMiB)
        acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiBDecoded
    }
}
