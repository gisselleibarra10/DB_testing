// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateCustomDBEngineVersionOutputResponseBody: Swift.Equatable {
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let dBParameterGroupFamily: Swift.String?
    let dBEngineDescription: Swift.String?
    let dBEngineVersionDescription: Swift.String?
    let defaultCharacterSet: RdsClientTypes.CharacterSet?
    let supportedCharacterSets: [RdsClientTypes.CharacterSet]?
    let supportedNcharCharacterSets: [RdsClientTypes.CharacterSet]?
    let validUpgradeTarget: [RdsClientTypes.UpgradeTarget]?
    let supportedTimezones: [RdsClientTypes.Timezone]?
    let exportableLogTypes: [Swift.String]?
    let supportsLogExportsToCloudwatchLogs: Swift.Bool
    let supportsReadReplica: Swift.Bool
    let supportedEngineModes: [Swift.String]?
    let supportedFeatureNames: [Swift.String]?
    let status: Swift.String?
    let supportsParallelQuery: Swift.Bool
    let supportsGlobalDatabases: Swift.Bool
    let majorEngineVersion: Swift.String?
    let databaseInstallationFilesS3BucketName: Swift.String?
    let databaseInstallationFilesS3Prefix: Swift.String?
    let dBEngineVersionArn: Swift.String?
    let kMSKeyId: Swift.String?
    let createTime: ClientRuntime.Date?
    let tagList: [RdsClientTypes.Tag]?
    let supportsBabelfish: Swift.Bool
}

extension CreateCustomDBEngineVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsBabelfish = "SupportsBabelfish"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("CreateCustomDBEngineVersionResult"))
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let supportsBabelfishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsBabelfish)
        supportsBabelfish = supportsBabelfishDecoded
    }
}
