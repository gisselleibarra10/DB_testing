// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RdsClientTypes.OrderableDBInstanceOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneGroup = "AvailabilityZoneGroup"
        case availabilityZones = "AvailabilityZones"
        case availableProcessorFeatures = "AvailableProcessorFeatures"
        case dBInstanceClass = "DBInstanceClass"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case licenseModel = "LicenseModel"
        case maxIopsPerDbInstance = "MaxIopsPerDbInstance"
        case maxIopsPerGib = "MaxIopsPerGib"
        case maxStorageSize = "MaxStorageSize"
        case minIopsPerDbInstance = "MinIopsPerDbInstance"
        case minIopsPerGib = "MinIopsPerGib"
        case minStorageSize = "MinStorageSize"
        case multiAZCapable = "MultiAZCapable"
        case outpostCapable = "OutpostCapable"
        case readReplicaCapable = "ReadReplicaCapable"
        case storageType = "StorageType"
        case supportedActivityStreamModes = "SupportedActivityStreamModes"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedNetworkTypes = "SupportedNetworkTypes"
        case supportsClusters = "SupportsClusters"
        case supportsEnhancedMonitoring = "SupportsEnhancedMonitoring"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsIAMDatabaseAuthentication = "SupportsIAMDatabaseAuthentication"
        case supportsIops = "SupportsIops"
        case supportsKerberosAuthentication = "SupportsKerberosAuthentication"
        case supportsPerformanceInsights = "SupportsPerformanceInsights"
        case supportsStorageAutoscaling = "SupportsStorageAutoscaling"
        case supportsStorageEncryption = "SupportsStorageEncryption"
        case vpc = "Vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZoneGroup = availabilityZoneGroup {
            try container.encode(availabilityZoneGroup, forKey: ClientRuntime.Key("AvailabilityZoneGroup"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let availableProcessorFeatures = availableProcessorFeatures {
            var availableProcessorFeaturesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailableProcessorFeatures"))
            for (index0, availableprocessorfeature0) in availableProcessorFeatures.enumerated() {
                try availableProcessorFeaturesContainer.encode(availableprocessorfeature0, forKey: ClientRuntime.Key("AvailableProcessorFeature.\(index0.advanced(by: 1))"))
            }
        }
        if let dBInstanceClass = dBInstanceClass {
            try container.encode(dBInstanceClass, forKey: ClientRuntime.Key("DBInstanceClass"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let licenseModel = licenseModel {
            try container.encode(licenseModel, forKey: ClientRuntime.Key("LicenseModel"))
        }
        if let maxIopsPerDbInstance = maxIopsPerDbInstance {
            try container.encode(maxIopsPerDbInstance, forKey: ClientRuntime.Key("MaxIopsPerDbInstance"))
        }
        if let maxIopsPerGib = maxIopsPerGib {
            try container.encode(maxIopsPerGib, forKey: ClientRuntime.Key("MaxIopsPerGib"))
        }
        if let maxStorageSize = maxStorageSize {
            try container.encode(maxStorageSize, forKey: ClientRuntime.Key("MaxStorageSize"))
        }
        if let minIopsPerDbInstance = minIopsPerDbInstance {
            try container.encode(minIopsPerDbInstance, forKey: ClientRuntime.Key("MinIopsPerDbInstance"))
        }
        if let minIopsPerGib = minIopsPerGib {
            try container.encode(minIopsPerGib, forKey: ClientRuntime.Key("MinIopsPerGib"))
        }
        if let minStorageSize = minStorageSize {
            try container.encode(minStorageSize, forKey: ClientRuntime.Key("MinStorageSize"))
        }
        if multiAZCapable != false {
            try container.encode(multiAZCapable, forKey: ClientRuntime.Key("MultiAZCapable"))
        }
        if outpostCapable != false {
            try container.encode(outpostCapable, forKey: ClientRuntime.Key("OutpostCapable"))
        }
        if readReplicaCapable != false {
            try container.encode(readReplicaCapable, forKey: ClientRuntime.Key("ReadReplicaCapable"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let supportedActivityStreamModes = supportedActivityStreamModes {
            var supportedActivityStreamModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedActivityStreamModes"))
            for (index0, string0) in supportedActivityStreamModes.enumerated() {
                try supportedActivityStreamModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedNetworkTypes = supportedNetworkTypes {
            var supportedNetworkTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedNetworkTypes"))
            for (index0, string0) in supportedNetworkTypes.enumerated() {
                try supportedNetworkTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if supportsClusters != false {
            try container.encode(supportsClusters, forKey: ClientRuntime.Key("SupportsClusters"))
        }
        if supportsEnhancedMonitoring != false {
            try container.encode(supportsEnhancedMonitoring, forKey: ClientRuntime.Key("SupportsEnhancedMonitoring"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsIAMDatabaseAuthentication != false {
            try container.encode(supportsIAMDatabaseAuthentication, forKey: ClientRuntime.Key("SupportsIAMDatabaseAuthentication"))
        }
        if supportsIops != false {
            try container.encode(supportsIops, forKey: ClientRuntime.Key("SupportsIops"))
        }
        if let supportsKerberosAuthentication = supportsKerberosAuthentication {
            try container.encode(supportsKerberosAuthentication, forKey: ClientRuntime.Key("SupportsKerberosAuthentication"))
        }
        if supportsPerformanceInsights != false {
            try container.encode(supportsPerformanceInsights, forKey: ClientRuntime.Key("SupportsPerformanceInsights"))
        }
        if let supportsStorageAutoscaling = supportsStorageAutoscaling {
            try container.encode(supportsStorageAutoscaling, forKey: ClientRuntime.Key("SupportsStorageAutoscaling"))
        }
        if supportsStorageEncryption != false {
            try container.encode(supportsStorageEncryption, forKey: ClientRuntime.Key("SupportsStorageEncryption"))
        }
        if vpc != false {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBInstanceClass)
        dBInstanceClass = dBInstanceClassDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let availabilityZoneGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneGroup)
        availabilityZoneGroup = availabilityZoneGroupDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[RdsClientTypes.AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [RdsClientTypes.AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let multiAZCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .multiAZCapable)
        multiAZCapable = multiAZCapableDecoded
        let readReplicaCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .readReplicaCapable)
        readReplicaCapable = readReplicaCapableDecoded
        let vpcDecoded = try containerValues.decode(Swift.Bool.self, forKey: .vpc)
        vpc = vpcDecoded
        let supportsStorageEncryptionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsStorageEncryption)
        supportsStorageEncryption = supportsStorageEncryptionDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportsIopsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIops)
        supportsIops = supportsIopsDecoded
        let supportsEnhancedMonitoringDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsEnhancedMonitoring)
        supportsEnhancedMonitoring = supportsEnhancedMonitoringDecoded
        let supportsIAMDatabaseAuthenticationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsIAMDatabaseAuthentication)
        supportsIAMDatabaseAuthentication = supportsIAMDatabaseAuthenticationDecoded
        let supportsPerformanceInsightsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsPerformanceInsights)
        supportsPerformanceInsights = supportsPerformanceInsightsDecoded
        let minStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minStorageSize)
        minStorageSize = minStorageSizeDecoded
        let maxStorageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStorageSize)
        maxStorageSize = maxStorageSizeDecoded
        let minIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minIopsPerDbInstance)
        minIopsPerDbInstance = minIopsPerDbInstanceDecoded
        let maxIopsPerDbInstanceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxIopsPerDbInstance)
        maxIopsPerDbInstance = maxIopsPerDbInstanceDecoded
        let minIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minIopsPerGib)
        minIopsPerGib = minIopsPerGibDecoded
        let maxIopsPerGibDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxIopsPerGib)
        maxIopsPerGib = maxIopsPerGibDecoded
        if containerValues.contains(.availableProcessorFeatures) {
            struct KeyVal0{struct AvailableProcessorFeature{}}
            let availableProcessorFeaturesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailableProcessorFeature>.CodingKeys.self, forKey: .availableProcessorFeatures)
            if let availableProcessorFeaturesWrappedContainer = availableProcessorFeaturesWrappedContainer {
                let availableProcessorFeaturesContainer = try availableProcessorFeaturesWrappedContainer.decodeIfPresent([RdsClientTypes.AvailableProcessorFeature].self, forKey: .member)
                var availableProcessorFeaturesBuffer:[RdsClientTypes.AvailableProcessorFeature]? = nil
                if let availableProcessorFeaturesContainer = availableProcessorFeaturesContainer {
                    availableProcessorFeaturesBuffer = [RdsClientTypes.AvailableProcessorFeature]()
                    for structureContainer0 in availableProcessorFeaturesContainer {
                        availableProcessorFeaturesBuffer?.append(structureContainer0)
                    }
                }
                availableProcessorFeatures = availableProcessorFeaturesBuffer
            } else {
                availableProcessorFeatures = []
            }
        } else {
            availableProcessorFeatures = nil
        }
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        let supportsStorageAutoscalingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsStorageAutoscaling)
        supportsStorageAutoscaling = supportsStorageAutoscalingDecoded
        let supportsKerberosAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsKerberosAuthentication)
        supportsKerberosAuthentication = supportsKerberosAuthenticationDecoded
        let outpostCapableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .outpostCapable)
        outpostCapable = outpostCapableDecoded
        if containerValues.contains(.supportedActivityStreamModes) {
            struct KeyVal0{struct member{}}
            let supportedActivityStreamModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedActivityStreamModes)
            if let supportedActivityStreamModesWrappedContainer = supportedActivityStreamModesWrappedContainer {
                let supportedActivityStreamModesContainer = try supportedActivityStreamModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedActivityStreamModesBuffer:[Swift.String]? = nil
                if let supportedActivityStreamModesContainer = supportedActivityStreamModesContainer {
                    supportedActivityStreamModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedActivityStreamModesContainer {
                        supportedActivityStreamModesBuffer?.append(stringContainer0)
                    }
                }
                supportedActivityStreamModes = supportedActivityStreamModesBuffer
            } else {
                supportedActivityStreamModes = []
            }
        } else {
            supportedActivityStreamModes = nil
        }
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let supportsClustersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsClusters)
        supportsClusters = supportsClustersDecoded
        if containerValues.contains(.supportedNetworkTypes) {
            struct KeyVal0{struct member{}}
            let supportedNetworkTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedNetworkTypes)
            if let supportedNetworkTypesWrappedContainer = supportedNetworkTypesWrappedContainer {
                let supportedNetworkTypesContainer = try supportedNetworkTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedNetworkTypesBuffer:[Swift.String]? = nil
                if let supportedNetworkTypesContainer = supportedNetworkTypesContainer {
                    supportedNetworkTypesBuffer = [Swift.String]()
                    for stringContainer0 in supportedNetworkTypesContainer {
                        supportedNetworkTypesBuffer?.append(stringContainer0)
                    }
                }
                supportedNetworkTypes = supportedNetworkTypesBuffer
            } else {
                supportedNetworkTypes = []
            }
        } else {
            supportedNetworkTypes = nil
        }
    }
}
