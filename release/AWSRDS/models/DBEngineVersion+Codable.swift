// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RdsClientTypes.DBEngineVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case dBEngineDescription = "DBEngineDescription"
        case dBEngineVersionArn = "DBEngineVersionArn"
        case dBEngineVersionDescription = "DBEngineVersionDescription"
        case dBParameterGroupFamily = "DBParameterGroupFamily"
        case databaseInstallationFilesS3BucketName = "DatabaseInstallationFilesS3BucketName"
        case databaseInstallationFilesS3Prefix = "DatabaseInstallationFilesS3Prefix"
        case defaultCharacterSet = "DefaultCharacterSet"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case exportableLogTypes = "ExportableLogTypes"
        case kMSKeyId = "KMSKeyId"
        case majorEngineVersion = "MajorEngineVersion"
        case status = "Status"
        case supportedCharacterSets = "SupportedCharacterSets"
        case supportedEngineModes = "SupportedEngineModes"
        case supportedFeatureNames = "SupportedFeatureNames"
        case supportedNcharCharacterSets = "SupportedNcharCharacterSets"
        case supportedTimezones = "SupportedTimezones"
        case supportsBabelfish = "SupportsBabelfish"
        case supportsGlobalDatabases = "SupportsGlobalDatabases"
        case supportsLogExportsToCloudwatchLogs = "SupportsLogExportsToCloudwatchLogs"
        case supportsParallelQuery = "SupportsParallelQuery"
        case supportsReadReplica = "SupportsReadReplica"
        case tagList = "TagList"
        case validUpgradeTarget = "ValidUpgradeTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createTime = createTime {
            try container.encode(ClientRuntime.TimestampWrapper(createTime, format: .dateTime), forKey: ClientRuntime.Key("createTime"))
        }
        if let dBEngineDescription = dBEngineDescription {
            try container.encode(dBEngineDescription, forKey: ClientRuntime.Key("DBEngineDescription"))
        }
        if let dBEngineVersionArn = dBEngineVersionArn {
            try container.encode(dBEngineVersionArn, forKey: ClientRuntime.Key("DBEngineVersionArn"))
        }
        if let dBEngineVersionDescription = dBEngineVersionDescription {
            try container.encode(dBEngineVersionDescription, forKey: ClientRuntime.Key("DBEngineVersionDescription"))
        }
        if let dBParameterGroupFamily = dBParameterGroupFamily {
            try container.encode(dBParameterGroupFamily, forKey: ClientRuntime.Key("DBParameterGroupFamily"))
        }
        if let databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketName {
            try container.encode(databaseInstallationFilesS3BucketName, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3BucketName"))
        }
        if let databaseInstallationFilesS3Prefix = databaseInstallationFilesS3Prefix {
            try container.encode(databaseInstallationFilesS3Prefix, forKey: ClientRuntime.Key("DatabaseInstallationFilesS3Prefix"))
        }
        if let defaultCharacterSet = defaultCharacterSet {
            try container.encode(defaultCharacterSet, forKey: ClientRuntime.Key("DefaultCharacterSet"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let exportableLogTypes = exportableLogTypes {
            var exportableLogTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExportableLogTypes"))
            for (index0, string0) in exportableLogTypes.enumerated() {
                try exportableLogTypesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let kMSKeyId = kMSKeyId {
            try container.encode(kMSKeyId, forKey: ClientRuntime.Key("KMSKeyId"))
        }
        if let majorEngineVersion = majorEngineVersion {
            try container.encode(majorEngineVersion, forKey: ClientRuntime.Key("MajorEngineVersion"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let supportedCharacterSets = supportedCharacterSets {
            var supportedCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedCharacterSets"))
            for (index0, characterset0) in supportedCharacterSets.enumerated() {
                try supportedCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedEngineModes = supportedEngineModes {
            var supportedEngineModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedEngineModes"))
            for (index0, string0) in supportedEngineModes.enumerated() {
                try supportedEngineModesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedFeatureNames = supportedFeatureNames {
            var supportedFeatureNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedFeatureNames"))
            for (index0, string0) in supportedFeatureNames.enumerated() {
                try supportedFeatureNamesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedNcharCharacterSets = supportedNcharCharacterSets {
            var supportedNcharCharacterSetsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedNcharCharacterSets"))
            for (index0, characterset0) in supportedNcharCharacterSets.enumerated() {
                try supportedNcharCharacterSetsContainer.encode(characterset0, forKey: ClientRuntime.Key("CharacterSet.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedTimezones = supportedTimezones {
            var supportedTimezonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedTimezones"))
            for (index0, timezone0) in supportedTimezones.enumerated() {
                try supportedTimezonesContainer.encode(timezone0, forKey: ClientRuntime.Key("Timezone.\(index0.advanced(by: 1))"))
            }
        }
        if supportsBabelfish != false {
            try container.encode(supportsBabelfish, forKey: ClientRuntime.Key("SupportsBabelfish"))
        }
        if supportsGlobalDatabases != false {
            try container.encode(supportsGlobalDatabases, forKey: ClientRuntime.Key("SupportsGlobalDatabases"))
        }
        if supportsLogExportsToCloudwatchLogs != false {
            try container.encode(supportsLogExportsToCloudwatchLogs, forKey: ClientRuntime.Key("SupportsLogExportsToCloudwatchLogs"))
        }
        if supportsParallelQuery != false {
            try container.encode(supportsParallelQuery, forKey: ClientRuntime.Key("SupportsParallelQuery"))
        }
        if supportsReadReplica != false {
            try container.encode(supportsReadReplica, forKey: ClientRuntime.Key("SupportsReadReplica"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let validUpgradeTarget = validUpgradeTarget {
            var validUpgradeTargetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ValidUpgradeTarget"))
            for (index0, upgradetarget0) in validUpgradeTarget.enumerated() {
                try validUpgradeTargetContainer.encode(upgradetarget0, forKey: ClientRuntime.Key("UpgradeTarget.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dBParameterGroupFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBParameterGroupFamily)
        dBParameterGroupFamily = dBParameterGroupFamilyDecoded
        let dBEngineDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineDescription)
        dBEngineDescription = dBEngineDescriptionDecoded
        let dBEngineVersionDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionDescription)
        dBEngineVersionDescription = dBEngineVersionDescriptionDecoded
        let defaultCharacterSetDecoded = try containerValues.decodeIfPresent(RdsClientTypes.CharacterSet.self, forKey: .defaultCharacterSet)
        defaultCharacterSet = defaultCharacterSetDecoded
        if containerValues.contains(.supportedCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedCharacterSets)
            if let supportedCharacterSetsWrappedContainer = supportedCharacterSetsWrappedContainer {
                let supportedCharacterSetsContainer = try supportedCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedCharacterSetsContainer = supportedCharacterSetsContainer {
                    supportedCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedCharacterSetsContainer {
                        supportedCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedCharacterSets = supportedCharacterSetsBuffer
            } else {
                supportedCharacterSets = []
            }
        } else {
            supportedCharacterSets = nil
        }
        if containerValues.contains(.supportedNcharCharacterSets) {
            struct KeyVal0{struct CharacterSet{}}
            let supportedNcharCharacterSetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CharacterSet>.CodingKeys.self, forKey: .supportedNcharCharacterSets)
            if let supportedNcharCharacterSetsWrappedContainer = supportedNcharCharacterSetsWrappedContainer {
                let supportedNcharCharacterSetsContainer = try supportedNcharCharacterSetsWrappedContainer.decodeIfPresent([RdsClientTypes.CharacterSet].self, forKey: .member)
                var supportedNcharCharacterSetsBuffer:[RdsClientTypes.CharacterSet]? = nil
                if let supportedNcharCharacterSetsContainer = supportedNcharCharacterSetsContainer {
                    supportedNcharCharacterSetsBuffer = [RdsClientTypes.CharacterSet]()
                    for structureContainer0 in supportedNcharCharacterSetsContainer {
                        supportedNcharCharacterSetsBuffer?.append(structureContainer0)
                    }
                }
                supportedNcharCharacterSets = supportedNcharCharacterSetsBuffer
            } else {
                supportedNcharCharacterSets = []
            }
        } else {
            supportedNcharCharacterSets = nil
        }
        if containerValues.contains(.validUpgradeTarget) {
            struct KeyVal0{struct UpgradeTarget{}}
            let validUpgradeTargetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.UpgradeTarget>.CodingKeys.self, forKey: .validUpgradeTarget)
            if let validUpgradeTargetWrappedContainer = validUpgradeTargetWrappedContainer {
                let validUpgradeTargetContainer = try validUpgradeTargetWrappedContainer.decodeIfPresent([RdsClientTypes.UpgradeTarget].self, forKey: .member)
                var validUpgradeTargetBuffer:[RdsClientTypes.UpgradeTarget]? = nil
                if let validUpgradeTargetContainer = validUpgradeTargetContainer {
                    validUpgradeTargetBuffer = [RdsClientTypes.UpgradeTarget]()
                    for structureContainer0 in validUpgradeTargetContainer {
                        validUpgradeTargetBuffer?.append(structureContainer0)
                    }
                }
                validUpgradeTarget = validUpgradeTargetBuffer
            } else {
                validUpgradeTarget = []
            }
        } else {
            validUpgradeTarget = nil
        }
        if containerValues.contains(.supportedTimezones) {
            struct KeyVal0{struct Timezone{}}
            let supportedTimezonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Timezone>.CodingKeys.self, forKey: .supportedTimezones)
            if let supportedTimezonesWrappedContainer = supportedTimezonesWrappedContainer {
                let supportedTimezonesContainer = try supportedTimezonesWrappedContainer.decodeIfPresent([RdsClientTypes.Timezone].self, forKey: .member)
                var supportedTimezonesBuffer:[RdsClientTypes.Timezone]? = nil
                if let supportedTimezonesContainer = supportedTimezonesContainer {
                    supportedTimezonesBuffer = [RdsClientTypes.Timezone]()
                    for structureContainer0 in supportedTimezonesContainer {
                        supportedTimezonesBuffer?.append(structureContainer0)
                    }
                }
                supportedTimezones = supportedTimezonesBuffer
            } else {
                supportedTimezones = []
            }
        } else {
            supportedTimezones = nil
        }
        if containerValues.contains(.exportableLogTypes) {
            struct KeyVal0{struct member{}}
            let exportableLogTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .exportableLogTypes)
            if let exportableLogTypesWrappedContainer = exportableLogTypesWrappedContainer {
                let exportableLogTypesContainer = try exportableLogTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var exportableLogTypesBuffer:[Swift.String]? = nil
                if let exportableLogTypesContainer = exportableLogTypesContainer {
                    exportableLogTypesBuffer = [Swift.String]()
                    for stringContainer0 in exportableLogTypesContainer {
                        exportableLogTypesBuffer?.append(stringContainer0)
                    }
                }
                exportableLogTypes = exportableLogTypesBuffer
            } else {
                exportableLogTypes = []
            }
        } else {
            exportableLogTypes = nil
        }
        let supportsLogExportsToCloudwatchLogsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLogExportsToCloudwatchLogs)
        supportsLogExportsToCloudwatchLogs = supportsLogExportsToCloudwatchLogsDecoded
        let supportsReadReplicaDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsReadReplica)
        supportsReadReplica = supportsReadReplicaDecoded
        if containerValues.contains(.supportedEngineModes) {
            struct KeyVal0{struct member{}}
            let supportedEngineModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedEngineModes)
            if let supportedEngineModesWrappedContainer = supportedEngineModesWrappedContainer {
                let supportedEngineModesContainer = try supportedEngineModesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedEngineModesBuffer:[Swift.String]? = nil
                if let supportedEngineModesContainer = supportedEngineModesContainer {
                    supportedEngineModesBuffer = [Swift.String]()
                    for stringContainer0 in supportedEngineModesContainer {
                        supportedEngineModesBuffer?.append(stringContainer0)
                    }
                }
                supportedEngineModes = supportedEngineModesBuffer
            } else {
                supportedEngineModes = []
            }
        } else {
            supportedEngineModes = nil
        }
        if containerValues.contains(.supportedFeatureNames) {
            struct KeyVal0{struct member{}}
            let supportedFeatureNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedFeatureNames)
            if let supportedFeatureNamesWrappedContainer = supportedFeatureNamesWrappedContainer {
                let supportedFeatureNamesContainer = try supportedFeatureNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedFeatureNamesBuffer:[Swift.String]? = nil
                if let supportedFeatureNamesContainer = supportedFeatureNamesContainer {
                    supportedFeatureNamesBuffer = [Swift.String]()
                    for stringContainer0 in supportedFeatureNamesContainer {
                        supportedFeatureNamesBuffer?.append(stringContainer0)
                    }
                }
                supportedFeatureNames = supportedFeatureNamesBuffer
            } else {
                supportedFeatureNames = []
            }
        } else {
            supportedFeatureNames = nil
        }
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let supportsParallelQueryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsParallelQuery)
        supportsParallelQuery = supportsParallelQueryDecoded
        let supportsGlobalDatabasesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsGlobalDatabases)
        supportsGlobalDatabases = supportsGlobalDatabasesDecoded
        let majorEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorEngineVersion)
        majorEngineVersion = majorEngineVersionDecoded
        let databaseInstallationFilesS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3BucketName)
        databaseInstallationFilesS3BucketName = databaseInstallationFilesS3BucketNameDecoded
        let databaseInstallationFilesS3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseInstallationFilesS3Prefix)
        databaseInstallationFilesS3Prefix = databaseInstallationFilesS3PrefixDecoded
        let dBEngineVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBEngineVersionArn)
        dBEngineVersionArn = dBEngineVersionArnDecoded
        let kMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kMSKeyId)
        kMSKeyId = kMSKeyIdDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createTime)
        var createTimeBuffer:ClientRuntime.Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let supportsBabelfishDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsBabelfish)
        supportsBabelfish = supportsBabelfishDecoded
    }
}
