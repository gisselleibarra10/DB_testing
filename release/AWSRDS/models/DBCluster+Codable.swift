// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension RdsClientTypes.DBCluster: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activityStreamKinesisStreamName = "ActivityStreamKinesisStreamName"
        case activityStreamKmsKeyId = "ActivityStreamKmsKeyId"
        case activityStreamMode = "ActivityStreamMode"
        case activityStreamStatus = "ActivityStreamStatus"
        case allocatedStorage = "AllocatedStorage"
        case associatedRoles = "AssociatedRoles"
        case autoMinorVersionUpgrade = "AutoMinorVersionUpgrade"
        case automaticRestartTime = "AutomaticRestartTime"
        case availabilityZones = "AvailabilityZones"
        case backtrackConsumedChangeRecords = "BacktrackConsumedChangeRecords"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case capacity = "Capacity"
        case characterSetName = "CharacterSetName"
        case cloneGroupId = "CloneGroupId"
        case clusterCreateTime = "ClusterCreateTime"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case crossAccountClone = "CrossAccountClone"
        case customEndpoints = "CustomEndpoints"
        case dBClusterArn = "DBClusterArn"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterInstanceClass = "DBClusterInstanceClass"
        case dBClusterMembers = "DBClusterMembers"
        case dBClusterOptionGroupMemberships = "DBClusterOptionGroupMemberships"
        case dBClusterParameterGroup = "DBClusterParameterGroup"
        case dBSubnetGroup = "DBSubnetGroup"
        case databaseName = "DatabaseName"
        case dbClusterResourceId = "DbClusterResourceId"
        case deletionProtection = "DeletionProtection"
        case domainMemberships = "DomainMemberships"
        case earliestBacktrackTime = "EarliestBacktrackTime"
        case earliestRestorableTime = "EarliestRestorableTime"
        case enabledCloudwatchLogsExports = "EnabledCloudwatchLogsExports"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineMode = "EngineMode"
        case engineVersion = "EngineVersion"
        case globalWriteForwardingRequested = "GlobalWriteForwardingRequested"
        case globalWriteForwardingStatus = "GlobalWriteForwardingStatus"
        case hostedZoneId = "HostedZoneId"
        case httpEndpointEnabled = "HttpEndpointEnabled"
        case iAMDatabaseAuthenticationEnabled = "IAMDatabaseAuthenticationEnabled"
        case iops = "Iops"
        case kmsKeyId = "KmsKeyId"
        case latestRestorableTime = "LatestRestorableTime"
        case masterUsername = "MasterUsername"
        case monitoringInterval = "MonitoringInterval"
        case monitoringRoleArn = "MonitoringRoleArn"
        case multiAZ = "MultiAZ"
        case networkType = "NetworkType"
        case pendingModifiedValues = "PendingModifiedValues"
        case percentProgress = "PercentProgress"
        case performanceInsightsEnabled = "PerformanceInsightsEnabled"
        case performanceInsightsKMSKeyId = "PerformanceInsightsKMSKeyId"
        case performanceInsightsRetentionPeriod = "PerformanceInsightsRetentionPeriod"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case publiclyAccessible = "PubliclyAccessible"
        case readReplicaIdentifiers = "ReadReplicaIdentifiers"
        case readerEndpoint = "ReaderEndpoint"
        case replicationSourceIdentifier = "ReplicationSourceIdentifier"
        case scalingConfigurationInfo = "ScalingConfigurationInfo"
        case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
        case status = "Status"
        case storageEncrypted = "StorageEncrypted"
        case storageType = "StorageType"
        case tagList = "TagList"
        case vpcSecurityGroups = "VpcSecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let activityStreamKinesisStreamName = activityStreamKinesisStreamName {
            try container.encode(activityStreamKinesisStreamName, forKey: ClientRuntime.Key("ActivityStreamKinesisStreamName"))
        }
        if let activityStreamKmsKeyId = activityStreamKmsKeyId {
            try container.encode(activityStreamKmsKeyId, forKey: ClientRuntime.Key("ActivityStreamKmsKeyId"))
        }
        if let activityStreamMode = activityStreamMode {
            try container.encode(activityStreamMode, forKey: ClientRuntime.Key("ActivityStreamMode"))
        }
        if let activityStreamStatus = activityStreamStatus {
            try container.encode(activityStreamStatus, forKey: ClientRuntime.Key("ActivityStreamStatus"))
        }
        if let allocatedStorage = allocatedStorage {
            try container.encode(allocatedStorage, forKey: ClientRuntime.Key("AllocatedStorage"))
        }
        if let associatedRoles = associatedRoles {
            var associatedRolesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AssociatedRoles"))
            for (index0, dbclusterrole0) in associatedRoles.enumerated() {
                try associatedRolesContainer.encode(dbclusterrole0, forKey: ClientRuntime.Key("DBClusterRole.\(index0.advanced(by: 1))"))
            }
        }
        if autoMinorVersionUpgrade != false {
            try container.encode(autoMinorVersionUpgrade, forKey: ClientRuntime.Key("AutoMinorVersionUpgrade"))
        }
        if let automaticRestartTime = automaticRestartTime {
            try container.encode(ClientRuntime.TimestampWrapper(automaticRestartTime, format: .dateTime), forKey: ClientRuntime.Key("automaticRestartTime"))
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZones"))
            for (index0, string0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(string0, forKey: ClientRuntime.Key("AvailabilityZone.\(index0.advanced(by: 1))"))
            }
        }
        if let backtrackConsumedChangeRecords = backtrackConsumedChangeRecords {
            try container.encode(backtrackConsumedChangeRecords, forKey: ClientRuntime.Key("BacktrackConsumedChangeRecords"))
        }
        if let backtrackWindow = backtrackWindow {
            try container.encode(backtrackWindow, forKey: ClientRuntime.Key("BacktrackWindow"))
        }
        if let backupRetentionPeriod = backupRetentionPeriod {
            try container.encode(backupRetentionPeriod, forKey: ClientRuntime.Key("BackupRetentionPeriod"))
        }
        if let capacity = capacity {
            try container.encode(capacity, forKey: ClientRuntime.Key("Capacity"))
        }
        if let characterSetName = characterSetName {
            try container.encode(characterSetName, forKey: ClientRuntime.Key("CharacterSetName"))
        }
        if let cloneGroupId = cloneGroupId {
            try container.encode(cloneGroupId, forKey: ClientRuntime.Key("CloneGroupId"))
        }
        if let clusterCreateTime = clusterCreateTime {
            try container.encode(ClientRuntime.TimestampWrapper(clusterCreateTime, format: .dateTime), forKey: ClientRuntime.Key("clusterCreateTime"))
        }
        if let copyTagsToSnapshot = copyTagsToSnapshot {
            try container.encode(copyTagsToSnapshot, forKey: ClientRuntime.Key("CopyTagsToSnapshot"))
        }
        if let crossAccountClone = crossAccountClone {
            try container.encode(crossAccountClone, forKey: ClientRuntime.Key("CrossAccountClone"))
        }
        if let customEndpoints = customEndpoints {
            var customEndpointsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CustomEndpoints"))
            for (index0, string0) in customEndpoints.enumerated() {
                try customEndpointsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterArn = dBClusterArn {
            try container.encode(dBClusterArn, forKey: ClientRuntime.Key("DBClusterArn"))
        }
        if let dBClusterIdentifier = dBClusterIdentifier {
            try container.encode(dBClusterIdentifier, forKey: ClientRuntime.Key("DBClusterIdentifier"))
        }
        if let dBClusterInstanceClass = dBClusterInstanceClass {
            try container.encode(dBClusterInstanceClass, forKey: ClientRuntime.Key("DBClusterInstanceClass"))
        }
        if let dBClusterMembers = dBClusterMembers {
            var dBClusterMembersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterMembers"))
            for (index0, dbclustermember0) in dBClusterMembers.enumerated() {
                try dBClusterMembersContainer.encode(dbclustermember0, forKey: ClientRuntime.Key("DBClusterMember.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterOptionGroupMemberships = dBClusterOptionGroupMemberships {
            var dBClusterOptionGroupMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DBClusterOptionGroupMemberships"))
            for (index0, dbclusteroptiongroupstatus0) in dBClusterOptionGroupMemberships.enumerated() {
                try dBClusterOptionGroupMembershipsContainer.encode(dbclusteroptiongroupstatus0, forKey: ClientRuntime.Key("DBClusterOptionGroup.\(index0.advanced(by: 1))"))
            }
        }
        if let dBClusterParameterGroup = dBClusterParameterGroup {
            try container.encode(dBClusterParameterGroup, forKey: ClientRuntime.Key("DBClusterParameterGroup"))
        }
        if let dBSubnetGroup = dBSubnetGroup {
            try container.encode(dBSubnetGroup, forKey: ClientRuntime.Key("DBSubnetGroup"))
        }
        if let databaseName = databaseName {
            try container.encode(databaseName, forKey: ClientRuntime.Key("DatabaseName"))
        }
        if let dbClusterResourceId = dbClusterResourceId {
            try container.encode(dbClusterResourceId, forKey: ClientRuntime.Key("DbClusterResourceId"))
        }
        if let deletionProtection = deletionProtection {
            try container.encode(deletionProtection, forKey: ClientRuntime.Key("DeletionProtection"))
        }
        if let domainMemberships = domainMemberships {
            var domainMembershipsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DomainMemberships"))
            for (index0, domainmembership0) in domainMemberships.enumerated() {
                try domainMembershipsContainer.encode(domainmembership0, forKey: ClientRuntime.Key("DomainMembership.\(index0.advanced(by: 1))"))
            }
        }
        if let earliestBacktrackTime = earliestBacktrackTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestBacktrackTime, format: .dateTime), forKey: ClientRuntime.Key("earliestBacktrackTime"))
        }
        if let earliestRestorableTime = earliestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(earliestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("earliestRestorableTime"))
        }
        if let enabledCloudwatchLogsExports = enabledCloudwatchLogsExports {
            var enabledCloudwatchLogsExportsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("EnabledCloudwatchLogsExports"))
            for (index0, string0) in enabledCloudwatchLogsExports.enumerated() {
                try enabledCloudwatchLogsExportsContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let engine = engine {
            try container.encode(engine, forKey: ClientRuntime.Key("Engine"))
        }
        if let engineMode = engineMode {
            try container.encode(engineMode, forKey: ClientRuntime.Key("EngineMode"))
        }
        if let engineVersion = engineVersion {
            try container.encode(engineVersion, forKey: ClientRuntime.Key("EngineVersion"))
        }
        if let globalWriteForwardingRequested = globalWriteForwardingRequested {
            try container.encode(globalWriteForwardingRequested, forKey: ClientRuntime.Key("GlobalWriteForwardingRequested"))
        }
        if let globalWriteForwardingStatus = globalWriteForwardingStatus {
            try container.encode(globalWriteForwardingStatus, forKey: ClientRuntime.Key("GlobalWriteForwardingStatus"))
        }
        if let hostedZoneId = hostedZoneId {
            try container.encode(hostedZoneId, forKey: ClientRuntime.Key("HostedZoneId"))
        }
        if let httpEndpointEnabled = httpEndpointEnabled {
            try container.encode(httpEndpointEnabled, forKey: ClientRuntime.Key("HttpEndpointEnabled"))
        }
        if let iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabled {
            try container.encode(iAMDatabaseAuthenticationEnabled, forKey: ClientRuntime.Key("IAMDatabaseAuthenticationEnabled"))
        }
        if let iops = iops {
            try container.encode(iops, forKey: ClientRuntime.Key("Iops"))
        }
        if let kmsKeyId = kmsKeyId {
            try container.encode(kmsKeyId, forKey: ClientRuntime.Key("KmsKeyId"))
        }
        if let latestRestorableTime = latestRestorableTime {
            try container.encode(ClientRuntime.TimestampWrapper(latestRestorableTime, format: .dateTime), forKey: ClientRuntime.Key("latestRestorableTime"))
        }
        if let masterUsername = masterUsername {
            try container.encode(masterUsername, forKey: ClientRuntime.Key("MasterUsername"))
        }
        if let monitoringInterval = monitoringInterval {
            try container.encode(monitoringInterval, forKey: ClientRuntime.Key("MonitoringInterval"))
        }
        if let monitoringRoleArn = monitoringRoleArn {
            try container.encode(monitoringRoleArn, forKey: ClientRuntime.Key("MonitoringRoleArn"))
        }
        if let multiAZ = multiAZ {
            try container.encode(multiAZ, forKey: ClientRuntime.Key("MultiAZ"))
        }
        if let networkType = networkType {
            try container.encode(networkType, forKey: ClientRuntime.Key("NetworkType"))
        }
        if let pendingModifiedValues = pendingModifiedValues {
            try container.encode(pendingModifiedValues, forKey: ClientRuntime.Key("PendingModifiedValues"))
        }
        if let percentProgress = percentProgress {
            try container.encode(percentProgress, forKey: ClientRuntime.Key("PercentProgress"))
        }
        if let performanceInsightsEnabled = performanceInsightsEnabled {
            try container.encode(performanceInsightsEnabled, forKey: ClientRuntime.Key("PerformanceInsightsEnabled"))
        }
        if let performanceInsightsKMSKeyId = performanceInsightsKMSKeyId {
            try container.encode(performanceInsightsKMSKeyId, forKey: ClientRuntime.Key("PerformanceInsightsKMSKeyId"))
        }
        if let performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriod {
            try container.encode(performanceInsightsRetentionPeriod, forKey: ClientRuntime.Key("PerformanceInsightsRetentionPeriod"))
        }
        if let port = port {
            try container.encode(port, forKey: ClientRuntime.Key("Port"))
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try container.encode(preferredBackupWindow, forKey: ClientRuntime.Key("PreferredBackupWindow"))
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try container.encode(preferredMaintenanceWindow, forKey: ClientRuntime.Key("PreferredMaintenanceWindow"))
        }
        if let publiclyAccessible = publiclyAccessible {
            try container.encode(publiclyAccessible, forKey: ClientRuntime.Key("PubliclyAccessible"))
        }
        if let readReplicaIdentifiers = readReplicaIdentifiers {
            var readReplicaIdentifiersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ReadReplicaIdentifiers"))
            for (index0, string0) in readReplicaIdentifiers.enumerated() {
                try readReplicaIdentifiersContainer.encode(string0, forKey: ClientRuntime.Key("ReadReplicaIdentifier.\(index0.advanced(by: 1))"))
            }
        }
        if let readerEndpoint = readerEndpoint {
            try container.encode(readerEndpoint, forKey: ClientRuntime.Key("ReaderEndpoint"))
        }
        if let replicationSourceIdentifier = replicationSourceIdentifier {
            try container.encode(replicationSourceIdentifier, forKey: ClientRuntime.Key("ReplicationSourceIdentifier"))
        }
        if let scalingConfigurationInfo = scalingConfigurationInfo {
            try container.encode(scalingConfigurationInfo, forKey: ClientRuntime.Key("ScalingConfigurationInfo"))
        }
        if let serverlessV2ScalingConfiguration = serverlessV2ScalingConfiguration {
            try container.encode(serverlessV2ScalingConfiguration, forKey: ClientRuntime.Key("ServerlessV2ScalingConfiguration"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if storageEncrypted != false {
            try container.encode(storageEncrypted, forKey: ClientRuntime.Key("StorageEncrypted"))
        }
        if let storageType = storageType {
            try container.encode(storageType, forKey: ClientRuntime.Key("StorageType"))
        }
        if let tagList = tagList {
            var tagListContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagList"))
            for (index0, tag0) in tagList.enumerated() {
                try tagListContainer.encode(tag0, forKey: ClientRuntime.Key("Tag.\(index0.advanced(by: 1))"))
            }
        }
        if let vpcSecurityGroups = vpcSecurityGroups {
            var vpcSecurityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("VpcSecurityGroups"))
            for (index0, vpcsecuritygroupmembership0) in vpcSecurityGroups.enumerated() {
                try vpcSecurityGroupsContainer.encode(vpcsecuritygroupmembership0, forKey: ClientRuntime.Key("VpcSecurityGroupMembership.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocatedStorageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .allocatedStorage)
        allocatedStorage = allocatedStorageDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroup)
        dBClusterParameterGroup = dBClusterParameterGroupDecoded
        let dBSubnetGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroup)
        dBSubnetGroup = dBSubnetGroupDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let automaticRestartTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .automaticRestartTime)
        var automaticRestartTimeBuffer:ClientRuntime.Date? = nil
        if let automaticRestartTimeDecoded = automaticRestartTimeDecoded {
            automaticRestartTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(automaticRestartTimeDecoded, format: .dateTime)
        }
        automaticRestartTime = automaticRestartTimeBuffer
        let percentProgressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .percentProgress)
        percentProgress = percentProgressDecoded
        let earliestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestRestorableTime)
        var earliestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let earliestRestorableTimeDecoded = earliestRestorableTimeDecoded {
            earliestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestRestorableTimeDecoded, format: .dateTime)
        }
        earliestRestorableTime = earliestRestorableTimeBuffer
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let readerEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readerEndpoint)
        readerEndpoint = readerEndpointDecoded
        if containerValues.contains(.customEndpoints) {
            struct KeyVal0{struct member{}}
            let customEndpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .customEndpoints)
            if let customEndpointsWrappedContainer = customEndpointsWrappedContainer {
                let customEndpointsContainer = try customEndpointsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var customEndpointsBuffer:[Swift.String]? = nil
                if let customEndpointsContainer = customEndpointsContainer {
                    customEndpointsBuffer = [Swift.String]()
                    for stringContainer0 in customEndpointsContainer {
                        customEndpointsBuffer?.append(stringContainer0)
                    }
                }
                customEndpoints = customEndpointsBuffer
            } else {
                customEndpoints = []
            }
        } else {
            customEndpoints = nil
        }
        let multiAZDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .multiAZ)
        multiAZ = multiAZDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let latestRestorableTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestRestorableTime)
        var latestRestorableTimeBuffer:ClientRuntime.Date? = nil
        if let latestRestorableTimeDecoded = latestRestorableTimeDecoded {
            latestRestorableTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(latestRestorableTimeDecoded, format: .dateTime)
        }
        latestRestorableTime = latestRestorableTimeBuffer
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        if containerValues.contains(.dBClusterOptionGroupMemberships) {
            struct KeyVal0{struct DBClusterOptionGroup{}}
            let dBClusterOptionGroupMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterOptionGroup>.CodingKeys.self, forKey: .dBClusterOptionGroupMemberships)
            if let dBClusterOptionGroupMembershipsWrappedContainer = dBClusterOptionGroupMembershipsWrappedContainer {
                let dBClusterOptionGroupMembershipsContainer = try dBClusterOptionGroupMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterOptionGroupStatus].self, forKey: .member)
                var dBClusterOptionGroupMembershipsBuffer:[RdsClientTypes.DBClusterOptionGroupStatus]? = nil
                if let dBClusterOptionGroupMembershipsContainer = dBClusterOptionGroupMembershipsContainer {
                    dBClusterOptionGroupMembershipsBuffer = [RdsClientTypes.DBClusterOptionGroupStatus]()
                    for structureContainer0 in dBClusterOptionGroupMembershipsContainer {
                        dBClusterOptionGroupMembershipsBuffer?.append(structureContainer0)
                    }
                }
                dBClusterOptionGroupMemberships = dBClusterOptionGroupMembershipsBuffer
            } else {
                dBClusterOptionGroupMemberships = []
            }
        } else {
            dBClusterOptionGroupMemberships = nil
        }
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let replicationSourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationSourceIdentifier)
        replicationSourceIdentifier = replicationSourceIdentifierDecoded
        if containerValues.contains(.readReplicaIdentifiers) {
            struct KeyVal0{struct ReadReplicaIdentifier{}}
            let readReplicaIdentifiersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ReadReplicaIdentifier>.CodingKeys.self, forKey: .readReplicaIdentifiers)
            if let readReplicaIdentifiersWrappedContainer = readReplicaIdentifiersWrappedContainer {
                let readReplicaIdentifiersContainer = try readReplicaIdentifiersWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var readReplicaIdentifiersBuffer:[Swift.String]? = nil
                if let readReplicaIdentifiersContainer = readReplicaIdentifiersContainer {
                    readReplicaIdentifiersBuffer = [Swift.String]()
                    for stringContainer0 in readReplicaIdentifiersContainer {
                        readReplicaIdentifiersBuffer?.append(stringContainer0)
                    }
                }
                readReplicaIdentifiers = readReplicaIdentifiersBuffer
            } else {
                readReplicaIdentifiers = []
            }
        } else {
            readReplicaIdentifiers = nil
        }
        if containerValues.contains(.dBClusterMembers) {
            struct KeyVal0{struct DBClusterMember{}}
            let dBClusterMembersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterMember>.CodingKeys.self, forKey: .dBClusterMembers)
            if let dBClusterMembersWrappedContainer = dBClusterMembersWrappedContainer {
                let dBClusterMembersContainer = try dBClusterMembersWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterMember].self, forKey: .member)
                var dBClusterMembersBuffer:[RdsClientTypes.DBClusterMember]? = nil
                if let dBClusterMembersContainer = dBClusterMembersContainer {
                    dBClusterMembersBuffer = [RdsClientTypes.DBClusterMember]()
                    for structureContainer0 in dBClusterMembersContainer {
                        dBClusterMembersBuffer?.append(structureContainer0)
                    }
                }
                dBClusterMembers = dBClusterMembersBuffer
            } else {
                dBClusterMembers = []
            }
        } else {
            dBClusterMembers = nil
        }
        if containerValues.contains(.vpcSecurityGroups) {
            struct KeyVal0{struct VpcSecurityGroupMembership{}}
            let vpcSecurityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupMembership>.CodingKeys.self, forKey: .vpcSecurityGroups)
            if let vpcSecurityGroupsWrappedContainer = vpcSecurityGroupsWrappedContainer {
                let vpcSecurityGroupsContainer = try vpcSecurityGroupsWrappedContainer.decodeIfPresent([RdsClientTypes.VpcSecurityGroupMembership].self, forKey: .member)
                var vpcSecurityGroupsBuffer:[RdsClientTypes.VpcSecurityGroupMembership]? = nil
                if let vpcSecurityGroupsContainer = vpcSecurityGroupsContainer {
                    vpcSecurityGroupsBuffer = [RdsClientTypes.VpcSecurityGroupMembership]()
                    for structureContainer0 in vpcSecurityGroupsContainer {
                        vpcSecurityGroupsBuffer?.append(structureContainer0)
                    }
                }
                vpcSecurityGroups = vpcSecurityGroupsBuffer
            } else {
                vpcSecurityGroups = []
            }
        } else {
            vpcSecurityGroups = nil
        }
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
        let storageEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dbClusterResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterResourceId)
        dbClusterResourceId = dbClusterResourceIdDecoded
        let dBClusterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterArn)
        dBClusterArn = dBClusterArnDecoded
        if containerValues.contains(.associatedRoles) {
            struct KeyVal0{struct DBClusterRole{}}
            let associatedRolesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DBClusterRole>.CodingKeys.self, forKey: .associatedRoles)
            if let associatedRolesWrappedContainer = associatedRolesWrappedContainer {
                let associatedRolesContainer = try associatedRolesWrappedContainer.decodeIfPresent([RdsClientTypes.DBClusterRole].self, forKey: .member)
                var associatedRolesBuffer:[RdsClientTypes.DBClusterRole]? = nil
                if let associatedRolesContainer = associatedRolesContainer {
                    associatedRolesBuffer = [RdsClientTypes.DBClusterRole]()
                    for structureContainer0 in associatedRolesContainer {
                        associatedRolesBuffer?.append(structureContainer0)
                    }
                }
                associatedRoles = associatedRolesBuffer
            } else {
                associatedRoles = []
            }
        } else {
            associatedRoles = nil
        }
        let iAMDatabaseAuthenticationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .iAMDatabaseAuthenticationEnabled)
        iAMDatabaseAuthenticationEnabled = iAMDatabaseAuthenticationEnabledDecoded
        let cloneGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneGroupId)
        cloneGroupId = cloneGroupIdDecoded
        let clusterCreateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterCreateTime)
        var clusterCreateTimeBuffer:ClientRuntime.Date? = nil
        if let clusterCreateTimeDecoded = clusterCreateTimeDecoded {
            clusterCreateTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(clusterCreateTimeDecoded, format: .dateTime)
        }
        clusterCreateTime = clusterCreateTimeBuffer
        let earliestBacktrackTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .earliestBacktrackTime)
        var earliestBacktrackTimeBuffer:ClientRuntime.Date? = nil
        if let earliestBacktrackTimeDecoded = earliestBacktrackTimeDecoded {
            earliestBacktrackTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(earliestBacktrackTimeDecoded, format: .dateTime)
        }
        earliestBacktrackTime = earliestBacktrackTimeBuffer
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        let backtrackConsumedChangeRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackConsumedChangeRecords)
        backtrackConsumedChangeRecords = backtrackConsumedChangeRecordsDecoded
        if containerValues.contains(.enabledCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enabledCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enabledCloudwatchLogsExports)
            if let enabledCloudwatchLogsExportsWrappedContainer = enabledCloudwatchLogsExportsWrappedContainer {
                let enabledCloudwatchLogsExportsContainer = try enabledCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enabledCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enabledCloudwatchLogsExportsContainer = enabledCloudwatchLogsExportsContainer {
                    enabledCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enabledCloudwatchLogsExportsContainer {
                        enabledCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enabledCloudwatchLogsExports = enabledCloudwatchLogsExportsBuffer
            } else {
                enabledCloudwatchLogsExports = []
            }
        } else {
            enabledCloudwatchLogsExports = nil
        }
        let capacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let engineModeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineMode)
        engineMode = engineModeDecoded
        let scalingConfigurationInfoDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ScalingConfigurationInfo.self, forKey: .scalingConfigurationInfo)
        scalingConfigurationInfo = scalingConfigurationInfoDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let httpEndpointEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .httpEndpointEnabled)
        httpEndpointEnabled = httpEndpointEnabledDecoded
        let activityStreamModeDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamMode.self, forKey: .activityStreamMode)
        activityStreamMode = activityStreamModeDecoded
        let activityStreamStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ActivityStreamStatus.self, forKey: .activityStreamStatus)
        activityStreamStatus = activityStreamStatusDecoded
        let activityStreamKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKmsKeyId)
        activityStreamKmsKeyId = activityStreamKmsKeyIdDecoded
        let activityStreamKinesisStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activityStreamKinesisStreamName)
        activityStreamKinesisStreamName = activityStreamKinesisStreamNameDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let crossAccountCloneDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .crossAccountClone)
        crossAccountClone = crossAccountCloneDecoded
        if containerValues.contains(.domainMemberships) {
            struct KeyVal0{struct DomainMembership{}}
            let domainMembershipsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DomainMembership>.CodingKeys.self, forKey: .domainMemberships)
            if let domainMembershipsWrappedContainer = domainMembershipsWrappedContainer {
                let domainMembershipsContainer = try domainMembershipsWrappedContainer.decodeIfPresent([RdsClientTypes.DomainMembership].self, forKey: .member)
                var domainMembershipsBuffer:[RdsClientTypes.DomainMembership]? = nil
                if let domainMembershipsContainer = domainMembershipsContainer {
                    domainMembershipsBuffer = [RdsClientTypes.DomainMembership]()
                    for structureContainer0 in domainMembershipsContainer {
                        domainMembershipsBuffer?.append(structureContainer0)
                    }
                }
                domainMemberships = domainMembershipsBuffer
            } else {
                domainMemberships = []
            }
        } else {
            domainMemberships = nil
        }
        if containerValues.contains(.tagList) {
            struct KeyVal0{struct Tag{}}
            let tagListWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tagList)
            if let tagListWrappedContainer = tagListWrappedContainer {
                let tagListContainer = try tagListWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagListBuffer:[RdsClientTypes.Tag]? = nil
                if let tagListContainer = tagListContainer {
                    tagListBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagListContainer {
                        tagListBuffer?.append(structureContainer0)
                    }
                }
                tagList = tagListBuffer
            } else {
                tagList = []
            }
        } else {
            tagList = nil
        }
        let globalWriteForwardingStatusDecoded = try containerValues.decodeIfPresent(RdsClientTypes.WriteForwardingStatus.self, forKey: .globalWriteForwardingStatus)
        globalWriteForwardingStatus = globalWriteForwardingStatusDecoded
        let globalWriteForwardingRequestedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .globalWriteForwardingRequested)
        globalWriteForwardingRequested = globalWriteForwardingRequestedDecoded
        let pendingModifiedValuesDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ClusterPendingModifiedValues.self, forKey: .pendingModifiedValues)
        pendingModifiedValues = pendingModifiedValuesDecoded
        let dBClusterInstanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterInstanceClass)
        dBClusterInstanceClass = dBClusterInstanceClassDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let publiclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let monitoringIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringInterval)
        monitoringInterval = monitoringIntervalDecoded
        let monitoringRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitoringRoleArn)
        monitoringRoleArn = monitoringRoleArnDecoded
        let performanceInsightsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .performanceInsightsEnabled)
        performanceInsightsEnabled = performanceInsightsEnabledDecoded
        let performanceInsightsKMSKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .performanceInsightsKMSKeyId)
        performanceInsightsKMSKeyId = performanceInsightsKMSKeyIdDecoded
        let performanceInsightsRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .performanceInsightsRetentionPeriod)
        performanceInsightsRetentionPeriod = performanceInsightsRetentionPeriodDecoded
        let serverlessV2ScalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ServerlessV2ScalingConfigurationInfo.self, forKey: .serverlessV2ScalingConfiguration)
        serverlessV2ScalingConfiguration = serverlessV2ScalingConfigurationDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}
