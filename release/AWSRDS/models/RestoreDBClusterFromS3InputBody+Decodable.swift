// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct RestoreDBClusterFromS3InputBody: Swift.Equatable {
    let availabilityZones: [Swift.String]?
    let backupRetentionPeriod: Swift.Int?
    let characterSetName: Swift.String?
    let databaseName: Swift.String?
    let dBClusterIdentifier: Swift.String?
    let dBClusterParameterGroupName: Swift.String?
    let vpcSecurityGroupIds: [Swift.String]?
    let dBSubnetGroupName: Swift.String?
    let engine: Swift.String?
    let engineVersion: Swift.String?
    let port: Swift.Int?
    let masterUsername: Swift.String?
    let masterUserPassword: Swift.String?
    let optionGroupName: Swift.String?
    let preferredBackupWindow: Swift.String?
    let preferredMaintenanceWindow: Swift.String?
    let tags: [RdsClientTypes.Tag]?
    let storageEncrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let enableIAMDatabaseAuthentication: Swift.Bool?
    let sourceEngine: Swift.String?
    let sourceEngineVersion: Swift.String?
    let s3BucketName: Swift.String?
    let s3Prefix: Swift.String?
    let s3IngestionRoleArn: Swift.String?
    let backtrackWindow: Swift.Int?
    let enableCloudwatchLogsExports: [Swift.String]?
    let deletionProtection: Swift.Bool?
    let copyTagsToSnapshot: Swift.Bool?
    let domain: Swift.String?
    let domainIAMRoleName: Swift.String?
    let serverlessV2ScalingConfiguration: RdsClientTypes.ServerlessV2ScalingConfiguration?
    let networkType: Swift.String?
}

extension RestoreDBClusterFromS3InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backtrackWindow = "BacktrackWindow"
        case backupRetentionPeriod = "BackupRetentionPeriod"
        case characterSetName = "CharacterSetName"
        case copyTagsToSnapshot = "CopyTagsToSnapshot"
        case dBClusterIdentifier = "DBClusterIdentifier"
        case dBClusterParameterGroupName = "DBClusterParameterGroupName"
        case dBSubnetGroupName = "DBSubnetGroupName"
        case databaseName = "DatabaseName"
        case deletionProtection = "DeletionProtection"
        case domain = "Domain"
        case domainIAMRoleName = "DomainIAMRoleName"
        case enableCloudwatchLogsExports = "EnableCloudwatchLogsExports"
        case enableIAMDatabaseAuthentication = "EnableIAMDatabaseAuthentication"
        case engine = "Engine"
        case engineVersion = "EngineVersion"
        case kmsKeyId = "KmsKeyId"
        case masterUserPassword = "MasterUserPassword"
        case masterUsername = "MasterUsername"
        case networkType = "NetworkType"
        case optionGroupName = "OptionGroupName"
        case port = "Port"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case s3BucketName = "S3BucketName"
        case s3IngestionRoleArn = "S3IngestionRoleArn"
        case s3Prefix = "S3Prefix"
        case serverlessV2ScalingConfiguration = "ServerlessV2ScalingConfiguration"
        case sourceEngine = "SourceEngine"
        case sourceEngineVersion = "SourceEngineVersion"
        case storageEncrypted = "StorageEncrypted"
        case tags = "Tags"
        case vpcSecurityGroupIds = "VpcSecurityGroupIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct AvailabilityZone{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AvailabilityZone>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let backupRetentionPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionPeriod)
        backupRetentionPeriod = backupRetentionPeriodDecoded
        let characterSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .characterSetName)
        characterSetName = characterSetNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let dBClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterIdentifier)
        dBClusterIdentifier = dBClusterIdentifierDecoded
        let dBClusterParameterGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBClusterParameterGroupName)
        dBClusterParameterGroupName = dBClusterParameterGroupNameDecoded
        if containerValues.contains(.vpcSecurityGroupIds) {
            struct KeyVal0{struct VpcSecurityGroupId{}}
            let vpcSecurityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.VpcSecurityGroupId>.CodingKeys.self, forKey: .vpcSecurityGroupIds)
            if let vpcSecurityGroupIdsWrappedContainer = vpcSecurityGroupIdsWrappedContainer {
                let vpcSecurityGroupIdsContainer = try vpcSecurityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var vpcSecurityGroupIdsBuffer:[Swift.String]? = nil
                if let vpcSecurityGroupIdsContainer = vpcSecurityGroupIdsContainer {
                    vpcSecurityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in vpcSecurityGroupIdsContainer {
                        vpcSecurityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                vpcSecurityGroupIds = vpcSecurityGroupIdsBuffer
            } else {
                vpcSecurityGroupIds = []
            }
        } else {
            vpcSecurityGroupIds = nil
        }
        let dBSubnetGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dBSubnetGroupName)
        dBSubnetGroupName = dBSubnetGroupNameDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let masterUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUsername)
        masterUsername = masterUsernameDecoded
        let masterUserPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterUserPassword)
        masterUserPassword = masterUserPasswordDecoded
        let optionGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .optionGroupName)
        optionGroupName = optionGroupNameDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct Tag{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([RdsClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[RdsClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [RdsClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let storageEncryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .storageEncrypted)
        storageEncrypted = storageEncryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let enableIAMDatabaseAuthenticationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableIAMDatabaseAuthentication)
        enableIAMDatabaseAuthentication = enableIAMDatabaseAuthenticationDecoded
        let sourceEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngine)
        sourceEngine = sourceEngineDecoded
        let sourceEngineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceEngineVersion)
        sourceEngineVersion = sourceEngineVersionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3IngestionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3IngestionRoleArn)
        s3IngestionRoleArn = s3IngestionRoleArnDecoded
        let backtrackWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backtrackWindow)
        backtrackWindow = backtrackWindowDecoded
        if containerValues.contains(.enableCloudwatchLogsExports) {
            struct KeyVal0{struct member{}}
            let enableCloudwatchLogsExportsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .enableCloudwatchLogsExports)
            if let enableCloudwatchLogsExportsWrappedContainer = enableCloudwatchLogsExportsWrappedContainer {
                let enableCloudwatchLogsExportsContainer = try enableCloudwatchLogsExportsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var enableCloudwatchLogsExportsBuffer:[Swift.String]? = nil
                if let enableCloudwatchLogsExportsContainer = enableCloudwatchLogsExportsContainer {
                    enableCloudwatchLogsExportsBuffer = [Swift.String]()
                    for stringContainer0 in enableCloudwatchLogsExportsContainer {
                        enableCloudwatchLogsExportsBuffer?.append(stringContainer0)
                    }
                }
                enableCloudwatchLogsExports = enableCloudwatchLogsExportsBuffer
            } else {
                enableCloudwatchLogsExports = []
            }
        } else {
            enableCloudwatchLogsExports = nil
        }
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let copyTagsToSnapshotDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTagsToSnapshot)
        copyTagsToSnapshot = copyTagsToSnapshotDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainIAMRoleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainIAMRoleName)
        domainIAMRoleName = domainIAMRoleNameDecoded
        let serverlessV2ScalingConfigurationDecoded = try containerValues.decodeIfPresent(RdsClientTypes.ServerlessV2ScalingConfiguration.self, forKey: .serverlessV2ScalingConfiguration)
        serverlessV2ScalingConfiguration = serverlessV2ScalingConfigurationDecoded
        let networkTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkType)
        networkType = networkTypeDecoded
    }
}
