// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct UpdateEnvironmentOutputResponseBody: Swift.Equatable {
    let environmentName: Swift.String?
    let environmentId: Swift.String?
    let applicationName: Swift.String?
    let versionLabel: Swift.String?
    let solutionStackName: Swift.String?
    let platformArn: Swift.String?
    let templateName: Swift.String?
    let description: Swift.String?
    let endpointURL: Swift.String?
    let cNAME: Swift.String?
    let dateCreated: ClientRuntime.Date?
    let dateUpdated: ClientRuntime.Date?
    let status: ElasticBeanstalkClientTypes.EnvironmentStatus?
    let abortableOperationInProgress: Swift.Bool?
    let health: ElasticBeanstalkClientTypes.EnvironmentHealth?
    let healthStatus: ElasticBeanstalkClientTypes.EnvironmentHealthStatus?
    let resources: ElasticBeanstalkClientTypes.EnvironmentResourcesDescription?
    let tier: ElasticBeanstalkClientTypes.EnvironmentTier?
    let environmentLinks: [ElasticBeanstalkClientTypes.EnvironmentLink]?
    let environmentArn: Swift.String?
    let operationsRole: Swift.String?
}

extension UpdateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortableOperationInProgress = "AbortableOperationInProgress"
        case applicationName = "ApplicationName"
        case cNAME = "CNAME"
        case dateCreated = "DateCreated"
        case dateUpdated = "DateUpdated"
        case description = "Description"
        case endpointURL = "EndpointURL"
        case environmentArn = "EnvironmentArn"
        case environmentId = "EnvironmentId"
        case environmentLinks = "EnvironmentLinks"
        case environmentName = "EnvironmentName"
        case health = "Health"
        case healthStatus = "HealthStatus"
        case operationsRole = "OperationsRole"
        case platformArn = "PlatformArn"
        case resources = "Resources"
        case solutionStackName = "SolutionStackName"
        case status = "Status"
        case templateName = "TemplateName"
        case tier = "Tier"
        case versionLabel = "VersionLabel"
    }

    public init (from decoder: Swift.Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: ClientRuntime.Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: ClientRuntime.Key("UpdateEnvironmentResult"))
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let applicationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationName)
        applicationName = applicationNameDecoded
        let versionLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionLabel)
        versionLabel = versionLabelDecoded
        let solutionStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .solutionStackName)
        solutionStackName = solutionStackNameDecoded
        let platformArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformArn)
        platformArn = platformArnDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let endpointURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointURL)
        endpointURL = endpointURLDecoded
        let cNAMEDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        var dateCreatedBuffer:ClientRuntime.Date? = nil
        if let dateCreatedDecoded = dateCreatedDecoded {
            dateCreatedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateCreatedDecoded, format: .dateTime)
        }
        dateCreated = dateCreatedBuffer
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        var dateUpdatedBuffer:ClientRuntime.Date? = nil
        if let dateUpdatedDecoded = dateUpdatedDecoded {
            dateUpdatedBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(dateUpdatedDecoded, format: .dateTime)
        }
        dateUpdated = dateUpdatedBuffer
        let statusDecoded = try containerValues.decodeIfPresent(ElasticBeanstalkClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let abortableOperationInProgressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .abortableOperationInProgress)
        abortableOperationInProgress = abortableOperationInProgressDecoded
        let healthDecoded = try containerValues.decodeIfPresent(ElasticBeanstalkClientTypes.EnvironmentHealth.self, forKey: .health)
        health = healthDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(ElasticBeanstalkClientTypes.EnvironmentHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(ElasticBeanstalkClientTypes.EnvironmentResourcesDescription.self, forKey: .resources)
        resources = resourcesDecoded
        let tierDecoded = try containerValues.decodeIfPresent(ElasticBeanstalkClientTypes.EnvironmentTier.self, forKey: .tier)
        tier = tierDecoded
        if containerValues.contains(.environmentLinks) {
            struct KeyVal0{struct member{}}
            let environmentLinksWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .environmentLinks)
            if let environmentLinksWrappedContainer = environmentLinksWrappedContainer {
                let environmentLinksContainer = try environmentLinksWrappedContainer.decodeIfPresent([ElasticBeanstalkClientTypes.EnvironmentLink].self, forKey: .member)
                var environmentLinksBuffer:[ElasticBeanstalkClientTypes.EnvironmentLink]? = nil
                if let environmentLinksContainer = environmentLinksContainer {
                    environmentLinksBuffer = [ElasticBeanstalkClientTypes.EnvironmentLink]()
                    for structureContainer0 in environmentLinksContainer {
                        environmentLinksBuffer?.append(structureContainer0)
                    }
                }
                environmentLinks = environmentLinksBuffer
            } else {
                environmentLinks = []
            }
        } else {
            environmentLinks = nil
        }
        let environmentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentArn)
        environmentArn = environmentArnDecoded
        let operationsRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationsRole)
        operationsRole = operationsRoleDecoded
    }
}
