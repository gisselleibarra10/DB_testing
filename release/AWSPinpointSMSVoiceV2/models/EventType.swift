// Code generated by smithy-swift-codegen. DO NOT EDIT!



extension PinpointSmsVoiceV2ClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case textAll
        case textBlocked
        case textCarrierBlocked
        case textCarrierUnreachable
        case textDelivered
        case textInvalid
        case textInvalidMessage
        case textPending
        case textQueued
        case textSent
        case textSpam
        case textSuccessful
        case textTtlExpired
        case textUnknown
        case textUnreachable
        case voiceAll
        case voiceAnswered
        case voiceBusy
        case voiceCompleted
        case voiceFailed
        case voiceInitiated
        case voiceNoAnswer
        case voiceRinging
        case voiceTtlExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .all,
                .textAll,
                .textBlocked,
                .textCarrierBlocked,
                .textCarrierUnreachable,
                .textDelivered,
                .textInvalid,
                .textInvalidMessage,
                .textPending,
                .textQueued,
                .textSent,
                .textSpam,
                .textSuccessful,
                .textTtlExpired,
                .textUnknown,
                .textUnreachable,
                .voiceAll,
                .voiceAnswered,
                .voiceBusy,
                .voiceCompleted,
                .voiceFailed,
                .voiceInitiated,
                .voiceNoAnswer,
                .voiceRinging,
                .voiceTtlExpired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .textAll: return "TEXT_ALL"
            case .textBlocked: return "TEXT_BLOCKED"
            case .textCarrierBlocked: return "TEXT_CARRIER_BLOCKED"
            case .textCarrierUnreachable: return "TEXT_CARRIER_UNREACHABLE"
            case .textDelivered: return "TEXT_DELIVERED"
            case .textInvalid: return "TEXT_INVALID"
            case .textInvalidMessage: return "TEXT_INVALID_MESSAGE"
            case .textPending: return "TEXT_PENDING"
            case .textQueued: return "TEXT_QUEUED"
            case .textSent: return "TEXT_SENT"
            case .textSpam: return "TEXT_SPAM"
            case .textSuccessful: return "TEXT_SUCCESSFUL"
            case .textTtlExpired: return "TEXT_TTL_EXPIRED"
            case .textUnknown: return "TEXT_UNKNOWN"
            case .textUnreachable: return "TEXT_UNREACHABLE"
            case .voiceAll: return "VOICE_ALL"
            case .voiceAnswered: return "VOICE_ANSWERED"
            case .voiceBusy: return "VOICE_BUSY"
            case .voiceCompleted: return "VOICE_COMPLETED"
            case .voiceFailed: return "VOICE_FAILED"
            case .voiceInitiated: return "VOICE_INITIATED"
            case .voiceNoAnswer: return "VOICE_NO_ANSWER"
            case .voiceRinging: return "VOICE_RINGING"
            case .voiceTtlExpired: return "VOICE_TTL_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}
