// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension IotClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abortConfig
        case comment
        case completedAt
        case createdAt
        case description
        case documentParameters
        case forceCanceled
        case isConcurrent
        case jobArn
        case jobExecutionsRetryConfig
        case jobExecutionsRolloutConfig
        case jobId
        case jobProcessDetails
        case jobTemplateArn
        case lastUpdatedAt
        case namespaceId
        case presignedUrlConfig
        case reasonCode
        case status
        case targetSelection
        case targets
        case timeoutConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abortConfig = self.abortConfig {
            try encodeContainer.encode(abortConfig, forKey: .abortConfig)
        }
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let completedAt = self.completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentParameters = documentParameters {
            var documentParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .documentParameters)
            for (dictKey0, parametermap0) in documentParameters {
                try documentParametersContainer.encode(parametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let forceCanceled = self.forceCanceled {
            try encodeContainer.encode(forceCanceled, forKey: .forceCanceled)
        }
        if let isConcurrent = self.isConcurrent {
            try encodeContainer.encode(isConcurrent, forKey: .isConcurrent)
        }
        if let jobArn = self.jobArn {
            try encodeContainer.encode(jobArn, forKey: .jobArn)
        }
        if let jobExecutionsRetryConfig = self.jobExecutionsRetryConfig {
            try encodeContainer.encode(jobExecutionsRetryConfig, forKey: .jobExecutionsRetryConfig)
        }
        if let jobExecutionsRolloutConfig = self.jobExecutionsRolloutConfig {
            try encodeContainer.encode(jobExecutionsRolloutConfig, forKey: .jobExecutionsRolloutConfig)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobProcessDetails = self.jobProcessDetails {
            try encodeContainer.encode(jobProcessDetails, forKey: .jobProcessDetails)
        }
        if let jobTemplateArn = self.jobTemplateArn {
            try encodeContainer.encode(jobTemplateArn, forKey: .jobTemplateArn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let namespaceId = self.namespaceId {
            try encodeContainer.encode(namespaceId, forKey: .namespaceId)
        }
        if let presignedUrlConfig = self.presignedUrlConfig {
            try encodeContainer.encode(presignedUrlConfig, forKey: .presignedUrlConfig)
        }
        if let reasonCode = self.reasonCode {
            try encodeContainer.encode(reasonCode, forKey: .reasonCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetSelection = self.targetSelection {
            try encodeContainer.encode(targetSelection.rawValue, forKey: .targetSelection)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for jobtargets0 in targets {
                try targetsContainer.encode(jobtargets0)
            }
        }
        if let timeoutConfig = self.timeoutConfig {
            try encodeContainer.encode(timeoutConfig, forKey: .timeoutConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let targetSelectionDecoded = try containerValues.decodeIfPresent(IotClientTypes.TargetSelection.self, forKey: .targetSelection)
        targetSelection = targetSelectionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let forceCanceledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceCanceled)
        forceCanceled = forceCanceledDecoded
        let reasonCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reasonCode)
        reasonCode = reasonCodeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let presignedUrlConfigDecoded = try containerValues.decodeIfPresent(IotClientTypes.PresignedUrlConfig.self, forKey: .presignedUrlConfig)
        presignedUrlConfig = presignedUrlConfigDecoded
        let jobExecutionsRolloutConfigDecoded = try containerValues.decodeIfPresent(IotClientTypes.JobExecutionsRolloutConfig.self, forKey: .jobExecutionsRolloutConfig)
        jobExecutionsRolloutConfig = jobExecutionsRolloutConfigDecoded
        let abortConfigDecoded = try containerValues.decodeIfPresent(IotClientTypes.AbortConfig.self, forKey: .abortConfig)
        abortConfig = abortConfigDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let jobProcessDetailsDecoded = try containerValues.decodeIfPresent(IotClientTypes.JobProcessDetails.self, forKey: .jobProcessDetails)
        jobProcessDetails = jobProcessDetailsDecoded
        let timeoutConfigDecoded = try containerValues.decodeIfPresent(IotClientTypes.TimeoutConfig.self, forKey: .timeoutConfig)
        timeoutConfig = timeoutConfigDecoded
        let namespaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespaceId)
        namespaceId = namespaceIdDecoded
        let jobTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobTemplateArn)
        jobTemplateArn = jobTemplateArnDecoded
        let jobExecutionsRetryConfigDecoded = try containerValues.decodeIfPresent(IotClientTypes.JobExecutionsRetryConfig.self, forKey: .jobExecutionsRetryConfig)
        jobExecutionsRetryConfig = jobExecutionsRetryConfigDecoded
        let documentParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .documentParameters)
        var documentParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let documentParametersContainer = documentParametersContainer {
            documentParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in documentParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    documentParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        documentParameters = documentParametersDecoded0
        let isConcurrentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isConcurrent)
        isConcurrent = isConcurrentDecoded
    }
}
