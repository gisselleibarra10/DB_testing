// Code generated by smithy-swift-codegen. DO NOT EDIT!



extension CostExplorerClientTypes {
    /// This object continuously inspects your account's cost data for anomalies. It's based on MonitorType and MonitorSpecification. The content consists of detailed metadata and the current status of the monitor object.
    public struct AnomalyMonitor: Swift.Equatable {
        /// The date when the monitor was created.
        public var creationDate: Swift.String?
        /// The value for evaluated dimensions.
        public var dimensionalValueCount: Swift.Int
        /// The date when the monitor last evaluated for anomalies.
        public var lastEvaluatedDate: Swift.String?
        /// The date when the monitor was last updated.
        public var lastUpdatedDate: Swift.String?
        /// The Amazon Resource Name (ARN) value.
        public var monitorArn: Swift.String?
        /// The dimensions to evaluate.
        public var monitorDimension: CostExplorerClientTypes.MonitorDimension?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// Use Expression to filter by cost or by usage. There are two patterns:
        ///
        /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
        ///
        /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
        ///
        ///
        /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
        public var monitorSpecification: CostExplorerClientTypes.Expression?
        /// The possible type values.
        /// This member is required.
        public var monitorType: CostExplorerClientTypes.MonitorType?

        public init (
            creationDate: Swift.String? = nil,
            dimensionalValueCount: Swift.Int = 0,
            lastEvaluatedDate: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            monitorArn: Swift.String? = nil,
            monitorDimension: CostExplorerClientTypes.MonitorDimension? = nil,
            monitorName: Swift.String? = nil,
            monitorSpecification: CostExplorerClientTypes.Expression? = nil,
            monitorType: CostExplorerClientTypes.MonitorType? = nil
        )
        {
            self.creationDate = creationDate
            self.dimensionalValueCount = dimensionalValueCount
            self.lastEvaluatedDate = lastEvaluatedDate
            self.lastUpdatedDate = lastUpdatedDate
            self.monitorArn = monitorArn
            self.monitorDimension = monitorDimension
            self.monitorName = monitorName
            self.monitorSpecification = monitorSpecification
            self.monitorType = monitorType
        }
    }

}
