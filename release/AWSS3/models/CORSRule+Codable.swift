// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension S3ClientTypes.CORSRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedHeaders = "AllowedHeader"
        case allowedMethods = "AllowedMethod"
        case allowedOrigins = "AllowedOrigin"
        case exposeHeaders = "ExposeHeader"
        case iD = "ID"
        case maxAgeSeconds = "MaxAgeSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://s3.amazonaws.com/doc/2006-03-01/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let allowedHeaders = allowedHeaders {
            if allowedHeaders.isEmpty {
                var allowedHeadersContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedHeader"))
                try allowedHeadersContainer.encodeNil()
            } else {
                for allowedheader0 in allowedHeaders {
                    var allowedHeadersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedHeader"))
                    try allowedHeadersContainer0.encode(allowedheader0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let allowedMethods = allowedMethods {
            if allowedMethods.isEmpty {
                var allowedMethodsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedMethod"))
                try allowedMethodsContainer.encodeNil()
            } else {
                for allowedmethod0 in allowedMethods {
                    var allowedMethodsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedMethod"))
                    try allowedMethodsContainer0.encode(allowedmethod0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let allowedOrigins = allowedOrigins {
            if allowedOrigins.isEmpty {
                var allowedOriginsContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("AllowedOrigin"))
                try allowedOriginsContainer.encodeNil()
            } else {
                for allowedorigin0 in allowedOrigins {
                    var allowedOriginsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AllowedOrigin"))
                    try allowedOriginsContainer0.encode(allowedorigin0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let exposeHeaders = exposeHeaders {
            if exposeHeaders.isEmpty {
                var exposeHeadersContainer = container.nestedUnkeyedContainer(forKey: ClientRuntime.Key("ExposeHeader"))
                try exposeHeadersContainer.encodeNil()
            } else {
                for exposeheader0 in exposeHeaders {
                    var exposeHeadersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExposeHeader"))
                    try exposeHeadersContainer0.encode(exposeheader0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let iD = iD {
            try container.encode(iD, forKey: ClientRuntime.Key("ID"))
        }
        if maxAgeSeconds != 0 {
            try container.encode(maxAgeSeconds, forKey: ClientRuntime.Key("MaxAgeSeconds"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iD)
        iD = iDDecoded
        if containerValues.contains(.allowedHeaders) {
            let allowedHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedHeaders)
            if allowedHeadersWrappedContainer != nil {
                let allowedHeadersContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedHeaders)
                var allowedHeadersBuffer:[Swift.String]? = nil
                if let allowedHeadersContainer = allowedHeadersContainer {
                    allowedHeadersBuffer = [Swift.String]()
                    for stringContainer0 in allowedHeadersContainer {
                        allowedHeadersBuffer?.append(stringContainer0)
                    }
                }
                allowedHeaders = allowedHeadersBuffer
            } else {
                allowedHeaders = []
            }
        } else {
            allowedHeaders = nil
        }
        if containerValues.contains(.allowedMethods) {
            let allowedMethodsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedMethods)
            if allowedMethodsWrappedContainer != nil {
                let allowedMethodsContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedMethods)
                var allowedMethodsBuffer:[Swift.String]? = nil
                if let allowedMethodsContainer = allowedMethodsContainer {
                    allowedMethodsBuffer = [Swift.String]()
                    for stringContainer0 in allowedMethodsContainer {
                        allowedMethodsBuffer?.append(stringContainer0)
                    }
                }
                allowedMethods = allowedMethodsBuffer
            } else {
                allowedMethods = []
            }
        } else {
            allowedMethods = nil
        }
        if containerValues.contains(.allowedOrigins) {
            let allowedOriginsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .allowedOrigins)
            if allowedOriginsWrappedContainer != nil {
                let allowedOriginsContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .allowedOrigins)
                var allowedOriginsBuffer:[Swift.String]? = nil
                if let allowedOriginsContainer = allowedOriginsContainer {
                    allowedOriginsBuffer = [Swift.String]()
                    for stringContainer0 in allowedOriginsContainer {
                        allowedOriginsBuffer?.append(stringContainer0)
                    }
                }
                allowedOrigins = allowedOriginsBuffer
            } else {
                allowedOrigins = []
            }
        } else {
            allowedOrigins = nil
        }
        if containerValues.contains(.exposeHeaders) {
            let exposeHeadersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .exposeHeaders)
            if exposeHeadersWrappedContainer != nil {
                let exposeHeadersContainer = try containerValues.decodeIfPresent([Swift.String].self, forKey: .exposeHeaders)
                var exposeHeadersBuffer:[Swift.String]? = nil
                if let exposeHeadersContainer = exposeHeadersContainer {
                    exposeHeadersBuffer = [Swift.String]()
                    for stringContainer0 in exposeHeadersContainer {
                        exposeHeadersBuffer?.append(stringContainer0)
                    }
                }
                exposeHeaders = exposeHeadersBuffer
            } else {
                exposeHeaders = []
            }
        } else {
            exposeHeaders = nil
        }
        let maxAgeSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxAgeSeconds)
        maxAgeSeconds = maxAgeSecondsDecoded
    }
}
