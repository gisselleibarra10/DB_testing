// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ListObjectVersionsOutputResponseBody: Swift.Equatable {
    let isTruncated: Swift.Bool
    let keyMarker: Swift.String?
    let versionIdMarker: Swift.String?
    let nextKeyMarker: Swift.String?
    let nextVersionIdMarker: Swift.String?
    let versions: [S3ClientTypes.ObjectVersion]?
    let deleteMarkers: [S3ClientTypes.DeleteMarkerEntry]?
    let name: Swift.String?
    let `prefix`: Swift.String?
    let delimiter: Swift.String?
    let maxKeys: Swift.Int
    let commonPrefixes: [S3ClientTypes.CommonPrefix]?
    let encodingType: S3ClientTypes.EncodingType?
}

extension ListObjectVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commonPrefixes = "CommonPrefixes"
        case deleteMarkers = "DeleteMarker"
        case delimiter = "Delimiter"
        case encodingType = "EncodingType"
        case isTruncated = "IsTruncated"
        case keyMarker = "KeyMarker"
        case maxKeys = "MaxKeys"
        case name = "Name"
        case nextKeyMarker = "NextKeyMarker"
        case nextVersionIdMarker = "NextVersionIdMarker"
        case `prefix` = "Prefix"
        case versionIdMarker = "VersionIdMarker"
        case versions = "Version"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isTruncatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let keyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyMarker)
        keyMarker = keyMarkerDecoded
        let versionIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionIdMarker)
        versionIdMarker = versionIdMarkerDecoded
        let nextKeyMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextKeyMarker)
        nextKeyMarker = nextKeyMarkerDecoded
        let nextVersionIdMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextVersionIdMarker)
        nextVersionIdMarker = nextVersionIdMarkerDecoded
        if containerValues.contains(.versions) {
            let versionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .versions)
            if versionsWrappedContainer != nil {
                let versionsContainer = try containerValues.decodeIfPresent([S3ClientTypes.ObjectVersion].self, forKey: .versions)
                var versionsBuffer:[S3ClientTypes.ObjectVersion]? = nil
                if let versionsContainer = versionsContainer {
                    versionsBuffer = [S3ClientTypes.ObjectVersion]()
                    for structureContainer0 in versionsContainer {
                        versionsBuffer?.append(structureContainer0)
                    }
                }
                versions = versionsBuffer
            } else {
                versions = []
            }
        } else {
            versions = nil
        }
        if containerValues.contains(.deleteMarkers) {
            let deleteMarkersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .deleteMarkers)
            if deleteMarkersWrappedContainer != nil {
                let deleteMarkersContainer = try containerValues.decodeIfPresent([S3ClientTypes.DeleteMarkerEntry].self, forKey: .deleteMarkers)
                var deleteMarkersBuffer:[S3ClientTypes.DeleteMarkerEntry]? = nil
                if let deleteMarkersContainer = deleteMarkersContainer {
                    deleteMarkersBuffer = [S3ClientTypes.DeleteMarkerEntry]()
                    for structureContainer0 in deleteMarkersContainer {
                        deleteMarkersBuffer?.append(structureContainer0)
                    }
                }
                deleteMarkers = deleteMarkersBuffer
            } else {
                deleteMarkers = []
            }
        } else {
            deleteMarkers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let maxKeysDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxKeys)
        maxKeys = maxKeysDecoded
        if containerValues.contains(.commonPrefixes) {
            let commonPrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CodingKeys.self, forKey: .commonPrefixes)
            if commonPrefixesWrappedContainer != nil {
                let commonPrefixesContainer = try containerValues.decodeIfPresent([S3ClientTypes.CommonPrefix].self, forKey: .commonPrefixes)
                var commonPrefixesBuffer:[S3ClientTypes.CommonPrefix]? = nil
                if let commonPrefixesContainer = commonPrefixesContainer {
                    commonPrefixesBuffer = [S3ClientTypes.CommonPrefix]()
                    for structureContainer0 in commonPrefixesContainer {
                        commonPrefixesBuffer?.append(structureContainer0)
                    }
                }
                commonPrefixes = commonPrefixesBuffer
            } else {
                commonPrefixes = []
            }
        } else {
            commonPrefixes = nil
        }
        let encodingTypeDecoded = try containerValues.decodeIfPresent(S3ClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
    }
}
