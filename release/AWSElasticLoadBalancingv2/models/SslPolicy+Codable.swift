// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ElasticLoadBalancingV2ClientTypes.SslPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ciphers = "Ciphers"
        case name = "Name"
        case sslProtocols = "SslProtocols"
        case supportedLoadBalancerTypes = "SupportedLoadBalancerTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let ciphers = ciphers {
            var ciphersContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ciphers"))
            for (index0, cipher0) in ciphers.enumerated() {
                try ciphersContainer.encode(cipher0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let sslProtocols = sslProtocols {
            var sslProtocolsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SslProtocols"))
            for (index0, sslprotocol0) in sslProtocols.enumerated() {
                try sslProtocolsContainer.encode(sslprotocol0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let supportedLoadBalancerTypes = supportedLoadBalancerTypes {
            var supportedLoadBalancerTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedLoadBalancerTypes"))
            for (index0, stringvalue0) in supportedLoadBalancerTypes.enumerated() {
                try supportedLoadBalancerTypesContainer.encode(stringvalue0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.sslProtocols) {
            struct KeyVal0{struct member{}}
            let sslProtocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslProtocols)
            if let sslProtocolsWrappedContainer = sslProtocolsWrappedContainer {
                let sslProtocolsContainer = try sslProtocolsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sslProtocolsBuffer:[Swift.String]? = nil
                if let sslProtocolsContainer = sslProtocolsContainer {
                    sslProtocolsBuffer = [Swift.String]()
                    for stringContainer0 in sslProtocolsContainer {
                        sslProtocolsBuffer?.append(stringContainer0)
                    }
                }
                sslProtocols = sslProtocolsBuffer
            } else {
                sslProtocols = []
            }
        } else {
            sslProtocols = nil
        }
        if containerValues.contains(.ciphers) {
            struct KeyVal0{struct member{}}
            let ciphersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ciphers)
            if let ciphersWrappedContainer = ciphersWrappedContainer {
                let ciphersContainer = try ciphersWrappedContainer.decodeIfPresent([ElasticLoadBalancingV2ClientTypes.Cipher].self, forKey: .member)
                var ciphersBuffer:[ElasticLoadBalancingV2ClientTypes.Cipher]? = nil
                if let ciphersContainer = ciphersContainer {
                    ciphersBuffer = [ElasticLoadBalancingV2ClientTypes.Cipher]()
                    for structureContainer0 in ciphersContainer {
                        ciphersBuffer?.append(structureContainer0)
                    }
                }
                ciphers = ciphersBuffer
            } else {
                ciphers = []
            }
        } else {
            ciphers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.supportedLoadBalancerTypes) {
            struct KeyVal0{struct member{}}
            let supportedLoadBalancerTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .supportedLoadBalancerTypes)
            if let supportedLoadBalancerTypesWrappedContainer = supportedLoadBalancerTypesWrappedContainer {
                let supportedLoadBalancerTypesContainer = try supportedLoadBalancerTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var supportedLoadBalancerTypesBuffer:[Swift.String]? = nil
                if let supportedLoadBalancerTypesContainer = supportedLoadBalancerTypesContainer {
                    supportedLoadBalancerTypesBuffer = [Swift.String]()
                    for stringContainer0 in supportedLoadBalancerTypesContainer {
                        supportedLoadBalancerTypesBuffer?.append(stringContainer0)
                    }
                }
                supportedLoadBalancerTypes = supportedLoadBalancerTypesBuffer
            } else {
                supportedLoadBalancerTypes = []
            }
        } else {
            supportedLoadBalancerTypes = nil
        }
    }
}
