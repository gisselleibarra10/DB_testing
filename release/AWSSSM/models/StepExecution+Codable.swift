// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SsmClientTypes.StepExecution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case executionEndTime = "ExecutionEndTime"
        case executionStartTime = "ExecutionStartTime"
        case failureDetails = "FailureDetails"
        case failureMessage = "FailureMessage"
        case inputs = "Inputs"
        case isCritical = "IsCritical"
        case isEnd = "IsEnd"
        case maxAttempts = "MaxAttempts"
        case nextStep = "NextStep"
        case onFailure = "OnFailure"
        case outputs = "Outputs"
        case overriddenParameters = "OverriddenParameters"
        case response = "Response"
        case responseCode = "ResponseCode"
        case stepExecutionId = "StepExecutionId"
        case stepName = "StepName"
        case stepStatus = "StepStatus"
        case targetLocation = "TargetLocation"
        case targets = "Targets"
        case timeoutSeconds = "TimeoutSeconds"
        case validNextSteps = "ValidNextSteps"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let executionEndTime = self.executionEndTime {
            try encodeContainer.encode(executionEndTime.timeIntervalSince1970, forKey: .executionEndTime)
        }
        if let executionStartTime = self.executionStartTime {
            try encodeContainer.encode(executionStartTime.timeIntervalSince1970, forKey: .executionStartTime)
        }
        if let failureDetails = self.failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputs)
            for (dictKey0, normalstringmap0) in inputs {
                try inputsContainer.encode(normalstringmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let isCritical = self.isCritical {
            try encodeContainer.encode(isCritical, forKey: .isCritical)
        }
        if let isEnd = self.isEnd {
            try encodeContainer.encode(isEnd, forKey: .isEnd)
        }
        if let maxAttempts = self.maxAttempts {
            try encodeContainer.encode(maxAttempts, forKey: .maxAttempts)
        }
        if let nextStep = self.nextStep {
            try encodeContainer.encode(nextStep, forKey: .nextStep)
        }
        if let onFailure = self.onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, automationparametermap0) in outputs {
                try outputsContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let overriddenParameters = overriddenParameters {
            var overriddenParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overriddenParameters)
            for (dictKey0, automationparametermap0) in overriddenParameters {
                try overriddenParametersContainer.encode(automationparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let response = self.response {
            try encodeContainer.encode(response, forKey: .response)
        }
        if let responseCode = self.responseCode {
            try encodeContainer.encode(responseCode, forKey: .responseCode)
        }
        if let stepExecutionId = self.stepExecutionId {
            try encodeContainer.encode(stepExecutionId, forKey: .stepExecutionId)
        }
        if let stepName = self.stepName {
            try encodeContainer.encode(stepName, forKey: .stepName)
        }
        if let stepStatus = self.stepStatus {
            try encodeContainer.encode(stepStatus.rawValue, forKey: .stepStatus)
        }
        if let targetLocation = self.targetLocation {
            try encodeContainer.encode(targetLocation, forKey: .targetLocation)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targets0 in targets {
                try targetsContainer.encode(targets0)
            }
        }
        if let timeoutSeconds = self.timeoutSeconds {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
        if let validNextSteps = validNextSteps {
            var validNextStepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validNextSteps)
            for validnextsteplist0 in validNextSteps {
                try validNextStepsContainer.encode(validnextsteplist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stepNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepName)
        stepName = stepNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds)
        timeoutSeconds = timeoutSecondsDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onFailure)
        onFailure = onFailureDecoded
        let maxAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxAttempts)
        maxAttempts = maxAttemptsDecoded
        let executionStartTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionStartTime)
        executionStartTime = executionStartTimeDecoded
        let executionEndTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .executionEndTime)
        executionEndTime = executionEndTimeDecoded
        let stepStatusDecoded = try containerValues.decodeIfPresent(SsmClientTypes.AutomationExecutionStatus.self, forKey: .stepStatus)
        stepStatus = stepStatusDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let inputsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputs)
        var inputsDecoded0: [Swift.String:Swift.String]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in inputsContainer {
                if let string0 = string0 {
                    inputsDecoded0?[key0] = string0
                }
            }
        }
        inputs = inputsDecoded0
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:[Swift.String]]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in outputsContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                outputsDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        outputs = outputsDecoded0
        let responseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .response)
        response = responseDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(SsmClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
        let stepExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stepExecutionId)
        stepExecutionId = stepExecutionIdDecoded
        let overriddenParametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .overriddenParameters)
        var overriddenParametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let overriddenParametersContainer = overriddenParametersContainer {
            overriddenParametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, automationparametervaluelist0) in overriddenParametersContainer {
                var automationparametervaluelist0Decoded0: [Swift.String]? = nil
                if let automationparametervaluelist0 = automationparametervaluelist0 {
                    automationparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in automationparametervaluelist0 {
                        if let string1 = string1 {
                            automationparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                overriddenParametersDecoded0?[key0] = automationparametervaluelist0Decoded0
            }
        }
        overriddenParameters = overriddenParametersDecoded0
        let isEndDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEnd)
        isEnd = isEndDecoded
        let nextStepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextStep)
        nextStep = nextStepDecoded
        let isCriticalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCritical)
        isCritical = isCriticalDecoded
        let validNextStepsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .validNextSteps)
        var validNextStepsDecoded0:[Swift.String]? = nil
        if let validNextStepsContainer = validNextStepsContainer {
            validNextStepsDecoded0 = [Swift.String]()
            for string0 in validNextStepsContainer {
                if let string0 = string0 {
                    validNextStepsDecoded0?.append(string0)
                }
            }
        }
        validNextSteps = validNextStepsDecoded0
        let targetsContainer = try containerValues.decodeIfPresent([SsmClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SsmClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SsmClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let targetLocationDecoded = try containerValues.decodeIfPresent(SsmClientTypes.TargetLocation.self, forKey: .targetLocation)
        targetLocation = targetLocationDecoded
    }
}
