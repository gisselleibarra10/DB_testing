// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SsmClientTypes.BaselineOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvalRules = "ApprovalRules"
        case approvedPatches = "ApprovedPatches"
        case approvedPatchesComplianceLevel = "ApprovedPatchesComplianceLevel"
        case approvedPatchesEnableNonSecurity = "ApprovedPatchesEnableNonSecurity"
        case globalFilters = "GlobalFilters"
        case operatingSystem = "OperatingSystem"
        case rejectedPatches = "RejectedPatches"
        case rejectedPatchesAction = "RejectedPatchesAction"
        case sources = "Sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let approvalRules = self.approvalRules {
            try encodeContainer.encode(approvalRules, forKey: .approvalRules)
        }
        if let approvedPatches = approvedPatches {
            var approvedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .approvedPatches)
            for patchidlist0 in approvedPatches {
                try approvedPatchesContainer.encode(patchidlist0)
            }
        }
        if let approvedPatchesComplianceLevel = self.approvedPatchesComplianceLevel {
            try encodeContainer.encode(approvedPatchesComplianceLevel.rawValue, forKey: .approvedPatchesComplianceLevel)
        }
        if approvedPatchesEnableNonSecurity != false {
            try encodeContainer.encode(approvedPatchesEnableNonSecurity, forKey: .approvedPatchesEnableNonSecurity)
        }
        if let globalFilters = self.globalFilters {
            try encodeContainer.encode(globalFilters, forKey: .globalFilters)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem.rawValue, forKey: .operatingSystem)
        }
        if let rejectedPatches = rejectedPatches {
            var rejectedPatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rejectedPatches)
            for patchidlist0 in rejectedPatches {
                try rejectedPatchesContainer.encode(patchidlist0)
            }
        }
        if let rejectedPatchesAction = self.rejectedPatchesAction {
            try encodeContainer.encode(rejectedPatchesAction.rawValue, forKey: .rejectedPatchesAction)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for patchsourcelist0 in sources {
                try sourcesContainer.encode(patchsourcelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operatingSystemDecoded = try containerValues.decodeIfPresent(SsmClientTypes.OperatingSystem.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let globalFiltersDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchFilterGroup.self, forKey: .globalFilters)
        globalFilters = globalFiltersDecoded
        let approvalRulesDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchRuleGroup.self, forKey: .approvalRules)
        approvalRules = approvalRulesDecoded
        let approvedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .approvedPatches)
        var approvedPatchesDecoded0:[Swift.String]? = nil
        if let approvedPatchesContainer = approvedPatchesContainer {
            approvedPatchesDecoded0 = [Swift.String]()
            for string0 in approvedPatchesContainer {
                if let string0 = string0 {
                    approvedPatchesDecoded0?.append(string0)
                }
            }
        }
        approvedPatches = approvedPatchesDecoded0
        let approvedPatchesComplianceLevelDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchComplianceLevel.self, forKey: .approvedPatchesComplianceLevel)
        approvedPatchesComplianceLevel = approvedPatchesComplianceLevelDecoded
        let rejectedPatchesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rejectedPatches)
        var rejectedPatchesDecoded0:[Swift.String]? = nil
        if let rejectedPatchesContainer = rejectedPatchesContainer {
            rejectedPatchesDecoded0 = [Swift.String]()
            for string0 in rejectedPatchesContainer {
                if let string0 = string0 {
                    rejectedPatchesDecoded0?.append(string0)
                }
            }
        }
        rejectedPatches = rejectedPatchesDecoded0
        let rejectedPatchesActionDecoded = try containerValues.decodeIfPresent(SsmClientTypes.PatchAction.self, forKey: .rejectedPatchesAction)
        rejectedPatchesAction = rejectedPatchesActionDecoded
        let approvedPatchesEnableNonSecurityDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .approvedPatchesEnableNonSecurity) ?? false
        approvedPatchesEnableNonSecurity = approvedPatchesEnableNonSecurityDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([SsmClientTypes.PatchSource?].self, forKey: .sources)
        var sourcesDecoded0:[SsmClientTypes.PatchSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [SsmClientTypes.PatchSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}
