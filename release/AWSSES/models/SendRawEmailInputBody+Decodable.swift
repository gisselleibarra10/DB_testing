// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct SendRawEmailInputBody: Swift.Equatable {
    let source: Swift.String?
    let destinations: [Swift.String]?
    let rawMessage: SesClientTypes.RawMessage?
    let fromArn: Swift.String?
    let sourceArn: Swift.String?
    let returnPathArn: Swift.String?
    let tags: [SesClientTypes.MessageTag]?
    let configurationSetName: Swift.String?
}

extension SendRawEmailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case destinations = "Destinations"
        case fromArn = "FromArn"
        case rawMessage = "RawMessage"
        case returnPathArn = "ReturnPathArn"
        case source = "Source"
        case sourceArn = "SourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        if containerValues.contains(.destinations) {
            struct KeyVal0{struct member{}}
            let destinationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .destinations)
            if let destinationsWrappedContainer = destinationsWrappedContainer {
                let destinationsContainer = try destinationsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var destinationsBuffer:[Swift.String]? = nil
                if let destinationsContainer = destinationsContainer {
                    destinationsBuffer = [Swift.String]()
                    for stringContainer0 in destinationsContainer {
                        destinationsBuffer?.append(stringContainer0)
                    }
                }
                destinations = destinationsBuffer
            } else {
                destinations = []
            }
        } else {
            destinations = nil
        }
        let rawMessageDecoded = try containerValues.decodeIfPresent(SesClientTypes.RawMessage.self, forKey: .rawMessage)
        rawMessage = rawMessageDecoded
        let fromArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromArn)
        fromArn = fromArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let returnPathArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnPathArn)
        returnPathArn = returnPathArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SesClientTypes.MessageTag].self, forKey: .member)
                var tagsBuffer:[SesClientTypes.MessageTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SesClientTypes.MessageTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}
