// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct SendBulkTemplatedEmailInputBody: Swift.Equatable {
    let source: Swift.String?
    let sourceArn: Swift.String?
    let replyToAddresses: [Swift.String]?
    let returnPath: Swift.String?
    let returnPathArn: Swift.String?
    let configurationSetName: Swift.String?
    let defaultTags: [SesClientTypes.MessageTag]?
    let template: Swift.String?
    let templateArn: Swift.String?
    let defaultTemplateData: Swift.String?
    let destinations: [SesClientTypes.BulkEmailDestination]?
}

extension SendBulkTemplatedEmailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case defaultTags = "DefaultTags"
        case defaultTemplateData = "DefaultTemplateData"
        case destinations = "Destinations"
        case replyToAddresses = "ReplyToAddresses"
        case returnPath = "ReturnPath"
        case returnPathArn = "ReturnPathArn"
        case source = "Source"
        case sourceArn = "SourceArn"
        case template = "Template"
        case templateArn = "TemplateArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        if containerValues.contains(.replyToAddresses) {
            struct KeyVal0{struct member{}}
            let replyToAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .replyToAddresses)
            if let replyToAddressesWrappedContainer = replyToAddressesWrappedContainer {
                let replyToAddressesContainer = try replyToAddressesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var replyToAddressesBuffer:[Swift.String]? = nil
                if let replyToAddressesContainer = replyToAddressesContainer {
                    replyToAddressesBuffer = [Swift.String]()
                    for stringContainer0 in replyToAddressesContainer {
                        replyToAddressesBuffer?.append(stringContainer0)
                    }
                }
                replyToAddresses = replyToAddressesBuffer
            } else {
                replyToAddresses = []
            }
        } else {
            replyToAddresses = nil
        }
        let returnPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnPath)
        returnPath = returnPathDecoded
        let returnPathArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnPathArn)
        returnPathArn = returnPathArnDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        if containerValues.contains(.defaultTags) {
            struct KeyVal0{struct member{}}
            let defaultTagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .defaultTags)
            if let defaultTagsWrappedContainer = defaultTagsWrappedContainer {
                let defaultTagsContainer = try defaultTagsWrappedContainer.decodeIfPresent([SesClientTypes.MessageTag].self, forKey: .member)
                var defaultTagsBuffer:[SesClientTypes.MessageTag]? = nil
                if let defaultTagsContainer = defaultTagsContainer {
                    defaultTagsBuffer = [SesClientTypes.MessageTag]()
                    for structureContainer0 in defaultTagsContainer {
                        defaultTagsBuffer?.append(structureContainer0)
                    }
                }
                defaultTags = defaultTagsBuffer
            } else {
                defaultTags = []
            }
        } else {
            defaultTags = nil
        }
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let defaultTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultTemplateData)
        defaultTemplateData = defaultTemplateDataDecoded
        if containerValues.contains(.destinations) {
            struct KeyVal0{struct member{}}
            let destinationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .destinations)
            if let destinationsWrappedContainer = destinationsWrappedContainer {
                let destinationsContainer = try destinationsWrappedContainer.decodeIfPresent([SesClientTypes.BulkEmailDestination].self, forKey: .member)
                var destinationsBuffer:[SesClientTypes.BulkEmailDestination]? = nil
                if let destinationsContainer = destinationsContainer {
                    destinationsBuffer = [SesClientTypes.BulkEmailDestination]()
                    for structureContainer0 in destinationsContainer {
                        destinationsBuffer?.append(structureContainer0)
                    }
                }
                destinations = destinationsBuffer
            } else {
                destinations = []
            }
        } else {
            destinations = nil
        }
    }
}
