// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct SendTemplatedEmailInputBody: Swift.Equatable {
    let source: Swift.String?
    let destination: SesClientTypes.Destination?
    let replyToAddresses: [Swift.String]?
    let returnPath: Swift.String?
    let sourceArn: Swift.String?
    let returnPathArn: Swift.String?
    let tags: [SesClientTypes.MessageTag]?
    let configurationSetName: Swift.String?
    let template: Swift.String?
    let templateArn: Swift.String?
    let templateData: Swift.String?
}

extension SendTemplatedEmailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
        case destination = "Destination"
        case replyToAddresses = "ReplyToAddresses"
        case returnPath = "ReturnPath"
        case returnPathArn = "ReturnPathArn"
        case source = "Source"
        case sourceArn = "SourceArn"
        case tags = "Tags"
        case template = "Template"
        case templateArn = "TemplateArn"
        case templateData = "TemplateData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(SesClientTypes.Destination.self, forKey: .destination)
        destination = destinationDecoded
        if containerValues.contains(.replyToAddresses) {
            struct KeyVal0{struct member{}}
            let replyToAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .replyToAddresses)
            if let replyToAddressesWrappedContainer = replyToAddressesWrappedContainer {
                let replyToAddressesContainer = try replyToAddressesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var replyToAddressesBuffer:[Swift.String]? = nil
                if let replyToAddressesContainer = replyToAddressesContainer {
                    replyToAddressesBuffer = [Swift.String]()
                    for stringContainer0 in replyToAddressesContainer {
                        replyToAddressesBuffer?.append(stringContainer0)
                    }
                }
                replyToAddresses = replyToAddressesBuffer
            } else {
                replyToAddresses = []
            }
        } else {
            replyToAddresses = nil
        }
        let returnPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnPath)
        returnPath = returnPathDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let returnPathArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .returnPathArn)
        returnPathArn = returnPathArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([SesClientTypes.MessageTag].self, forKey: .member)
                var tagsBuffer:[SesClientTypes.MessageTag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [SesClientTypes.MessageTag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let templateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateArn)
        templateArn = templateArnDecoded
        let templateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateData)
        templateData = templateDataDecoded
    }
}
