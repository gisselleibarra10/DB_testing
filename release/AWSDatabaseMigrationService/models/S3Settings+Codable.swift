// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DatabaseMigrationClientTypes.S3Settings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addColumnName = "AddColumnName"
        case addTrailingPaddingCharacter = "AddTrailingPaddingCharacter"
        case bucketFolder = "BucketFolder"
        case bucketName = "BucketName"
        case cannedAclForObjects = "CannedAclForObjects"
        case cdcInsertsAndUpdates = "CdcInsertsAndUpdates"
        case cdcInsertsOnly = "CdcInsertsOnly"
        case cdcMaxBatchInterval = "CdcMaxBatchInterval"
        case cdcMinFileSize = "CdcMinFileSize"
        case cdcPath = "CdcPath"
        case compressionType = "CompressionType"
        case csvDelimiter = "CsvDelimiter"
        case csvNoSupValue = "CsvNoSupValue"
        case csvNullValue = "CsvNullValue"
        case csvRowDelimiter = "CsvRowDelimiter"
        case dataFormat = "DataFormat"
        case dataPageSize = "DataPageSize"
        case datePartitionDelimiter = "DatePartitionDelimiter"
        case datePartitionEnabled = "DatePartitionEnabled"
        case datePartitionSequence = "DatePartitionSequence"
        case datePartitionTimezone = "DatePartitionTimezone"
        case dictPageSizeLimit = "DictPageSizeLimit"
        case enableStatistics = "EnableStatistics"
        case encodingType = "EncodingType"
        case encryptionMode = "EncryptionMode"
        case expectedBucketOwner = "ExpectedBucketOwner"
        case externalTableDefinition = "ExternalTableDefinition"
        case ignoreHeaderRows = "IgnoreHeaderRows"
        case includeOpForFullLoad = "IncludeOpForFullLoad"
        case maxFileSize = "MaxFileSize"
        case parquetTimestampInMillisecond = "ParquetTimestampInMillisecond"
        case parquetVersion = "ParquetVersion"
        case preserveTransactions = "PreserveTransactions"
        case rfc4180 = "Rfc4180"
        case rowGroupLength = "RowGroupLength"
        case serverSideEncryptionKmsKeyId = "ServerSideEncryptionKmsKeyId"
        case serviceAccessRoleArn = "ServiceAccessRoleArn"
        case timestampColumnName = "TimestampColumnName"
        case useCsvNoSupValue = "UseCsvNoSupValue"
        case useTaskStartTimeForFullLoadTimestamp = "UseTaskStartTimeForFullLoadTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addColumnName = self.addColumnName {
            try encodeContainer.encode(addColumnName, forKey: .addColumnName)
        }
        if let addTrailingPaddingCharacter = self.addTrailingPaddingCharacter {
            try encodeContainer.encode(addTrailingPaddingCharacter, forKey: .addTrailingPaddingCharacter)
        }
        if let bucketFolder = self.bucketFolder {
            try encodeContainer.encode(bucketFolder, forKey: .bucketFolder)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let cannedAclForObjects = self.cannedAclForObjects {
            try encodeContainer.encode(cannedAclForObjects.rawValue, forKey: .cannedAclForObjects)
        }
        if let cdcInsertsAndUpdates = self.cdcInsertsAndUpdates {
            try encodeContainer.encode(cdcInsertsAndUpdates, forKey: .cdcInsertsAndUpdates)
        }
        if let cdcInsertsOnly = self.cdcInsertsOnly {
            try encodeContainer.encode(cdcInsertsOnly, forKey: .cdcInsertsOnly)
        }
        if let cdcMaxBatchInterval = self.cdcMaxBatchInterval {
            try encodeContainer.encode(cdcMaxBatchInterval, forKey: .cdcMaxBatchInterval)
        }
        if let cdcMinFileSize = self.cdcMinFileSize {
            try encodeContainer.encode(cdcMinFileSize, forKey: .cdcMinFileSize)
        }
        if let cdcPath = self.cdcPath {
            try encodeContainer.encode(cdcPath, forKey: .cdcPath)
        }
        if let compressionType = self.compressionType {
            try encodeContainer.encode(compressionType.rawValue, forKey: .compressionType)
        }
        if let csvDelimiter = self.csvDelimiter {
            try encodeContainer.encode(csvDelimiter, forKey: .csvDelimiter)
        }
        if let csvNoSupValue = self.csvNoSupValue {
            try encodeContainer.encode(csvNoSupValue, forKey: .csvNoSupValue)
        }
        if let csvNullValue = self.csvNullValue {
            try encodeContainer.encode(csvNullValue, forKey: .csvNullValue)
        }
        if let csvRowDelimiter = self.csvRowDelimiter {
            try encodeContainer.encode(csvRowDelimiter, forKey: .csvRowDelimiter)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataPageSize = self.dataPageSize {
            try encodeContainer.encode(dataPageSize, forKey: .dataPageSize)
        }
        if let datePartitionDelimiter = self.datePartitionDelimiter {
            try encodeContainer.encode(datePartitionDelimiter.rawValue, forKey: .datePartitionDelimiter)
        }
        if let datePartitionEnabled = self.datePartitionEnabled {
            try encodeContainer.encode(datePartitionEnabled, forKey: .datePartitionEnabled)
        }
        if let datePartitionSequence = self.datePartitionSequence {
            try encodeContainer.encode(datePartitionSequence.rawValue, forKey: .datePartitionSequence)
        }
        if let datePartitionTimezone = self.datePartitionTimezone {
            try encodeContainer.encode(datePartitionTimezone, forKey: .datePartitionTimezone)
        }
        if let dictPageSizeLimit = self.dictPageSizeLimit {
            try encodeContainer.encode(dictPageSizeLimit, forKey: .dictPageSizeLimit)
        }
        if let enableStatistics = self.enableStatistics {
            try encodeContainer.encode(enableStatistics, forKey: .enableStatistics)
        }
        if let encodingType = self.encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let encryptionMode = self.encryptionMode {
            try encodeContainer.encode(encryptionMode.rawValue, forKey: .encryptionMode)
        }
        if let expectedBucketOwner = self.expectedBucketOwner {
            try encodeContainer.encode(expectedBucketOwner, forKey: .expectedBucketOwner)
        }
        if let externalTableDefinition = self.externalTableDefinition {
            try encodeContainer.encode(externalTableDefinition, forKey: .externalTableDefinition)
        }
        if let ignoreHeaderRows = self.ignoreHeaderRows {
            try encodeContainer.encode(ignoreHeaderRows, forKey: .ignoreHeaderRows)
        }
        if let includeOpForFullLoad = self.includeOpForFullLoad {
            try encodeContainer.encode(includeOpForFullLoad, forKey: .includeOpForFullLoad)
        }
        if let maxFileSize = self.maxFileSize {
            try encodeContainer.encode(maxFileSize, forKey: .maxFileSize)
        }
        if let parquetTimestampInMillisecond = self.parquetTimestampInMillisecond {
            try encodeContainer.encode(parquetTimestampInMillisecond, forKey: .parquetTimestampInMillisecond)
        }
        if let parquetVersion = self.parquetVersion {
            try encodeContainer.encode(parquetVersion.rawValue, forKey: .parquetVersion)
        }
        if let preserveTransactions = self.preserveTransactions {
            try encodeContainer.encode(preserveTransactions, forKey: .preserveTransactions)
        }
        if let rfc4180 = self.rfc4180 {
            try encodeContainer.encode(rfc4180, forKey: .rfc4180)
        }
        if let rowGroupLength = self.rowGroupLength {
            try encodeContainer.encode(rowGroupLength, forKey: .rowGroupLength)
        }
        if let serverSideEncryptionKmsKeyId = self.serverSideEncryptionKmsKeyId {
            try encodeContainer.encode(serverSideEncryptionKmsKeyId, forKey: .serverSideEncryptionKmsKeyId)
        }
        if let serviceAccessRoleArn = self.serviceAccessRoleArn {
            try encodeContainer.encode(serviceAccessRoleArn, forKey: .serviceAccessRoleArn)
        }
        if let timestampColumnName = self.timestampColumnName {
            try encodeContainer.encode(timestampColumnName, forKey: .timestampColumnName)
        }
        if let useCsvNoSupValue = self.useCsvNoSupValue {
            try encodeContainer.encode(useCsvNoSupValue, forKey: .useCsvNoSupValue)
        }
        if let useTaskStartTimeForFullLoadTimestamp = self.useTaskStartTimeForFullLoadTimestamp {
            try encodeContainer.encode(useTaskStartTimeForFullLoadTimestamp, forKey: .useTaskStartTimeForFullLoadTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceAccessRoleArn)
        serviceAccessRoleArn = serviceAccessRoleArnDecoded
        let externalTableDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalTableDefinition)
        externalTableDefinition = externalTableDefinitionDecoded
        let csvRowDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvRowDelimiter)
        csvRowDelimiter = csvRowDelimiterDecoded
        let csvDelimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvDelimiter)
        csvDelimiter = csvDelimiterDecoded
        let bucketFolderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketFolder)
        bucketFolder = bucketFolderDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let compressionTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CompressionTypeValue.self, forKey: .compressionType)
        compressionType = compressionTypeDecoded
        let encryptionModeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncryptionModeValue.self, forKey: .encryptionMode)
        encryptionMode = encryptionModeDecoded
        let serverSideEncryptionKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverSideEncryptionKmsKeyId)
        serverSideEncryptionKmsKeyId = serverSideEncryptionKmsKeyIdDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DataFormatValue.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let encodingTypeDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.EncodingTypeValue.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let dictPageSizeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dictPageSizeLimit)
        dictPageSizeLimit = dictPageSizeLimitDecoded
        let rowGroupLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rowGroupLength)
        rowGroupLength = rowGroupLengthDecoded
        let dataPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataPageSize)
        dataPageSize = dataPageSizeDecoded
        let parquetVersionDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.ParquetVersionValue.self, forKey: .parquetVersion)
        parquetVersion = parquetVersionDecoded
        let enableStatisticsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableStatistics)
        enableStatistics = enableStatisticsDecoded
        let includeOpForFullLoadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOpForFullLoad)
        includeOpForFullLoad = includeOpForFullLoadDecoded
        let cdcInsertsOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsOnly)
        cdcInsertsOnly = cdcInsertsOnlyDecoded
        let timestampColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestampColumnName)
        timestampColumnName = timestampColumnNameDecoded
        let parquetTimestampInMillisecondDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parquetTimestampInMillisecond)
        parquetTimestampInMillisecond = parquetTimestampInMillisecondDecoded
        let cdcInsertsAndUpdatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cdcInsertsAndUpdates)
        cdcInsertsAndUpdates = cdcInsertsAndUpdatesDecoded
        let datePartitionEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .datePartitionEnabled)
        datePartitionEnabled = datePartitionEnabledDecoded
        let datePartitionSequenceDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionSequenceValue.self, forKey: .datePartitionSequence)
        datePartitionSequence = datePartitionSequenceDecoded
        let datePartitionDelimiterDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.DatePartitionDelimiterValue.self, forKey: .datePartitionDelimiter)
        datePartitionDelimiter = datePartitionDelimiterDecoded
        let useCsvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useCsvNoSupValue)
        useCsvNoSupValue = useCsvNoSupValueDecoded
        let csvNoSupValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNoSupValue)
        csvNoSupValue = csvNoSupValueDecoded
        let preserveTransactionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveTransactions)
        preserveTransactions = preserveTransactionsDecoded
        let cdcPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cdcPath)
        cdcPath = cdcPathDecoded
        let useTaskStartTimeForFullLoadTimestampDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useTaskStartTimeForFullLoadTimestamp)
        useTaskStartTimeForFullLoadTimestamp = useTaskStartTimeForFullLoadTimestampDecoded
        let cannedAclForObjectsDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.CannedAclForObjectsValue.self, forKey: .cannedAclForObjects)
        cannedAclForObjects = cannedAclForObjectsDecoded
        let addColumnNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addColumnName)
        addColumnName = addColumnNameDecoded
        let cdcMaxBatchIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMaxBatchInterval)
        cdcMaxBatchInterval = cdcMaxBatchIntervalDecoded
        let cdcMinFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cdcMinFileSize)
        cdcMinFileSize = cdcMinFileSizeDecoded
        let csvNullValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvNullValue)
        csvNullValue = csvNullValueDecoded
        let ignoreHeaderRowsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ignoreHeaderRows)
        ignoreHeaderRows = ignoreHeaderRowsDecoded
        let maxFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxFileSize)
        maxFileSize = maxFileSizeDecoded
        let rfc4180Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rfc4180)
        rfc4180 = rfc4180Decoded
        let datePartitionTimezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datePartitionTimezone)
        datePartitionTimezone = datePartitionTimezoneDecoded
        let addTrailingPaddingCharacterDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .addTrailingPaddingCharacter)
        addTrailingPaddingCharacter = addTrailingPaddingCharacterDecoded
        let expectedBucketOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedBucketOwner)
        expectedBucketOwner = expectedBucketOwnerDecoded
    }
}
