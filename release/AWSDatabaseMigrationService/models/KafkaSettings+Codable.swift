// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DatabaseMigrationClientTypes.KafkaSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case broker = "Broker"
        case includeControlDetails = "IncludeControlDetails"
        case includeNullAndEmpty = "IncludeNullAndEmpty"
        case includePartitionValue = "IncludePartitionValue"
        case includeTableAlterOperations = "IncludeTableAlterOperations"
        case includeTransactionDetails = "IncludeTransactionDetails"
        case messageFormat = "MessageFormat"
        case messageMaxBytes = "MessageMaxBytes"
        case noHexPrefix = "NoHexPrefix"
        case partitionIncludeSchemaTable = "PartitionIncludeSchemaTable"
        case saslPassword = "SaslPassword"
        case saslUsername = "SaslUsername"
        case securityProtocol = "SecurityProtocol"
        case sslCaCertificateArn = "SslCaCertificateArn"
        case sslClientCertificateArn = "SslClientCertificateArn"
        case sslClientKeyArn = "SslClientKeyArn"
        case sslClientKeyPassword = "SslClientKeyPassword"
        case topic = "Topic"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let broker = self.broker {
            try encodeContainer.encode(broker, forKey: .broker)
        }
        if let includeControlDetails = self.includeControlDetails {
            try encodeContainer.encode(includeControlDetails, forKey: .includeControlDetails)
        }
        if let includeNullAndEmpty = self.includeNullAndEmpty {
            try encodeContainer.encode(includeNullAndEmpty, forKey: .includeNullAndEmpty)
        }
        if let includePartitionValue = self.includePartitionValue {
            try encodeContainer.encode(includePartitionValue, forKey: .includePartitionValue)
        }
        if let includeTableAlterOperations = self.includeTableAlterOperations {
            try encodeContainer.encode(includeTableAlterOperations, forKey: .includeTableAlterOperations)
        }
        if let includeTransactionDetails = self.includeTransactionDetails {
            try encodeContainer.encode(includeTransactionDetails, forKey: .includeTransactionDetails)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let messageMaxBytes = self.messageMaxBytes {
            try encodeContainer.encode(messageMaxBytes, forKey: .messageMaxBytes)
        }
        if let noHexPrefix = self.noHexPrefix {
            try encodeContainer.encode(noHexPrefix, forKey: .noHexPrefix)
        }
        if let partitionIncludeSchemaTable = self.partitionIncludeSchemaTable {
            try encodeContainer.encode(partitionIncludeSchemaTable, forKey: .partitionIncludeSchemaTable)
        }
        if let saslPassword = self.saslPassword {
            try encodeContainer.encode(saslPassword, forKey: .saslPassword)
        }
        if let saslUsername = self.saslUsername {
            try encodeContainer.encode(saslUsername, forKey: .saslUsername)
        }
        if let securityProtocol = self.securityProtocol {
            try encodeContainer.encode(securityProtocol.rawValue, forKey: .securityProtocol)
        }
        if let sslCaCertificateArn = self.sslCaCertificateArn {
            try encodeContainer.encode(sslCaCertificateArn, forKey: .sslCaCertificateArn)
        }
        if let sslClientCertificateArn = self.sslClientCertificateArn {
            try encodeContainer.encode(sslClientCertificateArn, forKey: .sslClientCertificateArn)
        }
        if let sslClientKeyArn = self.sslClientKeyArn {
            try encodeContainer.encode(sslClientKeyArn, forKey: .sslClientKeyArn)
        }
        if let sslClientKeyPassword = self.sslClientKeyPassword {
            try encodeContainer.encode(sslClientKeyPassword, forKey: .sslClientKeyPassword)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .broker)
        broker = brokerDecoded
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.MessageFormatValue.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let includeTransactionDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTransactionDetails)
        includeTransactionDetails = includeTransactionDetailsDecoded
        let includePartitionValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includePartitionValue)
        includePartitionValue = includePartitionValueDecoded
        let partitionIncludeSchemaTableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .partitionIncludeSchemaTable)
        partitionIncludeSchemaTable = partitionIncludeSchemaTableDecoded
        let includeTableAlterOperationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTableAlterOperations)
        includeTableAlterOperations = includeTableAlterOperationsDecoded
        let includeControlDetailsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeControlDetails)
        includeControlDetails = includeControlDetailsDecoded
        let messageMaxBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageMaxBytes)
        messageMaxBytes = messageMaxBytesDecoded
        let includeNullAndEmptyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeNullAndEmpty)
        includeNullAndEmpty = includeNullAndEmptyDecoded
        let securityProtocolDecoded = try containerValues.decodeIfPresent(DatabaseMigrationClientTypes.KafkaSecurityProtocol.self, forKey: .securityProtocol)
        securityProtocol = securityProtocolDecoded
        let sslClientCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientCertificateArn)
        sslClientCertificateArn = sslClientCertificateArnDecoded
        let sslClientKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyArn)
        sslClientKeyArn = sslClientKeyArnDecoded
        let sslClientKeyPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslClientKeyPassword)
        sslClientKeyPassword = sslClientKeyPasswordDecoded
        let sslCaCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sslCaCertificateArn)
        sslCaCertificateArn = sslCaCertificateArnDecoded
        let saslUsernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslUsername)
        saslUsername = saslUsernameDecoded
        let saslPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .saslPassword)
        saslPassword = saslPasswordDecoded
        let noHexPrefixDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noHexPrefix)
        noHexPrefix = noHexPrefixDecoded
    }
}
