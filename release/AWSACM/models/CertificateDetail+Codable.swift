// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AcmClientTypes.CertificateDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case domainValidationOptions = "DomainValidationOptions"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case failureReason = "FailureReason"
        case importedAt = "ImportedAt"
        case inUseBy = "InUseBy"
        case issuedAt = "IssuedAt"
        case issuer = "Issuer"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case options = "Options"
        case renewalEligibility = "RenewalEligibility"
        case renewalSummary = "RenewalSummary"
        case revocationReason = "RevocationReason"
        case revokedAt = "RevokedAt"
        case serial = "Serial"
        case signatureAlgorithm = "SignatureAlgorithm"
        case status = "Status"
        case subject = "Subject"
        case subjectAlternativeNames = "SubjectAlternativeNames"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateAuthorityArn = self.certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainValidationOptions = domainValidationOptions {
            var domainValidationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domainValidationOptions)
            for domainvalidationlist0 in domainValidationOptions {
                try domainValidationOptionsContainer.encode(domainvalidationlist0)
            }
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for extendedkeyusagelist0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(extendedkeyusagelist0)
            }
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason.rawValue, forKey: .failureReason)
        }
        if let importedAt = self.importedAt {
            try encodeContainer.encode(importedAt.timeIntervalSince1970, forKey: .importedAt)
        }
        if let inUseBy = inUseBy {
            var inUseByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inUseBy)
            for inuselist0 in inUseBy {
                try inUseByContainer.encode(inuselist0)
            }
        }
        if let issuedAt = self.issuedAt {
            try encodeContainer.encode(issuedAt.timeIntervalSince1970, forKey: .issuedAt)
        }
        if let issuer = self.issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
        if let keyAlgorithm = self.keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm.rawValue, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for keyusagelist0 in keyUsages {
                try keyUsagesContainer.encode(keyusagelist0)
            }
        }
        if let notAfter = self.notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = self.notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let options = self.options {
            try encodeContainer.encode(options, forKey: .options)
        }
        if let renewalEligibility = self.renewalEligibility {
            try encodeContainer.encode(renewalEligibility.rawValue, forKey: .renewalEligibility)
        }
        if let renewalSummary = self.renewalSummary {
            try encodeContainer.encode(renewalSummary, forKey: .renewalSummary)
        }
        if let revocationReason = self.revocationReason {
            try encodeContainer.encode(revocationReason.rawValue, forKey: .revocationReason)
        }
        if let revokedAt = self.revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let serial = self.serial {
            try encodeContainer.encode(serial, forKey: .serial)
        }
        if let signatureAlgorithm = self.signatureAlgorithm {
            try encodeContainer.encode(signatureAlgorithm, forKey: .signatureAlgorithm)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let subjectAlternativeNames = subjectAlternativeNames {
            var subjectAlternativeNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNames)
            for domainlist0 in subjectAlternativeNames {
                try subjectAlternativeNamesContainer.encode(domainlist0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let subjectAlternativeNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subjectAlternativeNames)
        var subjectAlternativeNamesDecoded0:[Swift.String]? = nil
        if let subjectAlternativeNamesContainer = subjectAlternativeNamesContainer {
            subjectAlternativeNamesDecoded0 = [Swift.String]()
            for string0 in subjectAlternativeNamesContainer {
                if let string0 = string0 {
                    subjectAlternativeNamesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNames = subjectAlternativeNamesDecoded0
        let domainValidationOptionsContainer = try containerValues.decodeIfPresent([AcmClientTypes.DomainValidation?].self, forKey: .domainValidationOptions)
        var domainValidationOptionsDecoded0:[AcmClientTypes.DomainValidation]? = nil
        if let domainValidationOptionsContainer = domainValidationOptionsContainer {
            domainValidationOptionsDecoded0 = [AcmClientTypes.DomainValidation]()
            for structure0 in domainValidationOptionsContainer {
                if let structure0 = structure0 {
                    domainValidationOptionsDecoded0?.append(structure0)
                }
            }
        }
        domainValidationOptions = domainValidationOptionsDecoded0
        let serialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serial)
        serial = serialDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuer)
        issuer = issuerDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AcmClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
        let revocationReasonDecoded = try containerValues.decodeIfPresent(AcmClientTypes.RevocationReason.self, forKey: .revocationReason)
        revocationReason = revocationReasonDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(AcmClientTypes.KeyAlgorithm.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let inUseByContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inUseBy)
        var inUseByDecoded0:[Swift.String]? = nil
        if let inUseByContainer = inUseByContainer {
            inUseByDecoded0 = [Swift.String]()
            for string0 in inUseByContainer {
                if let string0 = string0 {
                    inUseByDecoded0?.append(string0)
                }
            }
        }
        inUseBy = inUseByDecoded0
        let failureReasonDecoded = try containerValues.decodeIfPresent(AcmClientTypes.FailureReason.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AcmClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let renewalSummaryDecoded = try containerValues.decodeIfPresent(AcmClientTypes.RenewalSummary.self, forKey: .renewalSummary)
        renewalSummary = renewalSummaryDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([AcmClientTypes.KeyUsage?].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[AcmClientTypes.KeyUsage]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [AcmClientTypes.KeyUsage]()
            for structure0 in keyUsagesContainer {
                if let structure0 = structure0 {
                    keyUsagesDecoded0?.append(structure0)
                }
            }
        }
        keyUsages = keyUsagesDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([AcmClientTypes.ExtendedKeyUsage?].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[AcmClientTypes.ExtendedKeyUsage]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [AcmClientTypes.ExtendedKeyUsage]()
            for structure0 in extendedKeyUsagesContainer {
                if let structure0 = structure0 {
                    extendedKeyUsagesDecoded0?.append(structure0)
                }
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(AcmClientTypes.RenewalEligibility.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let optionsDecoded = try containerValues.decodeIfPresent(AcmClientTypes.CertificateOptions.self, forKey: .options)
        options = optionsDecoded
    }
}
