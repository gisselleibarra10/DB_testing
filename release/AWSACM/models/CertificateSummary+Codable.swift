// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AcmClientTypes.CertificateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case createdAt = "CreatedAt"
        case domainName = "DomainName"
        case exported = "Exported"
        case extendedKeyUsages = "ExtendedKeyUsages"
        case hasAdditionalSubjectAlternativeNames = "HasAdditionalSubjectAlternativeNames"
        case importedAt = "ImportedAt"
        case inUse = "InUse"
        case issuedAt = "IssuedAt"
        case keyAlgorithm = "KeyAlgorithm"
        case keyUsages = "KeyUsages"
        case notAfter = "NotAfter"
        case notBefore = "NotBefore"
        case renewalEligibility = "RenewalEligibility"
        case revokedAt = "RevokedAt"
        case status = "Status"
        case subjectAlternativeNameSummaries = "SubjectAlternativeNameSummaries"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let exported = self.exported {
            try encodeContainer.encode(exported, forKey: .exported)
        }
        if let extendedKeyUsages = extendedKeyUsages {
            var extendedKeyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .extendedKeyUsages)
            for extendedkeyusagenames0 in extendedKeyUsages {
                try extendedKeyUsagesContainer.encode(extendedkeyusagenames0.rawValue)
            }
        }
        if let hasAdditionalSubjectAlternativeNames = self.hasAdditionalSubjectAlternativeNames {
            try encodeContainer.encode(hasAdditionalSubjectAlternativeNames, forKey: .hasAdditionalSubjectAlternativeNames)
        }
        if let importedAt = self.importedAt {
            try encodeContainer.encode(importedAt.timeIntervalSince1970, forKey: .importedAt)
        }
        if let inUse = self.inUse {
            try encodeContainer.encode(inUse, forKey: .inUse)
        }
        if let issuedAt = self.issuedAt {
            try encodeContainer.encode(issuedAt.timeIntervalSince1970, forKey: .issuedAt)
        }
        if let keyAlgorithm = self.keyAlgorithm {
            try encodeContainer.encode(keyAlgorithm.rawValue, forKey: .keyAlgorithm)
        }
        if let keyUsages = keyUsages {
            var keyUsagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keyUsages)
            for keyusagenames0 in keyUsages {
                try keyUsagesContainer.encode(keyusagenames0.rawValue)
            }
        }
        if let notAfter = self.notAfter {
            try encodeContainer.encode(notAfter.timeIntervalSince1970, forKey: .notAfter)
        }
        if let notBefore = self.notBefore {
            try encodeContainer.encode(notBefore.timeIntervalSince1970, forKey: .notBefore)
        }
        if let renewalEligibility = self.renewalEligibility {
            try encodeContainer.encode(renewalEligibility.rawValue, forKey: .renewalEligibility)
        }
        if let revokedAt = self.revokedAt {
            try encodeContainer.encode(revokedAt.timeIntervalSince1970, forKey: .revokedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subjectAlternativeNameSummaries = subjectAlternativeNameSummaries {
            var subjectAlternativeNameSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subjectAlternativeNameSummaries)
            for domainlist0 in subjectAlternativeNameSummaries {
                try subjectAlternativeNameSummariesContainer.encode(domainlist0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let subjectAlternativeNameSummariesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subjectAlternativeNameSummaries)
        var subjectAlternativeNameSummariesDecoded0:[Swift.String]? = nil
        if let subjectAlternativeNameSummariesContainer = subjectAlternativeNameSummariesContainer {
            subjectAlternativeNameSummariesDecoded0 = [Swift.String]()
            for string0 in subjectAlternativeNameSummariesContainer {
                if let string0 = string0 {
                    subjectAlternativeNameSummariesDecoded0?.append(string0)
                }
            }
        }
        subjectAlternativeNameSummaries = subjectAlternativeNameSummariesDecoded0
        let hasAdditionalSubjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasAdditionalSubjectAlternativeNames)
        hasAdditionalSubjectAlternativeNames = hasAdditionalSubjectAlternativeNamesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AcmClientTypes.CertificateStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AcmClientTypes.CertificateType.self, forKey: .type)
        type = typeDecoded
        let keyAlgorithmDecoded = try containerValues.decodeIfPresent(AcmClientTypes.KeyAlgorithm.self, forKey: .keyAlgorithm)
        keyAlgorithm = keyAlgorithmDecoded
        let keyUsagesContainer = try containerValues.decodeIfPresent([AcmClientTypes.KeyUsageName?].self, forKey: .keyUsages)
        var keyUsagesDecoded0:[AcmClientTypes.KeyUsageName]? = nil
        if let keyUsagesContainer = keyUsagesContainer {
            keyUsagesDecoded0 = [AcmClientTypes.KeyUsageName]()
            for enum0 in keyUsagesContainer {
                if let enum0 = enum0 {
                    keyUsagesDecoded0?.append(enum0)
                }
            }
        }
        keyUsages = keyUsagesDecoded0
        let extendedKeyUsagesContainer = try containerValues.decodeIfPresent([AcmClientTypes.ExtendedKeyUsageName?].self, forKey: .extendedKeyUsages)
        var extendedKeyUsagesDecoded0:[AcmClientTypes.ExtendedKeyUsageName]? = nil
        if let extendedKeyUsagesContainer = extendedKeyUsagesContainer {
            extendedKeyUsagesDecoded0 = [AcmClientTypes.ExtendedKeyUsageName]()
            for enum0 in extendedKeyUsagesContainer {
                if let enum0 = enum0 {
                    extendedKeyUsagesDecoded0?.append(enum0)
                }
            }
        }
        extendedKeyUsages = extendedKeyUsagesDecoded0
        let inUseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .inUse)
        inUse = inUseDecoded
        let exportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exported)
        exported = exportedDecoded
        let renewalEligibilityDecoded = try containerValues.decodeIfPresent(AcmClientTypes.RenewalEligibility.self, forKey: .renewalEligibility)
        renewalEligibility = renewalEligibilityDecoded
        let notBeforeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notBefore)
        notBefore = notBeforeDecoded
        let notAfterDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .notAfter)
        notAfter = notAfterDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let issuedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .issuedAt)
        issuedAt = issuedAtDecoded
        let importedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .importedAt)
        importedAt = importedAtDecoded
        let revokedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .revokedAt)
        revokedAt = revokedAtDecoded
    }
}
