// Code generated by smithy-swift-codegen. DO NOT EDIT!



extension ApplicationAutoScalingClientTypes {
    /// Represents a step scaling policy configuration to use with Application Auto Scaling.
    public struct StepScalingPolicyConfiguration: Swift.Equatable {
        /// Specifies how the ScalingAdjustment value in a [StepAdjustment](https://docs.aws.amazon.com/autoscaling/application/APIReference/API_StepAdjustment.html) is interpreted (for example, an absolute number or a percentage). The valid values are ChangeInCapacity, ExactCapacity, and PercentChangeInCapacity. AdjustmentType is required if you are adding a new step scaling policy configuration.
        public var adjustmentType: ApplicationAutoScalingClientTypes.AdjustmentType?
        /// The amount of time, in seconds, to wait for a previous scaling activity to take effect. With scale-out policies, the intention is to continuously (but not excessively) scale out. After Application Auto Scaling successfully scales out using a step scaling policy, it starts to calculate the cooldown time. The scaling policy won't increase the desired capacity again unless either a larger scale out is triggered or the cooldown period ends. While the cooldown period is in effect, capacity added by the initiating scale-out activity is calculated as part of the desired capacity for the next scale-out activity. For example, when an alarm triggers a step scaling policy to increase the capacity by 2, the scaling activity completes successfully, and a cooldown period starts. If the alarm triggers again during the cooldown period but at a more aggressive step adjustment of 3, the previous increase of 2 is considered part of the current capacity. Therefore, only 1 is added to the capacity. With scale-in policies, the intention is to scale in conservatively to protect your applicationâ€™s availability, so scale-in activities are blocked until the cooldown period has expired. However, if another alarm triggers a scale-out activity during the cooldown period after a scale-in activity, Application Auto Scaling scales out the target immediately. In this case, the cooldown period for the scale-in activity stops and doesn't complete. Application Auto Scaling provides a default value of 600 for Amazon ElastiCache replication groups and a default value of 300 for the following scalable targets:
        ///
        /// * AppStream 2.0 fleets
        ///
        /// * Aurora DB clusters
        ///
        /// * ECS services
        ///
        /// * EMR clusters
        ///
        /// * Neptune clusters
        ///
        /// * SageMaker endpoint variants
        ///
        /// * Spot Fleets
        ///
        /// * Custom resources
        ///
        ///
        /// For all other scalable targets, the default value is 0:
        ///
        /// * Amazon Comprehend document classification and entity recognizer endpoints
        ///
        /// * DynamoDB tables and global secondary indexes
        ///
        /// * Amazon Keyspaces tables
        ///
        /// * Lambda provisioned concurrency
        ///
        /// * Amazon MSK broker storage
        public var cooldown: Swift.Int?
        /// The aggregation type for the CloudWatch metrics. Valid values are Minimum, Maximum, and Average. If the aggregation type is null, the value is treated as Average.
        public var metricAggregationType: ApplicationAutoScalingClientTypes.MetricAggregationType?
        /// The minimum value to scale by when the adjustment type is PercentChangeInCapacity. For example, suppose that you create a step scaling policy to scale out an Amazon ECS service by 25 percent and you specify a MinAdjustmentMagnitude of 2. If the service has 4 tasks and the scaling policy is performed, 25 percent of 4 is 1. However, because you specified a MinAdjustmentMagnitude of 2, Application Auto Scaling scales out the service by 2 tasks.
        public var minAdjustmentMagnitude: Swift.Int?
        /// A set of adjustments that enable you to scale based on the size of the alarm breach. At least one step adjustment is required if you are adding a new step scaling policy configuration.
        public var stepAdjustments: [ApplicationAutoScalingClientTypes.StepAdjustment]?

        public init (
            adjustmentType: ApplicationAutoScalingClientTypes.AdjustmentType? = nil,
            cooldown: Swift.Int? = nil,
            metricAggregationType: ApplicationAutoScalingClientTypes.MetricAggregationType? = nil,
            minAdjustmentMagnitude: Swift.Int? = nil,
            stepAdjustments: [ApplicationAutoScalingClientTypes.StepAdjustment]? = nil
        )
        {
            self.adjustmentType = adjustmentType
            self.cooldown = cooldown
            self.metricAggregationType = metricAggregationType
            self.minAdjustmentMagnitude = minAdjustmentMagnitude
            self.stepAdjustments = stepAdjustments
        }
    }

}
