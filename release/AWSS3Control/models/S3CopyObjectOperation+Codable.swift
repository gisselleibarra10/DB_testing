// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension S3ControlClientTypes.S3CopyObjectOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlGrants = "AccessControlGrants"
        case bucketKeyEnabled = "BucketKeyEnabled"
        case cannedAccessControlList = "CannedAccessControlList"
        case checksumAlgorithm = "ChecksumAlgorithm"
        case metadataDirective = "MetadataDirective"
        case modifiedSinceConstraint = "ModifiedSinceConstraint"
        case newObjectMetadata = "NewObjectMetadata"
        case newObjectTagging = "NewObjectTagging"
        case objectLockLegalHoldStatus = "ObjectLockLegalHoldStatus"
        case objectLockMode = "ObjectLockMode"
        case objectLockRetainUntilDate = "ObjectLockRetainUntilDate"
        case redirectLocation = "RedirectLocation"
        case requesterPays = "RequesterPays"
        case sSEAwsKmsKeyId = "SSEAwsKmsKeyId"
        case storageClass = "StorageClass"
        case targetKeyPrefix = "TargetKeyPrefix"
        case targetResource = "TargetResource"
        case unModifiedSinceConstraint = "UnModifiedSinceConstraint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let accessControlGrants = accessControlGrants {
            var accessControlGrantsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AccessControlGrants"))
            for s3grant0 in accessControlGrants {
                try accessControlGrantsContainer.encode(s3grant0, forKey: ClientRuntime.Key("member"))
            }
        }
        if bucketKeyEnabled != false {
            try container.encode(bucketKeyEnabled, forKey: ClientRuntime.Key("BucketKeyEnabled"))
        }
        if let cannedAccessControlList = cannedAccessControlList {
            try container.encode(cannedAccessControlList, forKey: ClientRuntime.Key("CannedAccessControlList"))
        }
        if let checksumAlgorithm = checksumAlgorithm {
            try container.encode(checksumAlgorithm, forKey: ClientRuntime.Key("ChecksumAlgorithm"))
        }
        if let metadataDirective = metadataDirective {
            try container.encode(metadataDirective, forKey: ClientRuntime.Key("MetadataDirective"))
        }
        if let modifiedSinceConstraint = modifiedSinceConstraint {
            try container.encode(ClientRuntime.TimestampWrapper(modifiedSinceConstraint, format: .dateTime), forKey: ClientRuntime.Key("ModifiedSinceConstraint"))
        }
        if let newObjectMetadata = newObjectMetadata {
            try container.encode(newObjectMetadata, forKey: ClientRuntime.Key("NewObjectMetadata"))
        }
        if let newObjectTagging = newObjectTagging {
            var newObjectTaggingContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NewObjectTagging"))
            for s3tag0 in newObjectTagging {
                try newObjectTaggingContainer.encode(s3tag0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let objectLockLegalHoldStatus = objectLockLegalHoldStatus {
            try container.encode(objectLockLegalHoldStatus, forKey: ClientRuntime.Key("ObjectLockLegalHoldStatus"))
        }
        if let objectLockMode = objectLockMode {
            try container.encode(objectLockMode, forKey: ClientRuntime.Key("ObjectLockMode"))
        }
        if let objectLockRetainUntilDate = objectLockRetainUntilDate {
            try container.encode(ClientRuntime.TimestampWrapper(objectLockRetainUntilDate, format: .dateTime), forKey: ClientRuntime.Key("ObjectLockRetainUntilDate"))
        }
        if let redirectLocation = redirectLocation {
            try container.encode(redirectLocation, forKey: ClientRuntime.Key("RedirectLocation"))
        }
        if requesterPays != false {
            try container.encode(requesterPays, forKey: ClientRuntime.Key("RequesterPays"))
        }
        if let sSEAwsKmsKeyId = sSEAwsKmsKeyId {
            try container.encode(sSEAwsKmsKeyId, forKey: ClientRuntime.Key("SSEAwsKmsKeyId"))
        }
        if let storageClass = storageClass {
            try container.encode(storageClass, forKey: ClientRuntime.Key("StorageClass"))
        }
        if let targetKeyPrefix = targetKeyPrefix {
            try container.encode(targetKeyPrefix, forKey: ClientRuntime.Key("TargetKeyPrefix"))
        }
        if let targetResource = targetResource {
            try container.encode(targetResource, forKey: ClientRuntime.Key("TargetResource"))
        }
        if let unModifiedSinceConstraint = unModifiedSinceConstraint {
            try container.encode(ClientRuntime.TimestampWrapper(unModifiedSinceConstraint, format: .dateTime), forKey: ClientRuntime.Key("UnModifiedSinceConstraint"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetResource)
        targetResource = targetResourceDecoded
        let cannedAccessControlListDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3CannedAccessControlList.self, forKey: .cannedAccessControlList)
        cannedAccessControlList = cannedAccessControlListDecoded
        if containerValues.contains(.accessControlGrants) {
            struct KeyVal0{struct member{}}
            let accessControlGrantsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .accessControlGrants)
            if let accessControlGrantsWrappedContainer = accessControlGrantsWrappedContainer {
                let accessControlGrantsContainer = try accessControlGrantsWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Grant].self, forKey: .member)
                var accessControlGrantsBuffer:[S3ControlClientTypes.S3Grant]? = nil
                if let accessControlGrantsContainer = accessControlGrantsContainer {
                    accessControlGrantsBuffer = [S3ControlClientTypes.S3Grant]()
                    for structureContainer0 in accessControlGrantsContainer {
                        accessControlGrantsBuffer?.append(structureContainer0)
                    }
                }
                accessControlGrants = accessControlGrantsBuffer
            } else {
                accessControlGrants = []
            }
        } else {
            accessControlGrants = nil
        }
        let metadataDirectiveDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3MetadataDirective.self, forKey: .metadataDirective)
        metadataDirective = metadataDirectiveDecoded
        let modifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifiedSinceConstraint)
        var modifiedSinceConstraintBuffer:ClientRuntime.Date? = nil
        if let modifiedSinceConstraintDecoded = modifiedSinceConstraintDecoded {
            modifiedSinceConstraintBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(modifiedSinceConstraintDecoded, format: .dateTime)
        }
        modifiedSinceConstraint = modifiedSinceConstraintBuffer
        let newObjectMetadataDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectMetadata.self, forKey: .newObjectMetadata)
        newObjectMetadata = newObjectMetadataDecoded
        if containerValues.contains(.newObjectTagging) {
            struct KeyVal0{struct member{}}
            let newObjectTaggingWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .newObjectTagging)
            if let newObjectTaggingWrappedContainer = newObjectTaggingWrappedContainer {
                let newObjectTaggingContainer = try newObjectTaggingWrappedContainer.decodeIfPresent([S3ControlClientTypes.S3Tag].self, forKey: .member)
                var newObjectTaggingBuffer:[S3ControlClientTypes.S3Tag]? = nil
                if let newObjectTaggingContainer = newObjectTaggingContainer {
                    newObjectTaggingBuffer = [S3ControlClientTypes.S3Tag]()
                    for structureContainer0 in newObjectTaggingContainer {
                        newObjectTaggingBuffer?.append(structureContainer0)
                    }
                }
                newObjectTagging = newObjectTaggingBuffer
            } else {
                newObjectTagging = []
            }
        } else {
            newObjectTagging = nil
        }
        let redirectLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectLocation)
        redirectLocation = redirectLocationDecoded
        let requesterPaysDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requesterPays)
        requesterPays = requesterPaysDecoded
        let storageClassDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3StorageClass.self, forKey: .storageClass)
        storageClass = storageClassDecoded
        let unModifiedSinceConstraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unModifiedSinceConstraint)
        var unModifiedSinceConstraintBuffer:ClientRuntime.Date? = nil
        if let unModifiedSinceConstraintDecoded = unModifiedSinceConstraintDecoded {
            unModifiedSinceConstraintBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(unModifiedSinceConstraintDecoded, format: .dateTime)
        }
        unModifiedSinceConstraint = unModifiedSinceConstraintBuffer
        let sSEAwsKmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sSEAwsKmsKeyId)
        sSEAwsKmsKeyId = sSEAwsKmsKeyIdDecoded
        let targetKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetKeyPrefix)
        targetKeyPrefix = targetKeyPrefixDecoded
        let objectLockLegalHoldStatusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockLegalHoldStatus.self, forKey: .objectLockLegalHoldStatus)
        objectLockLegalHoldStatus = objectLockLegalHoldStatusDecoded
        let objectLockModeDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ObjectLockMode.self, forKey: .objectLockMode)
        objectLockMode = objectLockModeDecoded
        let objectLockRetainUntilDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectLockRetainUntilDate)
        var objectLockRetainUntilDateBuffer:ClientRuntime.Date? = nil
        if let objectLockRetainUntilDateDecoded = objectLockRetainUntilDateDecoded {
            objectLockRetainUntilDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(objectLockRetainUntilDateDecoded, format: .dateTime)
        }
        objectLockRetainUntilDate = objectLockRetainUntilDateBuffer
        let bucketKeyEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .bucketKeyEnabled)
        bucketKeyEnabled = bucketKeyEnabledDecoded
        let checksumAlgorithmDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3ChecksumAlgorithm.self, forKey: .checksumAlgorithm)
        checksumAlgorithm = checksumAlgorithmDecoded
    }
}
