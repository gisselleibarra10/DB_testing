// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetAccessPointOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let bucket: Swift.String?
    let networkOrigin: S3ControlClientTypes.NetworkOrigin?
    let vpcConfiguration: S3ControlClientTypes.VpcConfiguration?
    let publicAccessBlockConfiguration: S3ControlClientTypes.PublicAccessBlockConfiguration?
    let creationDate: ClientRuntime.Date?
    let alias: Swift.String?
    let accessPointArn: Swift.String?
    let endpoints: [Swift.String:Swift.String]?
}

extension GetAccessPointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case alias = "Alias"
        case bucket = "Bucket"
        case creationDate = "CreationDate"
        case endpoints = "Endpoints"
        case name = "Name"
        case networkOrigin = "NetworkOrigin"
        case publicAccessBlockConfiguration = "PublicAccessBlockConfiguration"
        case vpcConfiguration = "VpcConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.NetworkOrigin.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
        let vpcConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.VpcConfiguration.self, forKey: .vpcConfiguration)
        vpcConfiguration = vpcConfigurationDecoded
        let publicAccessBlockConfigurationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.PublicAccessBlockConfiguration.self, forKey: .publicAccessBlockConfiguration)
        publicAccessBlockConfiguration = publicAccessBlockConfigurationDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        var creationDateBuffer:ClientRuntime.Date? = nil
        if let creationDateDecoded = creationDateDecoded {
            creationDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(creationDateDecoded, format: .dateTime)
        }
        creationDate = creationDateBuffer
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        if containerValues.contains(.endpoints) {
            struct KeyVal0{struct key{}; struct value{}}
            let endpointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: ClientRuntime.MapEntry<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .endpoints)
            if let endpointsWrappedContainer = endpointsWrappedContainer {
                let endpointsContainer = try endpointsWrappedContainer.decodeIfPresent([ClientRuntime.MapKeyValue<Swift.String, Swift.String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var endpointsBuffer: [Swift.String:Swift.String]? = nil
                if let endpointsContainer = endpointsContainer {
                    endpointsBuffer = [Swift.String:Swift.String]()
                    for stringContainer0 in endpointsContainer {
                        endpointsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                endpoints = endpointsBuffer
            } else {
                endpoints = [:]
            }
        } else {
            endpoints = nil
        }
    }
}
