// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension S3ControlClientTypes.JobDescriptor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case confirmationRequired = "ConfirmationRequired"
        case creationTime = "CreationTime"
        case description = "Description"
        case failureReasons = "FailureReasons"
        case generatedManifestDescriptor = "GeneratedManifestDescriptor"
        case jobArn = "JobArn"
        case jobId = "JobId"
        case manifest = "Manifest"
        case manifestGenerator = "ManifestGenerator"
        case operation = "Operation"
        case priority = "Priority"
        case progressSummary = "ProgressSummary"
        case report = "Report"
        case roleArn = "RoleArn"
        case status = "Status"
        case statusUpdateReason = "StatusUpdateReason"
        case suspendedCause = "SuspendedCause"
        case suspendedDate = "SuspendedDate"
        case terminationDate = "TerminationDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://awss3control.amazonaws.com/doc/2018-08-20/", forKey: ClientRuntime.Key("xmlns"))
        }
        if let confirmationRequired = confirmationRequired {
            try container.encode(confirmationRequired, forKey: ClientRuntime.Key("ConfirmationRequired"))
        }
        if let creationTime = creationTime {
            try container.encode(ClientRuntime.TimestampWrapper(creationTime, format: .dateTime), forKey: ClientRuntime.Key("CreationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let failureReasons = failureReasons {
            var failureReasonsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("FailureReasons"))
            for jobfailure0 in failureReasons {
                try failureReasonsContainer.encode(jobfailure0, forKey: ClientRuntime.Key("member"))
            }
        }
        if let generatedManifestDescriptor = generatedManifestDescriptor {
            try container.encode(generatedManifestDescriptor, forKey: ClientRuntime.Key("GeneratedManifestDescriptor"))
        }
        if let jobArn = jobArn {
            try container.encode(jobArn, forKey: ClientRuntime.Key("JobArn"))
        }
        if let jobId = jobId {
            try container.encode(jobId, forKey: ClientRuntime.Key("JobId"))
        }
        if let manifest = manifest {
            try container.encode(manifest, forKey: ClientRuntime.Key("Manifest"))
        }
        if let manifestGenerator = manifestGenerator {
            try container.encode(manifestGenerator, forKey: ClientRuntime.Key("ManifestGenerator"))
        }
        if let operation = operation {
            try container.encode(operation, forKey: ClientRuntime.Key("Operation"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: ClientRuntime.Key("Priority"))
        }
        if let progressSummary = progressSummary {
            try container.encode(progressSummary, forKey: ClientRuntime.Key("ProgressSummary"))
        }
        if let report = report {
            try container.encode(report, forKey: ClientRuntime.Key("Report"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: ClientRuntime.Key("RoleArn"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
        if let statusUpdateReason = statusUpdateReason {
            try container.encode(statusUpdateReason, forKey: ClientRuntime.Key("StatusUpdateReason"))
        }
        if let suspendedCause = suspendedCause {
            try container.encode(suspendedCause, forKey: ClientRuntime.Key("SuspendedCause"))
        }
        if let suspendedDate = suspendedDate {
            try container.encode(ClientRuntime.TimestampWrapper(suspendedDate, format: .dateTime), forKey: ClientRuntime.Key("SuspendedDate"))
        }
        if let terminationDate = terminationDate {
            try container.encode(ClientRuntime.TimestampWrapper(terminationDate, format: .dateTime), forKey: ClientRuntime.Key("TerminationDate"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let confirmationRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .confirmationRequired)
        confirmationRequired = confirmationRequiredDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let jobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobArn)
        jobArn = jobArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let manifestDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifest.self, forKey: .manifest)
        manifest = manifestDecoded
        let operationDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobOperation.self, forKey: .operation)
        operation = operationDecoded
        let priorityDecoded = try containerValues.decode(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let progressSummaryDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobProgressSummary.self, forKey: .progressSummary)
        progressSummary = progressSummaryDecoded
        let statusUpdateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusUpdateReason)
        statusUpdateReason = statusUpdateReasonDecoded
        if containerValues.contains(.failureReasons) {
            struct KeyVal0{struct member{}}
            let failureReasonsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .failureReasons)
            if let failureReasonsWrappedContainer = failureReasonsWrappedContainer {
                let failureReasonsContainer = try failureReasonsWrappedContainer.decodeIfPresent([S3ControlClientTypes.JobFailure].self, forKey: .member)
                var failureReasonsBuffer:[S3ControlClientTypes.JobFailure]? = nil
                if let failureReasonsContainer = failureReasonsContainer {
                    failureReasonsBuffer = [S3ControlClientTypes.JobFailure]()
                    for structureContainer0 in failureReasonsContainer {
                        failureReasonsBuffer?.append(structureContainer0)
                    }
                }
                failureReasons = failureReasonsBuffer
            } else {
                failureReasons = []
            }
        } else {
            failureReasons = nil
        }
        let reportDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobReport.self, forKey: .report)
        report = reportDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        var creationTimeBuffer:ClientRuntime.Date? = nil
        if let creationTimeDecoded = creationTimeDecoded {
            creationTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(creationTimeDecoded, format: .dateTime)
        }
        creationTime = creationTimeBuffer
        let terminationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terminationDate)
        var terminationDateBuffer:ClientRuntime.Date? = nil
        if let terminationDateDecoded = terminationDateDecoded {
            terminationDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(terminationDateDecoded, format: .dateTime)
        }
        terminationDate = terminationDateBuffer
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let suspendedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suspendedDate)
        var suspendedDateBuffer:ClientRuntime.Date? = nil
        if let suspendedDateDecoded = suspendedDateDecoded {
            suspendedDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(suspendedDateDecoded, format: .dateTime)
        }
        suspendedDate = suspendedDateBuffer
        let suspendedCauseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suspendedCause)
        suspendedCause = suspendedCauseDecoded
        let manifestGeneratorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.JobManifestGenerator.self, forKey: .manifestGenerator)
        manifestGenerator = manifestGeneratorDecoded
        let generatedManifestDescriptorDecoded = try containerValues.decodeIfPresent(S3ControlClientTypes.S3GeneratedManifestDescriptor.self, forKey: .generatedManifestDescriptor)
        generatedManifestDescriptor = generatedManifestDescriptorDecoded
    }
}
