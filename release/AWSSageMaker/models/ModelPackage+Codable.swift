// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SageMakerClientTypes.ModelPackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInferenceSpecifications = "AdditionalInferenceSpecifications"
        case approvalDescription = "ApprovalDescription"
        case certifyForMarketplace = "CertifyForMarketplace"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case customerMetadataProperties = "CustomerMetadataProperties"
        case domain = "Domain"
        case driftCheckBaselines = "DriftCheckBaselines"
        case inferenceSpecification = "InferenceSpecification"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedTime = "LastModifiedTime"
        case metadataProperties = "MetadataProperties"
        case modelApprovalStatus = "ModelApprovalStatus"
        case modelMetrics = "ModelMetrics"
        case modelPackageArn = "ModelPackageArn"
        case modelPackageDescription = "ModelPackageDescription"
        case modelPackageGroupName = "ModelPackageGroupName"
        case modelPackageName = "ModelPackageName"
        case modelPackageStatus = "ModelPackageStatus"
        case modelPackageStatusDetails = "ModelPackageStatusDetails"
        case modelPackageVersion = "ModelPackageVersion"
        case samplePayloadUrl = "SamplePayloadUrl"
        case sourceAlgorithmSpecification = "SourceAlgorithmSpecification"
        case tags = "Tags"
        case task = "Task"
        case validationSpecification = "ValidationSpecification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInferenceSpecifications = additionalInferenceSpecifications {
            var additionalInferenceSpecificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalInferenceSpecifications)
            for additionalinferencespecifications0 in additionalInferenceSpecifications {
                try additionalInferenceSpecificationsContainer.encode(additionalinferencespecifications0)
            }
        }
        if let approvalDescription = self.approvalDescription {
            try encodeContainer.encode(approvalDescription, forKey: .approvalDescription)
        }
        if certifyForMarketplace != false {
            try encodeContainer.encode(certifyForMarketplace, forKey: .certifyForMarketplace)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let customerMetadataProperties = customerMetadataProperties {
            var customerMetadataPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customerMetadataProperties)
            for (dictKey0, customermetadatamap0) in customerMetadataProperties {
                try customerMetadataPropertiesContainer.encode(customermetadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let driftCheckBaselines = self.driftCheckBaselines {
            try encodeContainer.encode(driftCheckBaselines, forKey: .driftCheckBaselines)
        }
        if let inferenceSpecification = self.inferenceSpecification {
            try encodeContainer.encode(inferenceSpecification, forKey: .inferenceSpecification)
        }
        if let lastModifiedBy = self.lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = self.lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let metadataProperties = self.metadataProperties {
            try encodeContainer.encode(metadataProperties, forKey: .metadataProperties)
        }
        if let modelApprovalStatus = self.modelApprovalStatus {
            try encodeContainer.encode(modelApprovalStatus.rawValue, forKey: .modelApprovalStatus)
        }
        if let modelMetrics = self.modelMetrics {
            try encodeContainer.encode(modelMetrics, forKey: .modelMetrics)
        }
        if let modelPackageArn = self.modelPackageArn {
            try encodeContainer.encode(modelPackageArn, forKey: .modelPackageArn)
        }
        if let modelPackageDescription = self.modelPackageDescription {
            try encodeContainer.encode(modelPackageDescription, forKey: .modelPackageDescription)
        }
        if let modelPackageGroupName = self.modelPackageGroupName {
            try encodeContainer.encode(modelPackageGroupName, forKey: .modelPackageGroupName)
        }
        if let modelPackageName = self.modelPackageName {
            try encodeContainer.encode(modelPackageName, forKey: .modelPackageName)
        }
        if let modelPackageStatus = self.modelPackageStatus {
            try encodeContainer.encode(modelPackageStatus.rawValue, forKey: .modelPackageStatus)
        }
        if let modelPackageStatusDetails = self.modelPackageStatusDetails {
            try encodeContainer.encode(modelPackageStatusDetails, forKey: .modelPackageStatusDetails)
        }
        if let modelPackageVersion = self.modelPackageVersion {
            try encodeContainer.encode(modelPackageVersion, forKey: .modelPackageVersion)
        }
        if let samplePayloadUrl = self.samplePayloadUrl {
            try encodeContainer.encode(samplePayloadUrl, forKey: .samplePayloadUrl)
        }
        if let sourceAlgorithmSpecification = self.sourceAlgorithmSpecification {
            try encodeContainer.encode(sourceAlgorithmSpecification, forKey: .sourceAlgorithmSpecification)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let task = self.task {
            try encodeContainer.encode(task, forKey: .task)
        }
        if let validationSpecification = self.validationSpecification {
            try encodeContainer.encode(validationSpecification, forKey: .validationSpecification)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelPackageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackageName)
        modelPackageName = modelPackageNameDecoded
        let modelPackageGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackageGroupName)
        modelPackageGroupName = modelPackageGroupNameDecoded
        let modelPackageVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modelPackageVersion)
        modelPackageVersion = modelPackageVersionDecoded
        let modelPackageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackageArn)
        modelPackageArn = modelPackageArnDecoded
        let modelPackageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelPackageDescription)
        modelPackageDescription = modelPackageDescriptionDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let inferenceSpecificationDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.InferenceSpecification.self, forKey: .inferenceSpecification)
        inferenceSpecification = inferenceSpecificationDecoded
        let sourceAlgorithmSpecificationDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.SourceAlgorithmSpecification.self, forKey: .sourceAlgorithmSpecification)
        sourceAlgorithmSpecification = sourceAlgorithmSpecificationDecoded
        let validationSpecificationDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.ModelPackageValidationSpecification.self, forKey: .validationSpecification)
        validationSpecification = validationSpecificationDecoded
        let modelPackageStatusDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.ModelPackageStatus.self, forKey: .modelPackageStatus)
        modelPackageStatus = modelPackageStatusDecoded
        let modelPackageStatusDetailsDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.ModelPackageStatusDetails.self, forKey: .modelPackageStatusDetails)
        modelPackageStatusDetails = modelPackageStatusDetailsDecoded
        let certifyForMarketplaceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .certifyForMarketplace) ?? false
        certifyForMarketplace = certifyForMarketplaceDecoded
        let modelApprovalStatusDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.ModelApprovalStatus.self, forKey: .modelApprovalStatus)
        modelApprovalStatus = modelApprovalStatusDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.UserContext.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let metadataPropertiesDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.MetadataProperties.self, forKey: .metadataProperties)
        metadataProperties = metadataPropertiesDecoded
        let modelMetricsDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.ModelMetrics.self, forKey: .modelMetrics)
        modelMetrics = modelMetricsDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.UserContext.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let approvalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .approvalDescription)
        approvalDescription = approvalDescriptionDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let taskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .task)
        task = taskDecoded
        let samplePayloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .samplePayloadUrl)
        samplePayloadUrl = samplePayloadUrlDecoded
        let additionalInferenceSpecificationsContainer = try containerValues.decodeIfPresent([SageMakerClientTypes.AdditionalInferenceSpecificationDefinition?].self, forKey: .additionalInferenceSpecifications)
        var additionalInferenceSpecificationsDecoded0:[SageMakerClientTypes.AdditionalInferenceSpecificationDefinition]? = nil
        if let additionalInferenceSpecificationsContainer = additionalInferenceSpecificationsContainer {
            additionalInferenceSpecificationsDecoded0 = [SageMakerClientTypes.AdditionalInferenceSpecificationDefinition]()
            for structure0 in additionalInferenceSpecificationsContainer {
                if let structure0 = structure0 {
                    additionalInferenceSpecificationsDecoded0?.append(structure0)
                }
            }
        }
        additionalInferenceSpecifications = additionalInferenceSpecificationsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SageMakerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SageMakerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SageMakerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let customerMetadataPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customerMetadataProperties)
        var customerMetadataPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let customerMetadataPropertiesContainer = customerMetadataPropertiesContainer {
            customerMetadataPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, customermetadatavalue0) in customerMetadataPropertiesContainer {
                if let customermetadatavalue0 = customermetadatavalue0 {
                    customerMetadataPropertiesDecoded0?[key0] = customermetadatavalue0
                }
            }
        }
        customerMetadataProperties = customerMetadataPropertiesDecoded0
        let driftCheckBaselinesDecoded = try containerValues.decodeIfPresent(SageMakerClientTypes.DriftCheckBaselines.self, forKey: .driftCheckBaselines)
        driftCheckBaselines = driftCheckBaselinesDecoded
    }
}
