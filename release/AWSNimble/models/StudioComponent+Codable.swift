// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension NimbleClientTypes.StudioComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configuration
        case createdAt
        case createdBy
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case state
        case statusCode
        case statusMessage
        case studioComponentId
        case subtype
        case tags
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for studiocomponentsecuritygroupidlist0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(studiocomponentsecuritygroupidlist0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscriptlist0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscriptlist0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for studiocomponentscriptparameterkeyvaluelist0 in scriptParameters {
                try scriptParametersContainer.encode(studiocomponentscriptparameterkeyvaluelist0)
            }
        }
        if let secureInitializationRoleArn = self.secureInitializationRoleArn {
            try encodeContainer.encode(secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioComponentId = self.studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let secureInitializationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secureInitializationRoleArn)
        secureInitializationRoleArn = secureInitializationRoleArnDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
    }
}
