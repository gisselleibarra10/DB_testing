// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SecurityHubClientTypes.AwsEc2VpnConnectionOptionsTunnelOptionsDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dpdTimeoutSeconds = "DpdTimeoutSeconds"
        case ikeVersions = "IkeVersions"
        case outsideIpAddress = "OutsideIpAddress"
        case phase1DhGroupNumbers = "Phase1DhGroupNumbers"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithms"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithms"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DhGroupNumbers = "Phase2DhGroupNumbers"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithms"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithms"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case tunnelInsideCidr = "TunnelInsideCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dpdTimeoutSeconds != 0 {
            try encodeContainer.encode(dpdTimeoutSeconds, forKey: .dpdTimeoutSeconds)
        }
        if let ikeVersions = ikeVersions {
            var ikeVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ikeVersions)
            for nonemptystringlist0 in ikeVersions {
                try ikeVersionsContainer.encode(nonemptystringlist0)
            }
        }
        if let outsideIpAddress = self.outsideIpAddress {
            try encodeContainer.encode(outsideIpAddress, forKey: .outsideIpAddress)
        }
        if let phase1DhGroupNumbers = phase1DhGroupNumbers {
            var phase1DhGroupNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1DhGroupNumbers)
            for integerlist0 in phase1DhGroupNumbers {
                try phase1DhGroupNumbersContainer.encode(integerlist0)
            }
        }
        if let phase1EncryptionAlgorithms = phase1EncryptionAlgorithms {
            var phase1EncryptionAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1EncryptionAlgorithms)
            for nonemptystringlist0 in phase1EncryptionAlgorithms {
                try phase1EncryptionAlgorithmsContainer.encode(nonemptystringlist0)
            }
        }
        if let phase1IntegrityAlgorithms = phase1IntegrityAlgorithms {
            var phase1IntegrityAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase1IntegrityAlgorithms)
            for nonemptystringlist0 in phase1IntegrityAlgorithms {
                try phase1IntegrityAlgorithmsContainer.encode(nonemptystringlist0)
            }
        }
        if phase1LifetimeSeconds != 0 {
            try encodeContainer.encode(phase1LifetimeSeconds, forKey: .phase1LifetimeSeconds)
        }
        if let phase2DhGroupNumbers = phase2DhGroupNumbers {
            var phase2DhGroupNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2DhGroupNumbers)
            for integerlist0 in phase2DhGroupNumbers {
                try phase2DhGroupNumbersContainer.encode(integerlist0)
            }
        }
        if let phase2EncryptionAlgorithms = phase2EncryptionAlgorithms {
            var phase2EncryptionAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2EncryptionAlgorithms)
            for nonemptystringlist0 in phase2EncryptionAlgorithms {
                try phase2EncryptionAlgorithmsContainer.encode(nonemptystringlist0)
            }
        }
        if let phase2IntegrityAlgorithms = phase2IntegrityAlgorithms {
            var phase2IntegrityAlgorithmsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phase2IntegrityAlgorithms)
            for nonemptystringlist0 in phase2IntegrityAlgorithms {
                try phase2IntegrityAlgorithmsContainer.encode(nonemptystringlist0)
            }
        }
        if phase2LifetimeSeconds != 0 {
            try encodeContainer.encode(phase2LifetimeSeconds, forKey: .phase2LifetimeSeconds)
        }
        if let preSharedKey = self.preSharedKey {
            try encodeContainer.encode(preSharedKey, forKey: .preSharedKey)
        }
        if rekeyFuzzPercentage != 0 {
            try encodeContainer.encode(rekeyFuzzPercentage, forKey: .rekeyFuzzPercentage)
        }
        if rekeyMarginTimeSeconds != 0 {
            try encodeContainer.encode(rekeyMarginTimeSeconds, forKey: .rekeyMarginTimeSeconds)
        }
        if replayWindowSize != 0 {
            try encodeContainer.encode(replayWindowSize, forKey: .replayWindowSize)
        }
        if let tunnelInsideCidr = self.tunnelInsideCidr {
            try encodeContainer.encode(tunnelInsideCidr, forKey: .tunnelInsideCidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dpdTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dpdTimeoutSeconds) ?? 0
        dpdTimeoutSeconds = dpdTimeoutSecondsDecoded
        let ikeVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ikeVersions)
        var ikeVersionsDecoded0:[Swift.String]? = nil
        if let ikeVersionsContainer = ikeVersionsContainer {
            ikeVersionsDecoded0 = [Swift.String]()
            for string0 in ikeVersionsContainer {
                if let string0 = string0 {
                    ikeVersionsDecoded0?.append(string0)
                }
            }
        }
        ikeVersions = ikeVersionsDecoded0
        let outsideIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outsideIpAddress)
        outsideIpAddress = outsideIpAddressDecoded
        let phase1DhGroupNumbersContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .phase1DhGroupNumbers)
        var phase1DhGroupNumbersDecoded0:[Swift.Int]? = nil
        if let phase1DhGroupNumbersContainer = phase1DhGroupNumbersContainer {
            phase1DhGroupNumbersDecoded0 = [Swift.Int]()
            for integer0 in phase1DhGroupNumbersContainer {
                if let integer0 = integer0 {
                    phase1DhGroupNumbersDecoded0?.append(integer0)
                }
            }
        }
        phase1DhGroupNumbers = phase1DhGroupNumbersDecoded0
        let phase1EncryptionAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase1EncryptionAlgorithms)
        var phase1EncryptionAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase1EncryptionAlgorithmsContainer = phase1EncryptionAlgorithmsContainer {
            phase1EncryptionAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase1EncryptionAlgorithmsContainer {
                if let string0 = string0 {
                    phase1EncryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase1EncryptionAlgorithms = phase1EncryptionAlgorithmsDecoded0
        let phase1IntegrityAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase1IntegrityAlgorithms)
        var phase1IntegrityAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase1IntegrityAlgorithmsContainer = phase1IntegrityAlgorithmsContainer {
            phase1IntegrityAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase1IntegrityAlgorithmsContainer {
                if let string0 = string0 {
                    phase1IntegrityAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase1IntegrityAlgorithms = phase1IntegrityAlgorithmsDecoded0
        let phase1LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase1LifetimeSeconds) ?? 0
        phase1LifetimeSeconds = phase1LifetimeSecondsDecoded
        let phase2DhGroupNumbersContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .phase2DhGroupNumbers)
        var phase2DhGroupNumbersDecoded0:[Swift.Int]? = nil
        if let phase2DhGroupNumbersContainer = phase2DhGroupNumbersContainer {
            phase2DhGroupNumbersDecoded0 = [Swift.Int]()
            for integer0 in phase2DhGroupNumbersContainer {
                if let integer0 = integer0 {
                    phase2DhGroupNumbersDecoded0?.append(integer0)
                }
            }
        }
        phase2DhGroupNumbers = phase2DhGroupNumbersDecoded0
        let phase2EncryptionAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase2EncryptionAlgorithms)
        var phase2EncryptionAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase2EncryptionAlgorithmsContainer = phase2EncryptionAlgorithmsContainer {
            phase2EncryptionAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase2EncryptionAlgorithmsContainer {
                if let string0 = string0 {
                    phase2EncryptionAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase2EncryptionAlgorithms = phase2EncryptionAlgorithmsDecoded0
        let phase2IntegrityAlgorithmsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .phase2IntegrityAlgorithms)
        var phase2IntegrityAlgorithmsDecoded0:[Swift.String]? = nil
        if let phase2IntegrityAlgorithmsContainer = phase2IntegrityAlgorithmsContainer {
            phase2IntegrityAlgorithmsDecoded0 = [Swift.String]()
            for string0 in phase2IntegrityAlgorithmsContainer {
                if let string0 = string0 {
                    phase2IntegrityAlgorithmsDecoded0?.append(string0)
                }
            }
        }
        phase2IntegrityAlgorithms = phase2IntegrityAlgorithmsDecoded0
        let phase2LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase2LifetimeSeconds) ?? 0
        phase2LifetimeSeconds = phase2LifetimeSecondsDecoded
        let preSharedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSharedKey)
        preSharedKey = preSharedKeyDecoded
        let rekeyFuzzPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyFuzzPercentage) ?? 0
        rekeyFuzzPercentage = rekeyFuzzPercentageDecoded
        let rekeyMarginTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyMarginTimeSeconds) ?? 0
        rekeyMarginTimeSeconds = rekeyMarginTimeSecondsDecoded
        let replayWindowSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replayWindowSize) ?? 0
        replayWindowSize = replayWindowSizeDecoded
        let tunnelInsideCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelInsideCidr)
        tunnelInsideCidr = tunnelInsideCidrDecoded
    }
}
