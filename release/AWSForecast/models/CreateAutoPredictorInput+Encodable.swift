// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CreateAutoPredictorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataConfig = "DataConfig"
        case encryptionConfig = "EncryptionConfig"
        case explainPredictor = "ExplainPredictor"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case monitorConfig = "MonitorConfig"
        case optimizationMetric = "OptimizationMetric"
        case predictorName = "PredictorName"
        case referencePredictorArn = "ReferencePredictorArn"
        case tags = "Tags"
        case timeAlignmentBoundary = "TimeAlignmentBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataConfig = self.dataConfig {
            try encodeContainer.encode(dataConfig, forKey: .dataConfig)
        }
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let explainPredictor = self.explainPredictor {
            try encodeContainer.encode(explainPredictor, forKey: .explainPredictor)
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for forecastdimensions0 in forecastDimensions {
                try forecastDimensionsContainer.encode(forecastdimensions0)
            }
        }
        if let forecastFrequency = self.forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
        if let forecastHorizon = self.forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let monitorConfig = self.monitorConfig {
            try encodeContainer.encode(monitorConfig, forKey: .monitorConfig)
        }
        if let optimizationMetric = self.optimizationMetric {
            try encodeContainer.encode(optimizationMetric.rawValue, forKey: .optimizationMetric)
        }
        if let predictorName = self.predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let referencePredictorArn = self.referencePredictorArn {
            try encodeContainer.encode(referencePredictorArn, forKey: .referencePredictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeAlignmentBoundary = self.timeAlignmentBoundary {
            try encodeContainer.encode(timeAlignmentBoundary, forKey: .timeAlignmentBoundary)
        }
    }
}
