// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ForecastClientTypes.PredictorMonitorEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationState = "EvaluationState"
        case evaluationTime = "EvaluationTime"
        case message = "Message"
        case metricResults = "MetricResults"
        case monitorArn = "MonitorArn"
        case monitorDataSource = "MonitorDataSource"
        case numItemsEvaluated = "NumItemsEvaluated"
        case predictorEvent = "PredictorEvent"
        case resourceArn = "ResourceArn"
        case windowEndDatetime = "WindowEndDatetime"
        case windowStartDatetime = "WindowStartDatetime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationState = self.evaluationState {
            try encodeContainer.encode(evaluationState, forKey: .evaluationState)
        }
        if let evaluationTime = self.evaluationTime {
            try encodeContainer.encode(evaluationTime.timeIntervalSince1970, forKey: .evaluationTime)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let metricResults = metricResults {
            var metricResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricResults)
            for metricresults0 in metricResults {
                try metricResultsContainer.encode(metricresults0)
            }
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDataSource = self.monitorDataSource {
            try encodeContainer.encode(monitorDataSource, forKey: .monitorDataSource)
        }
        if let numItemsEvaluated = self.numItemsEvaluated {
            try encodeContainer.encode(numItemsEvaluated, forKey: .numItemsEvaluated)
        }
        if let predictorEvent = self.predictorEvent {
            try encodeContainer.encode(predictorEvent, forKey: .predictorEvent)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let windowEndDatetime = self.windowEndDatetime {
            try encodeContainer.encode(windowEndDatetime.timeIntervalSince1970, forKey: .windowEndDatetime)
        }
        if let windowStartDatetime = self.windowStartDatetime {
            try encodeContainer.encode(windowStartDatetime.timeIntervalSince1970, forKey: .windowStartDatetime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let evaluationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .evaluationTime)
        evaluationTime = evaluationTimeDecoded
        let evaluationStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationState)
        evaluationState = evaluationStateDecoded
        let windowStartDatetimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .windowStartDatetime)
        windowStartDatetime = windowStartDatetimeDecoded
        let windowEndDatetimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .windowEndDatetime)
        windowEndDatetime = windowEndDatetimeDecoded
        let predictorEventDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.PredictorEvent.self, forKey: .predictorEvent)
        predictorEvent = predictorEventDecoded
        let monitorDataSourceDecoded = try containerValues.decodeIfPresent(ForecastClientTypes.MonitorDataSource.self, forKey: .monitorDataSource)
        monitorDataSource = monitorDataSourceDecoded
        let metricResultsContainer = try containerValues.decodeIfPresent([ForecastClientTypes.MetricResult?].self, forKey: .metricResults)
        var metricResultsDecoded0:[ForecastClientTypes.MetricResult]? = nil
        if let metricResultsContainer = metricResultsContainer {
            metricResultsDecoded0 = [ForecastClientTypes.MetricResult]()
            for structure0 in metricResultsContainer {
                if let structure0 = structure0 {
                    metricResultsDecoded0?.append(structure0)
                }
            }
        }
        metricResults = metricResultsDecoded0
        let numItemsEvaluatedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numItemsEvaluated)
        numItemsEvaluated = numItemsEvaluatedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
