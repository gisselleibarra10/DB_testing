// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TranslateClientTypes {
    /// The properties of the custom terminology.
    public struct TerminologyProperties: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the custom terminology.
        public var arn: Swift.String?
        /// The time at which the custom terminology was created, based on the timestamp.
        public var createdAt: ClientRuntime.Date?
        /// The description of the custom terminology properties.
        public var description: Swift.String?
        /// The directionality of your terminology resource indicates whether it has one source language (uni-directional) or multiple (multi-directional). UNI The terminology resource has one source language (the first column in a CSV file), and all of its other languages are target languages. MULTI Any language in the terminology resource can be the source language.
        public var directionality: TranslateClientTypes.Directionality?
        /// The encryption key for the custom terminology.
        public var encryptionKey: TranslateClientTypes.EncryptionKey?
        /// The format of the custom terminology input file.
        public var format: TranslateClientTypes.TerminologyDataFormat?
        /// The time at which the custom terminology was last update, based on the timestamp.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Additional information from Amazon Translate about the terminology resource.
        public var message: Swift.String?
        /// The name of the custom terminology.
        public var name: Swift.String?
        /// The size of the file used when importing a custom terminology.
        public var sizeBytes: Swift.Int?
        /// The number of terms in the input file that Amazon Translate skipped when you created or updated the terminology resource.
        public var skippedTermCount: Swift.Int?
        /// The language code for the source text of the translation request for which the custom terminology is being used.
        public var sourceLanguageCode: Swift.String?
        /// The language codes for the target languages available with the custom terminology resource. All possible target languages are returned in array.
        public var targetLanguageCodes: [Swift.String]?
        /// The number of terms included in the custom terminology.
        public var termCount: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            directionality: TranslateClientTypes.Directionality? = nil,
            encryptionKey: TranslateClientTypes.EncryptionKey? = nil,
            format: TranslateClientTypes.TerminologyDataFormat? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            sizeBytes: Swift.Int? = nil,
            skippedTermCount: Swift.Int? = nil,
            sourceLanguageCode: Swift.String? = nil,
            targetLanguageCodes: [Swift.String]? = nil,
            termCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.directionality = directionality
            self.encryptionKey = encryptionKey
            self.format = format
            self.lastUpdatedAt = lastUpdatedAt
            self.message = message
            self.name = name
            self.sizeBytes = sizeBytes
            self.skippedTermCount = skippedTermCount
            self.sourceLanguageCode = sourceLanguageCode
            self.targetLanguageCodes = targetLanguageCodes
            self.termCount = termCount
        }
    }

}
