// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LexModelsV2ClientTypes.PostFulfillmentStatusSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureConditional
        case failureNextStep
        case failureResponse
        case successConditional
        case successNextStep
        case successResponse
        case timeoutConditional
        case timeoutNextStep
        case timeoutResponse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureConditional = self.failureConditional {
            try encodeContainer.encode(failureConditional, forKey: .failureConditional)
        }
        if let failureNextStep = self.failureNextStep {
            try encodeContainer.encode(failureNextStep, forKey: .failureNextStep)
        }
        if let failureResponse = self.failureResponse {
            try encodeContainer.encode(failureResponse, forKey: .failureResponse)
        }
        if let successConditional = self.successConditional {
            try encodeContainer.encode(successConditional, forKey: .successConditional)
        }
        if let successNextStep = self.successNextStep {
            try encodeContainer.encode(successNextStep, forKey: .successNextStep)
        }
        if let successResponse = self.successResponse {
            try encodeContainer.encode(successResponse, forKey: .successResponse)
        }
        if let timeoutConditional = self.timeoutConditional {
            try encodeContainer.encode(timeoutConditional, forKey: .timeoutConditional)
        }
        if let timeoutNextStep = self.timeoutNextStep {
            try encodeContainer.encode(timeoutNextStep, forKey: .timeoutNextStep)
        }
        if let timeoutResponse = self.timeoutResponse {
            try encodeContainer.encode(timeoutResponse, forKey: .timeoutResponse)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .successResponse)
        successResponse = successResponseDecoded
        let failureResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .failureResponse)
        failureResponse = failureResponseDecoded
        let timeoutResponseDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ResponseSpecification.self, forKey: .timeoutResponse)
        timeoutResponse = timeoutResponseDecoded
        let successNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .successNextStep)
        successNextStep = successNextStepDecoded
        let successConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .successConditional)
        successConditional = successConditionalDecoded
        let failureNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .failureNextStep)
        failureNextStep = failureNextStepDecoded
        let failureConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .failureConditional)
        failureConditional = failureConditionalDecoded
        let timeoutNextStepDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.DialogState.self, forKey: .timeoutNextStep)
        timeoutNextStep = timeoutNextStepDecoded
        let timeoutConditionalDecoded = try containerValues.decodeIfPresent(LexModelsV2ClientTypes.ConditionalSpecification.self, forKey: .timeoutConditional)
        timeoutConditional = timeoutConditionalDecoded
    }
}
