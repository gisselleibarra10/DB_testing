// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ComputeOptimizerClientTypes.LambdaFunctionRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case currentMemorySize
        case currentPerformanceRisk
        case finding
        case findingReasonCodes
        case functionArn
        case functionVersion
        case lastRefreshTimestamp
        case lookbackPeriodInDays
        case memorySizeRecommendationOptions
        case numberOfInvocations
        case utilizationMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if currentMemorySize != 0 {
            try encodeContainer.encode(currentMemorySize, forKey: .currentMemorySize)
        }
        if let currentPerformanceRisk = self.currentPerformanceRisk {
            try encodeContainer.encode(currentPerformanceRisk.rawValue, forKey: .currentPerformanceRisk)
        }
        if let finding = self.finding {
            try encodeContainer.encode(finding.rawValue, forKey: .finding)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for lambdafunctionrecommendationfindingreasoncodes0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(lambdafunctionrecommendationfindingreasoncodes0.rawValue)
            }
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let lastRefreshTimestamp = self.lastRefreshTimestamp {
            try encodeContainer.encode(lastRefreshTimestamp.timeIntervalSince1970, forKey: .lastRefreshTimestamp)
        }
        if lookbackPeriodInDays != 0.0 {
            try encodeContainer.encode(lookbackPeriodInDays, forKey: .lookbackPeriodInDays)
        }
        if let memorySizeRecommendationOptions = memorySizeRecommendationOptions {
            var memorySizeRecommendationOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memorySizeRecommendationOptions)
            for lambdafunctionmemoryrecommendationoptions0 in memorySizeRecommendationOptions {
                try memorySizeRecommendationOptionsContainer.encode(lambdafunctionmemoryrecommendationoptions0)
            }
        }
        if numberOfInvocations != 0 {
            try encodeContainer.encode(numberOfInvocations, forKey: .numberOfInvocations)
        }
        if let utilizationMetrics = utilizationMetrics {
            var utilizationMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .utilizationMetrics)
            for lambdafunctionutilizationmetrics0 in utilizationMetrics {
                try utilizationMetricsContainer.encode(lambdafunctionutilizationmetrics0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentMemorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .currentMemorySize) ?? 0
        currentMemorySize = currentMemorySizeDecoded
        let numberOfInvocationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfInvocations) ?? 0
        numberOfInvocations = numberOfInvocationsDecoded
        let utilizationMetricsContainer = try containerValues.decodeIfPresent([ComputeOptimizerClientTypes.LambdaFunctionUtilizationMetric?].self, forKey: .utilizationMetrics)
        var utilizationMetricsDecoded0:[ComputeOptimizerClientTypes.LambdaFunctionUtilizationMetric]? = nil
        if let utilizationMetricsContainer = utilizationMetricsContainer {
            utilizationMetricsDecoded0 = [ComputeOptimizerClientTypes.LambdaFunctionUtilizationMetric]()
            for structure0 in utilizationMetricsContainer {
                if let structure0 = structure0 {
                    utilizationMetricsDecoded0?.append(structure0)
                }
            }
        }
        utilizationMetrics = utilizationMetricsDecoded0
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lookbackPeriodInDays) ?? 0.0
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let lastRefreshTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
        let findingDecoded = try containerValues.decodeIfPresent(ComputeOptimizerClientTypes.LambdaFunctionRecommendationFinding.self, forKey: .finding)
        finding = findingDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([ComputeOptimizerClientTypes.LambdaFunctionRecommendationFindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[ComputeOptimizerClientTypes.LambdaFunctionRecommendationFindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [ComputeOptimizerClientTypes.LambdaFunctionRecommendationFindingReasonCode]()
            for string0 in findingReasonCodesContainer {
                if let string0 = string0 {
                    findingReasonCodesDecoded0?.append(string0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
        let memorySizeRecommendationOptionsContainer = try containerValues.decodeIfPresent([ComputeOptimizerClientTypes.LambdaFunctionMemoryRecommendationOption?].self, forKey: .memorySizeRecommendationOptions)
        var memorySizeRecommendationOptionsDecoded0:[ComputeOptimizerClientTypes.LambdaFunctionMemoryRecommendationOption]? = nil
        if let memorySizeRecommendationOptionsContainer = memorySizeRecommendationOptionsContainer {
            memorySizeRecommendationOptionsDecoded0 = [ComputeOptimizerClientTypes.LambdaFunctionMemoryRecommendationOption]()
            for structure0 in memorySizeRecommendationOptionsContainer {
                if let structure0 = structure0 {
                    memorySizeRecommendationOptionsDecoded0?.append(structure0)
                }
            }
        }
        memorySizeRecommendationOptions = memorySizeRecommendationOptionsDecoded0
        let currentPerformanceRiskDecoded = try containerValues.decodeIfPresent(ComputeOptimizerClientTypes.CurrentPerformanceRisk.self, forKey: .currentPerformanceRisk)
        currentPerformanceRisk = currentPerformanceRiskDecoded
    }
}
