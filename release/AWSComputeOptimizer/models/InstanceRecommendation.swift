// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension ComputeOptimizerClientTypes {
    /// Describes an Amazon EC2 instance recommendation.
    public struct InstanceRecommendation: Swift.Equatable {
        /// The Amazon Web Services account ID of the instance.
        public var accountId: Swift.String?
        /// The instance type of the current instance.
        public var currentInstanceType: Swift.String?
        /// The risk of the current instance not meeting the performance needs of its workloads. The higher the risk, the more likely the current instance cannot meet the performance requirements of its workload.
        public var currentPerformanceRisk: ComputeOptimizerClientTypes.CurrentPerformanceRisk?
        /// An object that describes the effective recommendation preferences for the instance.
        public var effectiveRecommendationPreferences: ComputeOptimizerClientTypes.EffectiveRecommendationPreferences?
        /// The finding classification of the instance. Findings for instances include:
        ///
        /// * Underprovisioned —An instance is considered under-provisioned when at least one specification of your instance, such as CPU, memory, or network, does not meet the performance requirements of your workload. Under-provisioned instances may lead to poor application performance.
        ///
        /// * Overprovisioned —An instance is considered over-provisioned when at least one specification of your instance, such as CPU, memory, or network, can be sized down while still meeting the performance requirements of your workload, and no specification is under-provisioned. Over-provisioned instances may lead to unnecessary infrastructure cost.
        ///
        /// * Optimized —An instance is considered optimized when all specifications of your instance, such as CPU, memory, and network, meet the performance requirements of your workload and is not over provisioned. For optimized resources, Compute Optimizer might recommend a new generation instance type.
        public var finding: ComputeOptimizerClientTypes.Finding?
        /// The reason for the finding classification of the instance. Finding reason codes for instances include:
        ///
        /// * CPUOverprovisioned — The instance’s CPU configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the CPUUtilization metric of the current instance during the look-back period.
        ///
        /// * CPUUnderprovisioned — The instance’s CPU configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better CPU performance. This is identified by analyzing the CPUUtilization metric of the current instance during the look-back period.
        ///
        /// * MemoryOverprovisioned — The instance’s memory configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the memory utilization metric of the current instance during the look-back period.
        ///
        /// * MemoryUnderprovisioned — The instance’s memory configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better memory performance. This is identified by analyzing the memory utilization metric of the current instance during the look-back period. Memory utilization is analyzed only for resources that have the unified CloudWatch agent installed on them. For more information, see [Enabling memory utilization with the Amazon CloudWatch Agent](https://docs.aws.amazon.com/compute-optimizer/latest/ug/metrics.html#cw-agent) in the Compute Optimizer User Guide. On Linux instances, Compute Optimizer analyses the mem_used_percent metric in the CWAgent namespace, or the legacy MemoryUtilization metric in the System/Linux namespace. On Windows instances, Compute Optimizer analyses the Memory % Committed Bytes In Use metric in the CWAgent namespace.
        ///
        /// * EBSThroughputOverprovisioned — The instance’s EBS throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the VolumeReadOps and VolumeWriteOps metrics of EBS volumes attached to the current instance during the look-back period.
        ///
        /// * EBSThroughputUnderprovisioned — The instance’s EBS throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS throughput performance. This is identified by analyzing the VolumeReadOps and VolumeWriteOps metrics of EBS volumes attached to the current instance during the look-back period.
        ///
        /// * EBSIOPSOverprovisioned — The instance’s EBS IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the VolumeReadBytes and VolumeWriteBytes metric of EBS volumes attached to the current instance during the look-back period.
        ///
        /// * EBSIOPSUnderprovisioned — The instance’s EBS IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better EBS IOPS performance. This is identified by analyzing the VolumeReadBytes and VolumeWriteBytes metric of EBS volumes attached to the current instance during the look-back period.
        ///
        /// * NetworkBandwidthOverprovisioned — The instance’s network bandwidth configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the NetworkIn and NetworkOut metrics of the current instance during the look-back period.
        ///
        /// * NetworkBandwidthUnderprovisioned — The instance’s network bandwidth configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network bandwidth performance. This is identified by analyzing the NetworkIn and NetworkOut metrics of the current instance during the look-back period. This finding reason happens when the NetworkIn or NetworkOut performance of an instance is impacted.
        ///
        /// * NetworkPPSOverprovisioned — The instance’s network PPS (packets per second) configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the NetworkPacketsIn and NetworkPacketsIn metrics of the current instance during the look-back period.
        ///
        /// * NetworkPPSUnderprovisioned — The instance’s network PPS (packets per second) configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better network PPS performance. This is identified by analyzing the NetworkPacketsIn and NetworkPacketsIn metrics of the current instance during the look-back period.
        ///
        /// * DiskIOPSOverprovisioned — The instance’s disk IOPS configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the DiskReadOps and DiskWriteOps metrics of the current instance during the look-back period.
        ///
        /// * DiskIOPSUnderprovisioned — The instance’s disk IOPS configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk IOPS performance. This is identified by analyzing the DiskReadOps and DiskWriteOps metrics of the current instance during the look-back period.
        ///
        /// * DiskThroughputOverprovisioned — The instance’s disk throughput configuration can be sized down while still meeting the performance requirements of your workload. This is identified by analyzing the DiskReadBytes and DiskWriteBytes metrics of the current instance during the look-back period.
        ///
        /// * DiskThroughputUnderprovisioned — The instance’s disk throughput configuration doesn't meet the performance requirements of your workload and there is an alternative instance type that provides better disk throughput performance. This is identified by analyzing the DiskReadBytes and DiskWriteBytes metrics of the current instance during the look-back period.
        ///
        ///
        /// For more information about instance metrics, see [List the available CloudWatch metrics for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/viewing_metrics_with_cloudwatch.html) in the Amazon Elastic Compute Cloud User Guide. For more information about EBS volume metrics, see [Amazon CloudWatch metrics for Amazon EBS](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using_cloudwatch_ebs.html) in the Amazon Elastic Compute Cloud User Guide.
        public var findingReasonCodes: [ComputeOptimizerClientTypes.InstanceRecommendationFindingReasonCode]?
        /// The applications that might be running on the instance as inferred by Compute Optimizer. Compute Optimizer can infer if one of the following applications might be running on the instance:
        ///
        /// * AmazonEmr - Infers that Amazon EMR might be running on the instance.
        ///
        /// * ApacheCassandra - Infers that Apache Cassandra might be running on the instance.
        ///
        /// * ApacheHadoop - Infers that Apache Hadoop might be running on the instance.
        ///
        /// * Memcached - Infers that Memcached might be running on the instance.
        ///
        /// * NGINX - Infers that NGINX might be running on the instance.
        ///
        /// * PostgreSql - Infers that PostgreSQL might be running on the instance.
        ///
        /// * Redis - Infers that Redis might be running on the instance.
        public var inferredWorkloadTypes: [ComputeOptimizerClientTypes.InferredWorkloadType]?
        /// The Amazon Resource Name (ARN) of the current instance.
        public var instanceArn: Swift.String?
        /// The name of the current instance.
        public var instanceName: Swift.String?
        /// The timestamp of when the instance recommendation was last generated.
        public var lastRefreshTimestamp: ClientRuntime.Date?
        /// The number of days for which utilization metrics were analyzed for the instance.
        public var lookBackPeriodInDays: Swift.Double
        /// An array of objects that describe the recommendation options for the instance.
        public var recommendationOptions: [ComputeOptimizerClientTypes.InstanceRecommendationOption]?
        /// An array of objects that describe the source resource of the recommendation.
        public var recommendationSources: [ComputeOptimizerClientTypes.RecommendationSource]?
        /// An array of objects that describe the utilization metrics of the instance.
        public var utilizationMetrics: [ComputeOptimizerClientTypes.UtilizationMetric]?

        public init (
            accountId: Swift.String? = nil,
            currentInstanceType: Swift.String? = nil,
            currentPerformanceRisk: ComputeOptimizerClientTypes.CurrentPerformanceRisk? = nil,
            effectiveRecommendationPreferences: ComputeOptimizerClientTypes.EffectiveRecommendationPreferences? = nil,
            finding: ComputeOptimizerClientTypes.Finding? = nil,
            findingReasonCodes: [ComputeOptimizerClientTypes.InstanceRecommendationFindingReasonCode]? = nil,
            inferredWorkloadTypes: [ComputeOptimizerClientTypes.InferredWorkloadType]? = nil,
            instanceArn: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            lastRefreshTimestamp: ClientRuntime.Date? = nil,
            lookBackPeriodInDays: Swift.Double = 0.0,
            recommendationOptions: [ComputeOptimizerClientTypes.InstanceRecommendationOption]? = nil,
            recommendationSources: [ComputeOptimizerClientTypes.RecommendationSource]? = nil,
            utilizationMetrics: [ComputeOptimizerClientTypes.UtilizationMetric]? = nil
        )
        {
            self.accountId = accountId
            self.currentInstanceType = currentInstanceType
            self.currentPerformanceRisk = currentPerformanceRisk
            self.effectiveRecommendationPreferences = effectiveRecommendationPreferences
            self.finding = finding
            self.findingReasonCodes = findingReasonCodes
            self.inferredWorkloadTypes = inferredWorkloadTypes
            self.instanceArn = instanceArn
            self.instanceName = instanceName
            self.lastRefreshTimestamp = lastRefreshTimestamp
            self.lookBackPeriodInDays = lookBackPeriodInDays
            self.recommendationOptions = recommendationOptions
            self.recommendationSources = recommendationSources
            self.utilizationMetrics = utilizationMetrics
        }
    }

}
