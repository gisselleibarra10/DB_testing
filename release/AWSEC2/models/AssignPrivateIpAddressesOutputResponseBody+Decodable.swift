// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct AssignPrivateIpAddressesOutputResponseBody: Swift.Equatable {
    let networkInterfaceId: Swift.String?
    let assignedPrivateIpAddresses: [EC2ClientTypes.AssignedPrivateIpAddress]?
    let assignedIpv4Prefixes: [EC2ClientTypes.Ipv4PrefixSpecification]?
}

extension AssignPrivateIpAddressesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedIpv4Prefixes = "assignedIpv4PrefixSet"
        case assignedPrivateIpAddresses = "assignedPrivateIpAddressesSet"
        case networkInterfaceId = "networkInterfaceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        if containerValues.contains(.assignedPrivateIpAddresses) {
            struct KeyVal0{struct item{}}
            let assignedPrivateIpAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .assignedPrivateIpAddresses)
            if let assignedPrivateIpAddressesWrappedContainer = assignedPrivateIpAddressesWrappedContainer {
                let assignedPrivateIpAddressesContainer = try assignedPrivateIpAddressesWrappedContainer.decodeIfPresent([EC2ClientTypes.AssignedPrivateIpAddress].self, forKey: .member)
                var assignedPrivateIpAddressesBuffer:[EC2ClientTypes.AssignedPrivateIpAddress]? = nil
                if let assignedPrivateIpAddressesContainer = assignedPrivateIpAddressesContainer {
                    assignedPrivateIpAddressesBuffer = [EC2ClientTypes.AssignedPrivateIpAddress]()
                    for structureContainer0 in assignedPrivateIpAddressesContainer {
                        assignedPrivateIpAddressesBuffer?.append(structureContainer0)
                    }
                }
                assignedPrivateIpAddresses = assignedPrivateIpAddressesBuffer
            } else {
                assignedPrivateIpAddresses = []
            }
        } else {
            assignedPrivateIpAddresses = nil
        }
        if containerValues.contains(.assignedIpv4Prefixes) {
            struct KeyVal0{struct item{}}
            let assignedIpv4PrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .assignedIpv4Prefixes)
            if let assignedIpv4PrefixesWrappedContainer = assignedIpv4PrefixesWrappedContainer {
                let assignedIpv4PrefixesContainer = try assignedIpv4PrefixesWrappedContainer.decodeIfPresent([EC2ClientTypes.Ipv4PrefixSpecification].self, forKey: .member)
                var assignedIpv4PrefixesBuffer:[EC2ClientTypes.Ipv4PrefixSpecification]? = nil
                if let assignedIpv4PrefixesContainer = assignedIpv4PrefixesContainer {
                    assignedIpv4PrefixesBuffer = [EC2ClientTypes.Ipv4PrefixSpecification]()
                    for structureContainer0 in assignedIpv4PrefixesContainer {
                        assignedIpv4PrefixesBuffer?.append(structureContainer0)
                    }
                }
                assignedIpv4Prefixes = assignedIpv4PrefixesBuffer
            } else {
                assignedIpv4Prefixes = []
            }
        } else {
            assignedIpv4Prefixes = nil
        }
    }
}
