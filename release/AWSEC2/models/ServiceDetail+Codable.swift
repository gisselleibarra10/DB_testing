// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.ServiceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceRequired = "acceptanceRequired"
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case managesVpcEndpoints = "managesVpcEndpoints"
        case owner = "owner"
        case payerResponsibility = "payerResponsibility"
        case privateDnsName = "privateDnsName"
        case privateDnsNameVerificationState = "privateDnsNameVerificationState"
        case privateDnsNames = "privateDnsNameSet"
        case serviceId = "serviceId"
        case serviceName = "serviceName"
        case serviceType = "serviceType"
        case supportedIpAddressTypes = "supportedIpAddressTypeSet"
        case tags = "tagSet"
        case vpcEndpointPolicySupported = "vpcEndpointPolicySupported"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let acceptanceRequired = acceptanceRequired {
            try container.encode(acceptanceRequired, forKey: ClientRuntime.Key("AcceptanceRequired"))
        }
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                for (index0, string0) in availabilityZones.enumerated() {
                    var availabilityZonesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZoneSet.\(index0.advanced(by: 1))"))
                    try availabilityZonesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZoneSet"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let baseEndpointDnsNames = baseEndpointDnsNames {
            if !baseEndpointDnsNames.isEmpty {
                for (index0, string0) in baseEndpointDnsNames.enumerated() {
                    var baseEndpointDnsNamesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BaseEndpointDnsNameSet.\(index0.advanced(by: 1))"))
                    try baseEndpointDnsNamesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var baseEndpointDnsNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BaseEndpointDnsNameSet"))
                try baseEndpointDnsNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let managesVpcEndpoints = managesVpcEndpoints {
            try container.encode(managesVpcEndpoints, forKey: ClientRuntime.Key("ManagesVpcEndpoints"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let payerResponsibility = payerResponsibility {
            try container.encode(payerResponsibility, forKey: ClientRuntime.Key("PayerResponsibility"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: ClientRuntime.Key("PrivateDnsName"))
        }
        if let privateDnsNameVerificationState = privateDnsNameVerificationState {
            try container.encode(privateDnsNameVerificationState, forKey: ClientRuntime.Key("PrivateDnsNameVerificationState"))
        }
        if let privateDnsNames = privateDnsNames {
            if !privateDnsNames.isEmpty {
                for (index0, privatednsdetails0) in privateDnsNames.enumerated() {
                    var privateDnsNamesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PrivateDnsNameSet.\(index0.advanced(by: 1))"))
                    try privateDnsNamesContainer0.encode(privatednsdetails0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var privateDnsNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PrivateDnsNameSet"))
                try privateDnsNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: ClientRuntime.Key("ServiceId"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceType = serviceType {
            if !serviceType.isEmpty {
                for (index0, servicetypedetail0) in serviceType.enumerated() {
                    var serviceTypeContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceType.\(index0.advanced(by: 1))"))
                    try serviceTypeContainer0.encode(servicetypedetail0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var serviceTypeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceType"))
                try serviceTypeContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let supportedIpAddressTypes = supportedIpAddressTypes {
            if !supportedIpAddressTypes.isEmpty {
                for (index0, serviceconnectivitytype0) in supportedIpAddressTypes.enumerated() {
                    var supportedIpAddressTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedIpAddressTypeSet.\(index0.advanced(by: 1))"))
                    try supportedIpAddressTypesContainer0.encode(serviceconnectivitytype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedIpAddressTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedIpAddressTypeSet"))
                try supportedIpAddressTypesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let vpcEndpointPolicySupported = vpcEndpointPolicySupported {
            try container.encode(vpcEndpointPolicySupported, forKey: ClientRuntime.Key("VpcEndpointPolicySupported"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        if containerValues.contains(.serviceType) {
            struct KeyVal0{struct item{}}
            let serviceTypeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .serviceType)
            if let serviceTypeWrappedContainer = serviceTypeWrappedContainer {
                let serviceTypeContainer = try serviceTypeWrappedContainer.decodeIfPresent([EC2ClientTypes.ServiceTypeDetail].self, forKey: .member)
                var serviceTypeBuffer:[EC2ClientTypes.ServiceTypeDetail]? = nil
                if let serviceTypeContainer = serviceTypeContainer {
                    serviceTypeBuffer = [EC2ClientTypes.ServiceTypeDetail]()
                    for structureContainer0 in serviceTypeContainer {
                        serviceTypeBuffer?.append(structureContainer0)
                    }
                }
                serviceType = serviceTypeBuffer
            } else {
                serviceType = []
            }
        } else {
            serviceType = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct item{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        if containerValues.contains(.baseEndpointDnsNames) {
            struct KeyVal0{struct item{}}
            let baseEndpointDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .baseEndpointDnsNames)
            if let baseEndpointDnsNamesWrappedContainer = baseEndpointDnsNamesWrappedContainer {
                let baseEndpointDnsNamesContainer = try baseEndpointDnsNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var baseEndpointDnsNamesBuffer:[Swift.String]? = nil
                if let baseEndpointDnsNamesContainer = baseEndpointDnsNamesContainer {
                    baseEndpointDnsNamesBuffer = [Swift.String]()
                    for stringContainer0 in baseEndpointDnsNamesContainer {
                        baseEndpointDnsNamesBuffer?.append(stringContainer0)
                    }
                }
                baseEndpointDnsNames = baseEndpointDnsNamesBuffer
            } else {
                baseEndpointDnsNames = []
            }
        } else {
            baseEndpointDnsNames = nil
        }
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        if containerValues.contains(.privateDnsNames) {
            struct KeyVal0{struct item{}}
            let privateDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .privateDnsNames)
            if let privateDnsNamesWrappedContainer = privateDnsNamesWrappedContainer {
                let privateDnsNamesContainer = try privateDnsNamesWrappedContainer.decodeIfPresent([EC2ClientTypes.PrivateDnsDetails].self, forKey: .member)
                var privateDnsNamesBuffer:[EC2ClientTypes.PrivateDnsDetails]? = nil
                if let privateDnsNamesContainer = privateDnsNamesContainer {
                    privateDnsNamesBuffer = [EC2ClientTypes.PrivateDnsDetails]()
                    for structureContainer0 in privateDnsNamesContainer {
                        privateDnsNamesBuffer?.append(structureContainer0)
                    }
                }
                privateDnsNames = privateDnsNamesBuffer
            } else {
                privateDnsNames = []
            }
        } else {
            privateDnsNames = nil
        }
        let vpcEndpointPolicySupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .vpcEndpointPolicySupported)
        vpcEndpointPolicySupported = vpcEndpointPolicySupportedDecoded
        let acceptanceRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptanceRequired)
        acceptanceRequired = acceptanceRequiredDecoded
        let managesVpcEndpointsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .managesVpcEndpoints)
        managesVpcEndpoints = managesVpcEndpointsDecoded
        let payerResponsibilityDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PayerResponsibility.self, forKey: .payerResponsibility)
        payerResponsibility = payerResponsibilityDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([EC2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[EC2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [EC2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let privateDnsNameVerificationStateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.DnsNameState.self, forKey: .privateDnsNameVerificationState)
        privateDnsNameVerificationState = privateDnsNameVerificationStateDecoded
        if containerValues.contains(.supportedIpAddressTypes) {
            struct KeyVal0{struct item{}}
            let supportedIpAddressTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedIpAddressTypes)
            if let supportedIpAddressTypesWrappedContainer = supportedIpAddressTypesWrappedContainer {
                let supportedIpAddressTypesContainer = try supportedIpAddressTypesWrappedContainer.decodeIfPresent([EC2ClientTypes.ServiceConnectivityType].self, forKey: .member)
                var supportedIpAddressTypesBuffer:[EC2ClientTypes.ServiceConnectivityType]? = nil
                if let supportedIpAddressTypesContainer = supportedIpAddressTypesContainer {
                    supportedIpAddressTypesBuffer = [EC2ClientTypes.ServiceConnectivityType]()
                    for enumContainer0 in supportedIpAddressTypesContainer {
                        supportedIpAddressTypesBuffer?.append(enumContainer0)
                    }
                }
                supportedIpAddressTypes = supportedIpAddressTypesBuffer
            } else {
                supportedIpAddressTypes = []
            }
        } else {
            supportedIpAddressTypes = nil
        }
    }
}
