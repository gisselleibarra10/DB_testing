// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct RunInstancesInputBody: Swift.Equatable {
    let blockDeviceMappings: [EC2ClientTypes.BlockDeviceMapping]?
    let imageId: Swift.String?
    let instanceType: EC2ClientTypes.InstanceType?
    let ipv6AddressCount: Swift.Int?
    let ipv6Addresses: [EC2ClientTypes.InstanceIpv6Address]?
    let kernelId: Swift.String?
    let keyName: Swift.String?
    let maxCount: Swift.Int?
    let minCount: Swift.Int?
    let monitoring: EC2ClientTypes.RunInstancesMonitoringEnabled?
    let placement: EC2ClientTypes.Placement?
    let ramdiskId: Swift.String?
    let securityGroupIds: [Swift.String]?
    let securityGroups: [Swift.String]?
    let subnetId: Swift.String?
    let userData: Swift.String?
    let additionalInfo: Swift.String?
    let clientToken: Swift.String?
    let disableApiTermination: Swift.Bool?
    let dryRun: Swift.Bool?
    let ebsOptimized: Swift.Bool?
    let iamInstanceProfile: EC2ClientTypes.IamInstanceProfileSpecification?
    let instanceInitiatedShutdownBehavior: EC2ClientTypes.ShutdownBehavior?
    let networkInterfaces: [EC2ClientTypes.InstanceNetworkInterfaceSpecification]?
    let privateIpAddress: Swift.String?
    let elasticGpuSpecification: [EC2ClientTypes.ElasticGpuSpecification]?
    let elasticInferenceAccelerators: [EC2ClientTypes.ElasticInferenceAccelerator]?
    let tagSpecifications: [EC2ClientTypes.TagSpecification]?
    let launchTemplate: EC2ClientTypes.LaunchTemplateSpecification?
    let instanceMarketOptions: EC2ClientTypes.InstanceMarketOptionsRequest?
    let creditSpecification: EC2ClientTypes.CreditSpecificationRequest?
    let cpuOptions: EC2ClientTypes.CpuOptionsRequest?
    let capacityReservationSpecification: EC2ClientTypes.CapacityReservationSpecification?
    let hibernationOptions: EC2ClientTypes.HibernationOptionsRequest?
    let licenseSpecifications: [EC2ClientTypes.LicenseConfigurationRequest]?
    let metadataOptions: EC2ClientTypes.InstanceMetadataOptionsRequest?
    let enclaveOptions: EC2ClientTypes.EnclaveOptionsRequest?
    let privateDnsNameOptions: EC2ClientTypes.PrivateDnsNameOptionsRequest?
    let maintenanceOptions: EC2ClientTypes.InstanceMaintenanceOptionsRequest?
    let disableApiStop: Swift.Bool?
}

extension RunInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInfo = "additionalInfo"
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case clientToken = "clientToken"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination = "disableApiTermination"
        case dryRun = "dryRun"
        case ebsOptimized = "ebsOptimized"
        case elasticGpuSpecification = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "instanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceType = "InstanceType"
        case ipv6AddressCount = "Ipv6AddressCount"
        case ipv6Addresses = "Ipv6Address"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case launchTemplate = "LaunchTemplate"
        case licenseSpecifications = "LicenseSpecification"
        case maintenanceOptions = "MaintenanceOptions"
        case maxCount = "MaxCount"
        case metadataOptions = "MetadataOptions"
        case minCount = "MinCount"
        case monitoring = "Monitoring"
        case networkInterfaces = "networkInterface"
        case placement = "Placement"
        case privateDnsNameOptions = "PrivateDnsNameOptions"
        case privateIpAddress = "privateIpAddress"
        case ramdiskId = "RamdiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case subnetId = "SubnetId"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct BlockDeviceMapping{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.BlockDeviceMapping>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([EC2ClientTypes.BlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[EC2ClientTypes.BlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [EC2ClientTypes.BlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let ipv6AddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6AddressCount)
        ipv6AddressCount = ipv6AddressCountDecoded
        if containerValues.contains(.ipv6Addresses) {
            struct KeyVal0{struct item{}}
            let ipv6AddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Addresses)
            if let ipv6AddressesWrappedContainer = ipv6AddressesWrappedContainer {
                let ipv6AddressesContainer = try ipv6AddressesWrappedContainer.decodeIfPresent([EC2ClientTypes.InstanceIpv6Address].self, forKey: .member)
                var ipv6AddressesBuffer:[EC2ClientTypes.InstanceIpv6Address]? = nil
                if let ipv6AddressesContainer = ipv6AddressesContainer {
                    ipv6AddressesBuffer = [EC2ClientTypes.InstanceIpv6Address]()
                    for structureContainer0 in ipv6AddressesContainer {
                        ipv6AddressesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Addresses = ipv6AddressesBuffer
            } else {
                ipv6Addresses = []
            }
        } else {
            ipv6Addresses = nil
        }
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let minCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minCount)
        minCount = minCountDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.RunInstancesMonitoringEnabled.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.Placement.self, forKey: .placement)
        placement = placementDecoded
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct SecurityGroup{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroup>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userData)
        userData = userDataDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let disableApiTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiTermination)
        disableApiTermination = disableApiTerminationDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.IamInstanceProfileSpecification.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.ShutdownBehavior.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct item{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([EC2ClientTypes.InstanceNetworkInterfaceSpecification].self, forKey: .member)
                var networkInterfacesBuffer:[EC2ClientTypes.InstanceNetworkInterfaceSpecification]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [EC2ClientTypes.InstanceNetworkInterfaceSpecification]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.elasticGpuSpecification) {
            struct KeyVal0{struct item{}}
            let elasticGpuSpecificationWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticGpuSpecification)
            if let elasticGpuSpecificationWrappedContainer = elasticGpuSpecificationWrappedContainer {
                let elasticGpuSpecificationContainer = try elasticGpuSpecificationWrappedContainer.decodeIfPresent([EC2ClientTypes.ElasticGpuSpecification].self, forKey: .member)
                var elasticGpuSpecificationBuffer:[EC2ClientTypes.ElasticGpuSpecification]? = nil
                if let elasticGpuSpecificationContainer = elasticGpuSpecificationContainer {
                    elasticGpuSpecificationBuffer = [EC2ClientTypes.ElasticGpuSpecification]()
                    for structureContainer0 in elasticGpuSpecificationContainer {
                        elasticGpuSpecificationBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuSpecification = elasticGpuSpecificationBuffer
            } else {
                elasticGpuSpecification = []
            }
        } else {
            elasticGpuSpecification = nil
        }
        if containerValues.contains(.elasticInferenceAccelerators) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAccelerators)
            if let elasticInferenceAcceleratorsWrappedContainer = elasticInferenceAcceleratorsWrappedContainer {
                let elasticInferenceAcceleratorsContainer = try elasticInferenceAcceleratorsWrappedContainer.decodeIfPresent([EC2ClientTypes.ElasticInferenceAccelerator].self, forKey: .member)
                var elasticInferenceAcceleratorsBuffer:[EC2ClientTypes.ElasticInferenceAccelerator]? = nil
                if let elasticInferenceAcceleratorsContainer = elasticInferenceAcceleratorsContainer {
                    elasticInferenceAcceleratorsBuffer = [EC2ClientTypes.ElasticInferenceAccelerator]()
                    for structureContainer0 in elasticInferenceAcceleratorsContainer {
                        elasticInferenceAcceleratorsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAccelerators = elasticInferenceAcceleratorsBuffer
            } else {
                elasticInferenceAccelerators = []
            }
        } else {
            elasticInferenceAccelerators = nil
        }
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.TagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[EC2ClientTypes.TagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [EC2ClientTypes.TagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
        let launchTemplateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceMarketOptionsRequest.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
        let creditSpecificationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CreditSpecificationRequest.self, forKey: .creditSpecification)
        creditSpecification = creditSpecificationDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CpuOptionsRequest.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CapacityReservationSpecification.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.HibernationOptionsRequest.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        if containerValues.contains(.licenseSpecifications) {
            struct KeyVal0{struct item{}}
            let licenseSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenseSpecifications)
            if let licenseSpecificationsWrappedContainer = licenseSpecificationsWrappedContainer {
                let licenseSpecificationsContainer = try licenseSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.LicenseConfigurationRequest].self, forKey: .member)
                var licenseSpecificationsBuffer:[EC2ClientTypes.LicenseConfigurationRequest]? = nil
                if let licenseSpecificationsContainer = licenseSpecificationsContainer {
                    licenseSpecificationsBuffer = [EC2ClientTypes.LicenseConfigurationRequest]()
                    for structureContainer0 in licenseSpecificationsContainer {
                        licenseSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                licenseSpecifications = licenseSpecificationsBuffer
            } else {
                licenseSpecifications = []
            }
        } else {
            licenseSpecifications = nil
        }
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceMetadataOptionsRequest.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.EnclaveOptionsRequest.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let privateDnsNameOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PrivateDnsNameOptionsRequest.self, forKey: .privateDnsNameOptions)
        privateDnsNameOptions = privateDnsNameOptionsDecoded
        let maintenanceOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceMaintenanceOptionsRequest.self, forKey: .maintenanceOptions)
        maintenanceOptions = maintenanceOptionsDecoded
        let disableApiStopDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiStop)
        disableApiStop = disableApiStopDecoded
    }
}
