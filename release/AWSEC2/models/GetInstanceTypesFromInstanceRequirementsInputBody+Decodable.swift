// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetInstanceTypesFromInstanceRequirementsInputBody: Swift.Equatable {
    let dryRun: Swift.Bool?
    let architectureTypes: [Ec2ClientTypes.ArchitectureType]?
    let virtualizationTypes: [Ec2ClientTypes.VirtualizationType]?
    let instanceRequirements: Ec2ClientTypes.InstanceRequirementsRequest?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetInstanceTypesFromInstanceRequirementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architectureTypes = "ArchitectureType"
        case dryRun = "DryRun"
        case instanceRequirements = "InstanceRequirements"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case virtualizationTypes = "VirtualizationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        if containerValues.contains(.architectureTypes) {
            struct KeyVal0{struct item{}}
            let architectureTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .architectureTypes)
            if let architectureTypesWrappedContainer = architectureTypesWrappedContainer {
                let architectureTypesContainer = try architectureTypesWrappedContainer.decodeIfPresent([Ec2ClientTypes.ArchitectureType].self, forKey: .member)
                var architectureTypesBuffer:[Ec2ClientTypes.ArchitectureType]? = nil
                if let architectureTypesContainer = architectureTypesContainer {
                    architectureTypesBuffer = [Ec2ClientTypes.ArchitectureType]()
                    for enumContainer0 in architectureTypesContainer {
                        architectureTypesBuffer?.append(enumContainer0)
                    }
                }
                architectureTypes = architectureTypesBuffer
            } else {
                architectureTypes = []
            }
        } else {
            architectureTypes = nil
        }
        if containerValues.contains(.virtualizationTypes) {
            struct KeyVal0{struct item{}}
            let virtualizationTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .virtualizationTypes)
            if let virtualizationTypesWrappedContainer = virtualizationTypesWrappedContainer {
                let virtualizationTypesContainer = try virtualizationTypesWrappedContainer.decodeIfPresent([Ec2ClientTypes.VirtualizationType].self, forKey: .member)
                var virtualizationTypesBuffer:[Ec2ClientTypes.VirtualizationType]? = nil
                if let virtualizationTypesContainer = virtualizationTypesContainer {
                    virtualizationTypesBuffer = [Ec2ClientTypes.VirtualizationType]()
                    for enumContainer0 in virtualizationTypesContainer {
                        virtualizationTypesBuffer?.append(enumContainer0)
                    }
                }
                virtualizationTypes = virtualizationTypesBuffer
            } else {
                virtualizationTypes = []
            }
        } else {
            virtualizationTypes = nil
        }
        let instanceRequirementsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.InstanceRequirementsRequest.self, forKey: .instanceRequirements)
        instanceRequirements = instanceRequirementsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}
