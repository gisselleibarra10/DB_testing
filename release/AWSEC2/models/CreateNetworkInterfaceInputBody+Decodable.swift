// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct CreateNetworkInterfaceInputBody: Swift.Equatable {
    let description: Swift.String?
    let dryRun: Swift.Bool?
    let groups: [Swift.String]?
    let ipv6AddressCount: Swift.Int?
    let ipv6Addresses: [Ec2ClientTypes.InstanceIpv6Address]?
    let privateIpAddress: Swift.String?
    let privateIpAddresses: [Ec2ClientTypes.PrivateIpAddressSpecification]?
    let secondaryPrivateIpAddressCount: Swift.Int?
    let ipv4Prefixes: [Ec2ClientTypes.Ipv4PrefixSpecificationRequest]?
    let ipv4PrefixCount: Swift.Int?
    let ipv6Prefixes: [Ec2ClientTypes.Ipv6PrefixSpecificationRequest]?
    let ipv6PrefixCount: Swift.Int?
    let interfaceType: Ec2ClientTypes.NetworkInterfaceCreationType?
    let subnetId: Swift.String?
    let tagSpecifications: [Ec2ClientTypes.TagSpecification]?
    let clientToken: Swift.String?
}

extension CreateNetworkInterfaceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "description"
        case dryRun = "dryRun"
        case groups = "SecurityGroupId"
        case interfaceType = "InterfaceType"
        case ipv4PrefixCount = "Ipv4PrefixCount"
        case ipv4Prefixes = "Ipv4Prefix"
        case ipv6AddressCount = "ipv6AddressCount"
        case ipv6Addresses = "ipv6Addresses"
        case ipv6PrefixCount = "Ipv6PrefixCount"
        case ipv6Prefixes = "Ipv6Prefix"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddresses"
        case secondaryPrivateIpAddressCount = "secondaryPrivateIpAddressCount"
        case subnetId = "subnetId"
        case tagSpecifications = "TagSpecification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        if containerValues.contains(.groups) {
            struct KeyVal0{struct SecurityGroupId{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var groupsBuffer:[Swift.String]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [Swift.String]()
                    for stringContainer0 in groupsContainer {
                        groupsBuffer?.append(stringContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let ipv6AddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6AddressCount)
        ipv6AddressCount = ipv6AddressCountDecoded
        if containerValues.contains(.ipv6Addresses) {
            struct KeyVal0{struct item{}}
            let ipv6AddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Addresses)
            if let ipv6AddressesWrappedContainer = ipv6AddressesWrappedContainer {
                let ipv6AddressesContainer = try ipv6AddressesWrappedContainer.decodeIfPresent([Ec2ClientTypes.InstanceIpv6Address].self, forKey: .member)
                var ipv6AddressesBuffer:[Ec2ClientTypes.InstanceIpv6Address]? = nil
                if let ipv6AddressesContainer = ipv6AddressesContainer {
                    ipv6AddressesBuffer = [Ec2ClientTypes.InstanceIpv6Address]()
                    for structureContainer0 in ipv6AddressesContainer {
                        ipv6AddressesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Addresses = ipv6AddressesBuffer
            } else {
                ipv6Addresses = []
            }
        } else {
            ipv6Addresses = nil
        }
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.privateIpAddresses) {
            struct KeyVal0{struct item{}}
            let privateIpAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .privateIpAddresses)
            if let privateIpAddressesWrappedContainer = privateIpAddressesWrappedContainer {
                let privateIpAddressesContainer = try privateIpAddressesWrappedContainer.decodeIfPresent([Ec2ClientTypes.PrivateIpAddressSpecification].self, forKey: .member)
                var privateIpAddressesBuffer:[Ec2ClientTypes.PrivateIpAddressSpecification]? = nil
                if let privateIpAddressesContainer = privateIpAddressesContainer {
                    privateIpAddressesBuffer = [Ec2ClientTypes.PrivateIpAddressSpecification]()
                    for structureContainer0 in privateIpAddressesContainer {
                        privateIpAddressesBuffer?.append(structureContainer0)
                    }
                }
                privateIpAddresses = privateIpAddressesBuffer
            } else {
                privateIpAddresses = []
            }
        } else {
            privateIpAddresses = nil
        }
        let secondaryPrivateIpAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondaryPrivateIpAddressCount)
        secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCountDecoded
        if containerValues.contains(.ipv4Prefixes) {
            struct KeyVal0{struct item{}}
            let ipv4PrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv4Prefixes)
            if let ipv4PrefixesWrappedContainer = ipv4PrefixesWrappedContainer {
                let ipv4PrefixesContainer = try ipv4PrefixesWrappedContainer.decodeIfPresent([Ec2ClientTypes.Ipv4PrefixSpecificationRequest].self, forKey: .member)
                var ipv4PrefixesBuffer:[Ec2ClientTypes.Ipv4PrefixSpecificationRequest]? = nil
                if let ipv4PrefixesContainer = ipv4PrefixesContainer {
                    ipv4PrefixesBuffer = [Ec2ClientTypes.Ipv4PrefixSpecificationRequest]()
                    for structureContainer0 in ipv4PrefixesContainer {
                        ipv4PrefixesBuffer?.append(structureContainer0)
                    }
                }
                ipv4Prefixes = ipv4PrefixesBuffer
            } else {
                ipv4Prefixes = []
            }
        } else {
            ipv4Prefixes = nil
        }
        let ipv4PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv4PrefixCount)
        ipv4PrefixCount = ipv4PrefixCountDecoded
        if containerValues.contains(.ipv6Prefixes) {
            struct KeyVal0{struct item{}}
            let ipv6PrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Prefixes)
            if let ipv6PrefixesWrappedContainer = ipv6PrefixesWrappedContainer {
                let ipv6PrefixesContainer = try ipv6PrefixesWrappedContainer.decodeIfPresent([Ec2ClientTypes.Ipv6PrefixSpecificationRequest].self, forKey: .member)
                var ipv6PrefixesBuffer:[Ec2ClientTypes.Ipv6PrefixSpecificationRequest]? = nil
                if let ipv6PrefixesContainer = ipv6PrefixesContainer {
                    ipv6PrefixesBuffer = [Ec2ClientTypes.Ipv6PrefixSpecificationRequest]()
                    for structureContainer0 in ipv6PrefixesContainer {
                        ipv6PrefixesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Prefixes = ipv6PrefixesBuffer
            } else {
                ipv6Prefixes = []
            }
        } else {
            ipv6Prefixes = nil
        }
        let ipv6PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6PrefixCount)
        ipv6PrefixCount = ipv6PrefixCountDecoded
        let interfaceTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.NetworkInterfaceCreationType.self, forKey: .interfaceType)
        interfaceType = interfaceTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.TagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[Ec2ClientTypes.TagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [Ec2ClientTypes.TagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}
