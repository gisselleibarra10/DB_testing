// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiLaunchIndex = "amiLaunchIndex"
        case architecture = "architecture"
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode = "bootMode"
        case capacityReservationId = "capacityReservationId"
        case capacityReservationSpecification = "capacityReservationSpecification"
        case clientToken = "clientToken"
        case cpuOptions = "cpuOptions"
        case ebsOptimized = "ebsOptimized"
        case elasticGpuAssociations = "elasticGpuAssociationSet"
        case elasticInferenceAcceleratorAssociations = "elasticInferenceAcceleratorAssociationSet"
        case enaSupport = "enaSupport"
        case enclaveOptions = "enclaveOptions"
        case hibernationOptions = "hibernationOptions"
        case hypervisor = "hypervisor"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceLifecycle = "instanceLifecycle"
        case instanceType = "instanceType"
        case ipv6Address = "ipv6Address"
        case kernelId = "kernelId"
        case keyName = "keyName"
        case launchTime = "launchTime"
        case licenses = "licenseSet"
        case maintenanceOptions = "maintenanceOptions"
        case metadataOptions = "metadataOptions"
        case monitoring = "monitoring"
        case networkInterfaces = "networkInterfaceSet"
        case outpostArn = "outpostArn"
        case placement = "placement"
        case platform = "platform"
        case platformDetails = "platformDetails"
        case privateDnsName = "privateDnsName"
        case privateDnsNameOptions = "privateDnsNameOptions"
        case privateIpAddress = "privateIpAddress"
        case productCodes = "productCodes"
        case publicDnsName = "dnsName"
        case publicIpAddress = "ipAddress"
        case ramdiskId = "ramdiskId"
        case rootDeviceName = "rootDeviceName"
        case rootDeviceType = "rootDeviceType"
        case securityGroups = "groupSet"
        case sourceDestCheck = "sourceDestCheck"
        case spotInstanceRequestId = "spotInstanceRequestId"
        case sriovNetSupport = "sriovNetSupport"
        case state = "instanceState"
        case stateReason = "stateReason"
        case stateTransitionReason = "reason"
        case subnetId = "subnetId"
        case tags = "tagSet"
        case tpmSupport = "tpmSupport"
        case usageOperation = "usageOperation"
        case usageOperationUpdateTime = "usageOperationUpdateTime"
        case virtualizationType = "virtualizationType"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let amiLaunchIndex = amiLaunchIndex {
            try container.encode(amiLaunchIndex, forKey: ClientRuntime.Key("AmiLaunchIndex"))
        }
        if let architecture = architecture {
            try container.encode(architecture, forKey: ClientRuntime.Key("Architecture"))
        }
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, instanceblockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(instanceblockdevicemapping0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var blockDeviceMappingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMapping"))
                try blockDeviceMappingsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let bootMode = bootMode {
            try container.encode(bootMode, forKey: ClientRuntime.Key("BootMode"))
        }
        if let capacityReservationId = capacityReservationId {
            try container.encode(capacityReservationId, forKey: ClientRuntime.Key("CapacityReservationId"))
        }
        if let capacityReservationSpecification = capacityReservationSpecification {
            try container.encode(capacityReservationSpecification, forKey: ClientRuntime.Key("CapacityReservationSpecification"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: ClientRuntime.Key("ClientToken"))
        }
        if let cpuOptions = cpuOptions {
            try container.encode(cpuOptions, forKey: ClientRuntime.Key("CpuOptions"))
        }
        if let ebsOptimized = ebsOptimized {
            try container.encode(ebsOptimized, forKey: ClientRuntime.Key("EbsOptimized"))
        }
        if let elasticGpuAssociations = elasticGpuAssociations {
            if !elasticGpuAssociations.isEmpty {
                for (index0, elasticgpuassociation0) in elasticGpuAssociations.enumerated() {
                    var elasticGpuAssociationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticGpuAssociationSet.\(index0.advanced(by: 1))"))
                    try elasticGpuAssociationsContainer0.encode(elasticgpuassociation0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var elasticGpuAssociationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticGpuAssociationSet"))
                try elasticGpuAssociationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociations {
            if !elasticInferenceAcceleratorAssociations.isEmpty {
                for (index0, elasticinferenceacceleratorassociation0) in elasticInferenceAcceleratorAssociations.enumerated() {
                    var elasticInferenceAcceleratorAssociationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticInferenceAcceleratorAssociationSet.\(index0.advanced(by: 1))"))
                    try elasticInferenceAcceleratorAssociationsContainer0.encode(elasticinferenceacceleratorassociation0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var elasticInferenceAcceleratorAssociationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticInferenceAcceleratorAssociationSet"))
                try elasticInferenceAcceleratorAssociationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let enaSupport = enaSupport {
            try container.encode(enaSupport, forKey: ClientRuntime.Key("EnaSupport"))
        }
        if let enclaveOptions = enclaveOptions {
            try container.encode(enclaveOptions, forKey: ClientRuntime.Key("EnclaveOptions"))
        }
        if let hibernationOptions = hibernationOptions {
            try container.encode(hibernationOptions, forKey: ClientRuntime.Key("HibernationOptions"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: ClientRuntime.Key("Hypervisor"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: ClientRuntime.Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: ClientRuntime.Key("ImageId"))
        }
        if let instanceId = instanceId {
            try container.encode(instanceId, forKey: ClientRuntime.Key("InstanceId"))
        }
        if let instanceLifecycle = instanceLifecycle {
            try container.encode(instanceLifecycle, forKey: ClientRuntime.Key("InstanceLifecycle"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: ClientRuntime.Key("InstanceType"))
        }
        if let ipv6Address = ipv6Address {
            try container.encode(ipv6Address, forKey: ClientRuntime.Key("Ipv6Address"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: ClientRuntime.Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: ClientRuntime.Key("KeyName"))
        }
        if let launchTime = launchTime {
            try container.encodeTimestamp(launchTime, format: .dateTime, forKey: ClientRuntime.Key("LaunchTime"))
        }
        if let licenses = licenses {
            if !licenses.isEmpty {
                for (index0, licenseconfiguration0) in licenses.enumerated() {
                    var licensesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LicenseSet.\(index0.advanced(by: 1))"))
                    try licensesContainer0.encode(licenseconfiguration0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var licensesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LicenseSet"))
                try licensesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let maintenanceOptions = maintenanceOptions {
            try container.encode(maintenanceOptions, forKey: ClientRuntime.Key("MaintenanceOptions"))
        }
        if let metadataOptions = metadataOptions {
            try container.encode(metadataOptions, forKey: ClientRuntime.Key("MetadataOptions"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: ClientRuntime.Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, instancenetworkinterface0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterfaceSet.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(instancenetworkinterface0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var networkInterfacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterfaceSet"))
                try networkInterfacesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: ClientRuntime.Key("OutpostArn"))
        }
        if let placement = placement {
            try container.encode(placement, forKey: ClientRuntime.Key("Placement"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: ClientRuntime.Key("Platform"))
        }
        if let platformDetails = platformDetails {
            try container.encode(platformDetails, forKey: ClientRuntime.Key("PlatformDetails"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: ClientRuntime.Key("PrivateDnsName"))
        }
        if let privateDnsNameOptions = privateDnsNameOptions {
            try container.encode(privateDnsNameOptions, forKey: ClientRuntime.Key("PrivateDnsNameOptions"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: ClientRuntime.Key("PrivateIpAddress"))
        }
        if let productCodes = productCodes {
            if !productCodes.isEmpty {
                for (index0, productcode0) in productCodes.enumerated() {
                    var productCodesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProductCodes.\(index0.advanced(by: 1))"))
                    try productCodesContainer0.encode(productcode0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var productCodesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProductCodes"))
                try productCodesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let publicDnsName = publicDnsName {
            try container.encode(publicDnsName, forKey: ClientRuntime.Key("DnsName"))
        }
        if let publicIpAddress = publicIpAddress {
            try container.encode(publicIpAddress, forKey: ClientRuntime.Key("IpAddress"))
        }
        if let ramdiskId = ramdiskId {
            try container.encode(ramdiskId, forKey: ClientRuntime.Key("RamdiskId"))
        }
        if let rootDeviceName = rootDeviceName {
            try container.encode(rootDeviceName, forKey: ClientRuntime.Key("RootDeviceName"))
        }
        if let rootDeviceType = rootDeviceType {
            try container.encode(rootDeviceType, forKey: ClientRuntime.Key("RootDeviceType"))
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, groupidentifier0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupSet.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(groupidentifier0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupSet"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourceDestCheck = sourceDestCheck {
            try container.encode(sourceDestCheck, forKey: ClientRuntime.Key("SourceDestCheck"))
        }
        if let spotInstanceRequestId = spotInstanceRequestId {
            try container.encode(spotInstanceRequestId, forKey: ClientRuntime.Key("SpotInstanceRequestId"))
        }
        if let sriovNetSupport = sriovNetSupport {
            try container.encode(sriovNetSupport, forKey: ClientRuntime.Key("SriovNetSupport"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("InstanceState"))
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: ClientRuntime.Key("StateReason"))
        }
        if let stateTransitionReason = stateTransitionReason {
            try container.encode(stateTransitionReason, forKey: ClientRuntime.Key("Reason"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tpmSupport = tpmSupport {
            try container.encode(tpmSupport, forKey: ClientRuntime.Key("TpmSupport"))
        }
        if let usageOperation = usageOperation {
            try container.encode(usageOperation, forKey: ClientRuntime.Key("UsageOperation"))
        }
        if let usageOperationUpdateTime = usageOperationUpdateTime {
            try container.encodeTimestamp(usageOperationUpdateTime, format: .dateTime, forKey: ClientRuntime.Key("UsageOperationUpdateTime"))
        }
        if let virtualizationType = virtualizationType {
            try container.encode(virtualizationType, forKey: ClientRuntime.Key("VirtualizationType"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiLaunchIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amiLaunchIndex)
        amiLaunchIndex = amiLaunchIndexDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let launchTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.Monitoring.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.Placement.self, forKey: .placement)
        placement = placementDecoded
        let platformDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PlatformValues.self, forKey: .platform)
        platform = platformDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.productCodes) {
            struct KeyVal0{struct item{}}
            let productCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .productCodes)
            if let productCodesWrappedContainer = productCodesWrappedContainer {
                let productCodesContainer = try productCodesWrappedContainer.decodeIfPresent([EC2ClientTypes.ProductCode].self, forKey: .member)
                var productCodesBuffer:[EC2ClientTypes.ProductCode]? = nil
                if let productCodesContainer = productCodesContainer {
                    productCodesBuffer = [EC2ClientTypes.ProductCode]()
                    for structureContainer0 in productCodesContainer {
                        productCodesBuffer?.append(structureContainer0)
                    }
                }
                productCodes = productCodesBuffer
            } else {
                productCodes = []
            }
        } else {
            productCodes = nil
        }
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceState.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.ArchitectureValues.self, forKey: .architecture)
        architecture = architectureDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([EC2ClientTypes.InstanceBlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[EC2ClientTypes.InstanceBlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [EC2ClientTypes.InstanceBlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let enaSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.HypervisorType.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let instanceLifecycleDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceLifecycleType.self, forKey: .instanceLifecycle)
        instanceLifecycle = instanceLifecycleDecoded
        if containerValues.contains(.elasticGpuAssociations) {
            struct KeyVal0{struct item{}}
            let elasticGpuAssociationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticGpuAssociations)
            if let elasticGpuAssociationsWrappedContainer = elasticGpuAssociationsWrappedContainer {
                let elasticGpuAssociationsContainer = try elasticGpuAssociationsWrappedContainer.decodeIfPresent([EC2ClientTypes.ElasticGpuAssociation].self, forKey: .member)
                var elasticGpuAssociationsBuffer:[EC2ClientTypes.ElasticGpuAssociation]? = nil
                if let elasticGpuAssociationsContainer = elasticGpuAssociationsContainer {
                    elasticGpuAssociationsBuffer = [EC2ClientTypes.ElasticGpuAssociation]()
                    for structureContainer0 in elasticGpuAssociationsContainer {
                        elasticGpuAssociationsBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuAssociations = elasticGpuAssociationsBuffer
            } else {
                elasticGpuAssociations = []
            }
        } else {
            elasticGpuAssociations = nil
        }
        if containerValues.contains(.elasticInferenceAcceleratorAssociations) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorAssociationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAcceleratorAssociations)
            if let elasticInferenceAcceleratorAssociationsWrappedContainer = elasticInferenceAcceleratorAssociationsWrappedContainer {
                let elasticInferenceAcceleratorAssociationsContainer = try elasticInferenceAcceleratorAssociationsWrappedContainer.decodeIfPresent([EC2ClientTypes.ElasticInferenceAcceleratorAssociation].self, forKey: .member)
                var elasticInferenceAcceleratorAssociationsBuffer:[EC2ClientTypes.ElasticInferenceAcceleratorAssociation]? = nil
                if let elasticInferenceAcceleratorAssociationsContainer = elasticInferenceAcceleratorAssociationsContainer {
                    elasticInferenceAcceleratorAssociationsBuffer = [EC2ClientTypes.ElasticInferenceAcceleratorAssociation]()
                    for structureContainer0 in elasticInferenceAcceleratorAssociationsContainer {
                        elasticInferenceAcceleratorAssociationsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAcceleratorAssociations = elasticInferenceAcceleratorAssociationsBuffer
            } else {
                elasticInferenceAcceleratorAssociations = []
            }
        } else {
            elasticInferenceAcceleratorAssociations = nil
        }
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct item{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([EC2ClientTypes.InstanceNetworkInterface].self, forKey: .member)
                var networkInterfacesBuffer:[EC2ClientTypes.InstanceNetworkInterface]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [EC2ClientTypes.InstanceNetworkInterface]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.DeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct item{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([EC2ClientTypes.GroupIdentifier].self, forKey: .member)
                var securityGroupsBuffer:[EC2ClientTypes.GroupIdentifier]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [EC2ClientTypes.GroupIdentifier]()
                    for structureContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(structureContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let sourceDestCheckDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sourceDestCheck)
        sourceDestCheck = sourceDestCheckDecoded
        let spotInstanceRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotInstanceRequestId)
        spotInstanceRequestId = spotInstanceRequestIdDecoded
        let sriovNetSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sriovNetSupport)
        sriovNetSupport = sriovNetSupportDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.StateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([EC2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[EC2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [EC2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CpuOptions.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationId)
        capacityReservationId = capacityReservationIdDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CapacityReservationSpecificationResponse.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.HibernationOptions.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        if containerValues.contains(.licenses) {
            struct KeyVal0{struct item{}}
            let licensesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenses)
            if let licensesWrappedContainer = licensesWrappedContainer {
                let licensesContainer = try licensesWrappedContainer.decodeIfPresent([EC2ClientTypes.LicenseConfiguration].self, forKey: .member)
                var licensesBuffer:[EC2ClientTypes.LicenseConfiguration]? = nil
                if let licensesContainer = licensesContainer {
                    licensesBuffer = [EC2ClientTypes.LicenseConfiguration]()
                    for structureContainer0 in licensesContainer {
                        licensesBuffer?.append(structureContainer0)
                    }
                }
                licenses = licensesBuffer
            } else {
                licenses = []
            }
        } else {
            licenses = nil
        }
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceMetadataOptionsResponse.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.EnclaveOptions.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.BootModeValues.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let platformDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDetails)
        platformDetails = platformDetailsDecoded
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
        let usageOperationUpdateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .usageOperationUpdateTime)
        usageOperationUpdateTime = usageOperationUpdateTimeDecoded
        let privateDnsNameOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PrivateDnsNameOptionsResponse.self, forKey: .privateDnsNameOptions)
        privateDnsNameOptions = privateDnsNameOptionsDecoded
        let ipv6AddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipv6Address)
        ipv6Address = ipv6AddressDecoded
        let tpmSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tpmSupport)
        tpmSupport = tpmSupportDecoded
        let maintenanceOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceMaintenanceOptions.self, forKey: .maintenanceOptions)
        maintenanceOptions = maintenanceOptionsDecoded
    }
}
