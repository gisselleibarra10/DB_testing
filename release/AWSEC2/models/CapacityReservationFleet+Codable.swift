// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.CapacityReservationFleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocationStrategy = "allocationStrategy"
        case capacityReservationFleetArn = "capacityReservationFleetArn"
        case capacityReservationFleetId = "capacityReservationFleetId"
        case createTime = "createTime"
        case endDate = "endDate"
        case instanceMatchCriteria = "instanceMatchCriteria"
        case instanceTypeSpecifications = "instanceTypeSpecificationSet"
        case state = "state"
        case tags = "tagSet"
        case tenancy = "tenancy"
        case totalFulfilledCapacity = "totalFulfilledCapacity"
        case totalTargetCapacity = "totalTargetCapacity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocationStrategy = allocationStrategy {
            try container.encode(allocationStrategy, forKey: ClientRuntime.Key("AllocationStrategy"))
        }
        if let capacityReservationFleetArn = capacityReservationFleetArn {
            try container.encode(capacityReservationFleetArn, forKey: ClientRuntime.Key("CapacityReservationFleetArn"))
        }
        if let capacityReservationFleetId = capacityReservationFleetId {
            try container.encode(capacityReservationFleetId, forKey: ClientRuntime.Key("CapacityReservationFleetId"))
        }
        if let createTime = createTime {
            try container.encodeTimestamp(createTime, format: .dateTime, forKey: ClientRuntime.Key("CreateTime"))
        }
        if let endDate = endDate {
            try container.encodeTimestamp(endDate, format: .dateTime, forKey: ClientRuntime.Key("EndDate"))
        }
        if let instanceMatchCriteria = instanceMatchCriteria {
            try container.encode(instanceMatchCriteria, forKey: ClientRuntime.Key("InstanceMatchCriteria"))
        }
        if let instanceTypeSpecifications = instanceTypeSpecifications {
            if !instanceTypeSpecifications.isEmpty {
                for (index0, fleetcapacityreservation0) in instanceTypeSpecifications.enumerated() {
                    var instanceTypeSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceTypeSpecificationSet.\(index0.advanced(by: 1))"))
                    try instanceTypeSpecificationsContainer0.encode(fleetcapacityreservation0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var instanceTypeSpecificationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceTypeSpecificationSet"))
                try instanceTypeSpecificationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tenancy = tenancy {
            try container.encode(tenancy, forKey: ClientRuntime.Key("Tenancy"))
        }
        if let totalFulfilledCapacity = totalFulfilledCapacity {
            try container.encode(totalFulfilledCapacity, forKey: ClientRuntime.Key("TotalFulfilledCapacity"))
        }
        if let totalTargetCapacity = totalTargetCapacity {
            try container.encode(totalTargetCapacity, forKey: ClientRuntime.Key("TotalTargetCapacity"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationFleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationFleetId)
        capacityReservationFleetId = capacityReservationFleetIdDecoded
        let capacityReservationFleetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationFleetArn)
        capacityReservationFleetArn = capacityReservationFleetArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CapacityReservationFleetState.self, forKey: .state)
        state = stateDecoded
        let totalTargetCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalTargetCapacity)
        totalTargetCapacity = totalTargetCapacityDecoded
        let totalFulfilledCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalFulfilledCapacity)
        totalFulfilledCapacity = totalFulfilledCapacityDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.FleetCapacityReservationTenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endDate)
        endDate = endDateDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createTime)
        createTime = createTimeDecoded
        let instanceMatchCriteriaDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.FleetInstanceMatchCriteria.self, forKey: .instanceMatchCriteria)
        instanceMatchCriteria = instanceMatchCriteriaDecoded
        let allocationStrategyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allocationStrategy)
        allocationStrategy = allocationStrategyDecoded
        if containerValues.contains(.instanceTypeSpecifications) {
            struct KeyVal0{struct item{}}
            let instanceTypeSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .instanceTypeSpecifications)
            if let instanceTypeSpecificationsWrappedContainer = instanceTypeSpecificationsWrappedContainer {
                let instanceTypeSpecificationsContainer = try instanceTypeSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.FleetCapacityReservation].self, forKey: .member)
                var instanceTypeSpecificationsBuffer:[EC2ClientTypes.FleetCapacityReservation]? = nil
                if let instanceTypeSpecificationsContainer = instanceTypeSpecificationsContainer {
                    instanceTypeSpecificationsBuffer = [EC2ClientTypes.FleetCapacityReservation]()
                    for structureContainer0 in instanceTypeSpecificationsContainer {
                        instanceTypeSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                instanceTypeSpecifications = instanceTypeSpecificationsBuffer
            } else {
                instanceTypeSpecifications = []
            }
        } else {
            instanceTypeSpecifications = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([EC2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[EC2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [EC2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}
