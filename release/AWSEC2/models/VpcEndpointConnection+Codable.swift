// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.VpcEndpointConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTimestamp = "creationTimestamp"
        case dnsEntries = "dnsEntrySet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case ipAddressType = "ipAddressType"
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case serviceId = "serviceId"
        case tags = "tagSet"
        case vpcEndpointConnectionId = "vpcEndpointConnectionId"
        case vpcEndpointId = "vpcEndpointId"
        case vpcEndpointOwner = "vpcEndpointOwner"
        case vpcEndpointState = "vpcEndpointState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let creationTimestamp = creationTimestamp {
            try container.encode(ClientRuntime.TimestampWrapper(creationTimestamp, format: .dateTime), forKey: ClientRuntime.Key("CreationTimestamp"))
        }
        if let dnsEntries = dnsEntries {
            if !dnsEntries.isEmpty {
                for (index0, dnsentry0) in dnsEntries.enumerated() {
                    var dnsEntriesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DnsEntrySet.\(index0.advanced(by: 1))"))
                    try dnsEntriesContainer0.encode(dnsentry0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let gatewayLoadBalancerArns = gatewayLoadBalancerArns {
            if !gatewayLoadBalancerArns.isEmpty {
                for (index0, string0) in gatewayLoadBalancerArns.enumerated() {
                    var gatewayLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GatewayLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try gatewayLoadBalancerArnsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: ClientRuntime.Key("IpAddressType"))
        }
        if let networkLoadBalancerArns = networkLoadBalancerArns {
            if !networkLoadBalancerArns.isEmpty {
                for (index0, string0) in networkLoadBalancerArns.enumerated() {
                    var networkLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try networkLoadBalancerArnsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: ClientRuntime.Key("ServiceId"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let vpcEndpointConnectionId = vpcEndpointConnectionId {
            try container.encode(vpcEndpointConnectionId, forKey: ClientRuntime.Key("VpcEndpointConnectionId"))
        }
        if let vpcEndpointId = vpcEndpointId {
            try container.encode(vpcEndpointId, forKey: ClientRuntime.Key("VpcEndpointId"))
        }
        if let vpcEndpointOwner = vpcEndpointOwner {
            try container.encode(vpcEndpointOwner, forKey: ClientRuntime.Key("VpcEndpointOwner"))
        }
        if let vpcEndpointState = vpcEndpointState {
            try container.encode(vpcEndpointState, forKey: ClientRuntime.Key("VpcEndpointState"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcEndpointOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointOwner)
        vpcEndpointOwner = vpcEndpointOwnerDecoded
        let vpcEndpointStateDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.State.self, forKey: .vpcEndpointState)
        vpcEndpointState = vpcEndpointStateDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        var creationTimestampBuffer:ClientRuntime.Date? = nil
        if let creationTimestampDecoded = creationTimestampDecoded {
            creationTimestampBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(creationTimestampDecoded, format: .dateTime)
        }
        creationTimestamp = creationTimestampBuffer
        if containerValues.contains(.dnsEntries) {
            struct KeyVal0{struct item{}}
            let dnsEntriesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .dnsEntries)
            if let dnsEntriesWrappedContainer = dnsEntriesWrappedContainer {
                let dnsEntriesContainer = try dnsEntriesWrappedContainer.decodeIfPresent([Ec2ClientTypes.DnsEntry].self, forKey: .member)
                var dnsEntriesBuffer:[Ec2ClientTypes.DnsEntry]? = nil
                if let dnsEntriesContainer = dnsEntriesContainer {
                    dnsEntriesBuffer = [Ec2ClientTypes.DnsEntry]()
                    for structureContainer0 in dnsEntriesContainer {
                        dnsEntriesBuffer?.append(structureContainer0)
                    }
                }
                dnsEntries = dnsEntriesBuffer
            } else {
                dnsEntries = []
            }
        } else {
            dnsEntries = nil
        }
        if containerValues.contains(.networkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let networkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkLoadBalancerArns)
            if let networkLoadBalancerArnsWrappedContainer = networkLoadBalancerArnsWrappedContainer {
                let networkLoadBalancerArnsContainer = try networkLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var networkLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let networkLoadBalancerArnsContainer = networkLoadBalancerArnsContainer {
                    networkLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in networkLoadBalancerArnsContainer {
                        networkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                networkLoadBalancerArns = networkLoadBalancerArnsBuffer
            } else {
                networkLoadBalancerArns = []
            }
        } else {
            networkLoadBalancerArns = nil
        }
        if containerValues.contains(.gatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let gatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .gatewayLoadBalancerArns)
            if let gatewayLoadBalancerArnsWrappedContainer = gatewayLoadBalancerArnsWrappedContainer {
                let gatewayLoadBalancerArnsContainer = try gatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var gatewayLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let gatewayLoadBalancerArnsContainer = gatewayLoadBalancerArnsContainer {
                    gatewayLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in gatewayLoadBalancerArnsContainer {
                        gatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                gatewayLoadBalancerArns = gatewayLoadBalancerArnsBuffer
            } else {
                gatewayLoadBalancerArns = []
            }
        } else {
            gatewayLoadBalancerArns = nil
        }
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let vpcEndpointConnectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointConnectionId)
        vpcEndpointConnectionId = vpcEndpointConnectionIdDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[Ec2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Ec2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}
