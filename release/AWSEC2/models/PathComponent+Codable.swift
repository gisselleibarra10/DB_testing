// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.PathComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aclRule = "aclRule"
        case additionalDetails = "additionalDetailSet"
        case attachedTo = "attachedTo"
        case component = "component"
        case destinationVpc = "destinationVpc"
        case elasticLoadBalancerListener = "elasticLoadBalancerListener"
        case explanations = "explanationSet"
        case inboundHeader = "inboundHeader"
        case outboundHeader = "outboundHeader"
        case routeTableRoute = "routeTableRoute"
        case securityGroupRule = "securityGroupRule"
        case sequenceNumber = "sequenceNumber"
        case sourceVpc = "sourceVpc"
        case subnet = "subnet"
        case transitGateway = "transitGateway"
        case transitGatewayRouteTableRoute = "transitGatewayRouteTableRoute"
        case vpc = "vpc"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let aclRule = aclRule {
            try container.encode(aclRule, forKey: ClientRuntime.Key("AclRule"))
        }
        if let additionalDetails = additionalDetails {
            if !additionalDetails.isEmpty {
                for (index0, additionaldetail0) in additionalDetails.enumerated() {
                    var additionalDetailsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AdditionalDetailSet.\(index0.advanced(by: 1))"))
                    try additionalDetailsContainer0.encode(additionaldetail0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let attachedTo = attachedTo {
            try container.encode(attachedTo, forKey: ClientRuntime.Key("AttachedTo"))
        }
        if let component = component {
            try container.encode(component, forKey: ClientRuntime.Key("Component"))
        }
        if let destinationVpc = destinationVpc {
            try container.encode(destinationVpc, forKey: ClientRuntime.Key("DestinationVpc"))
        }
        if let elasticLoadBalancerListener = elasticLoadBalancerListener {
            try container.encode(elasticLoadBalancerListener, forKey: ClientRuntime.Key("ElasticLoadBalancerListener"))
        }
        if let explanations = explanations {
            if !explanations.isEmpty {
                for (index0, explanation0) in explanations.enumerated() {
                    var explanationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExplanationSet.\(index0.advanced(by: 1))"))
                    try explanationsContainer0.encode(explanation0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let inboundHeader = inboundHeader {
            try container.encode(inboundHeader, forKey: ClientRuntime.Key("InboundHeader"))
        }
        if let outboundHeader = outboundHeader {
            try container.encode(outboundHeader, forKey: ClientRuntime.Key("OutboundHeader"))
        }
        if let routeTableRoute = routeTableRoute {
            try container.encode(routeTableRoute, forKey: ClientRuntime.Key("RouteTableRoute"))
        }
        if let securityGroupRule = securityGroupRule {
            try container.encode(securityGroupRule, forKey: ClientRuntime.Key("SecurityGroupRule"))
        }
        if let sequenceNumber = sequenceNumber {
            try container.encode(sequenceNumber, forKey: ClientRuntime.Key("SequenceNumber"))
        }
        if let sourceVpc = sourceVpc {
            try container.encode(sourceVpc, forKey: ClientRuntime.Key("SourceVpc"))
        }
        if let subnet = subnet {
            try container.encode(subnet, forKey: ClientRuntime.Key("Subnet"))
        }
        if let transitGateway = transitGateway {
            try container.encode(transitGateway, forKey: ClientRuntime.Key("TransitGateway"))
        }
        if let transitGatewayRouteTableRoute = transitGatewayRouteTableRoute {
            try container.encode(transitGatewayRouteTableRoute, forKey: ClientRuntime.Key("TransitGatewayRouteTableRoute"))
        }
        if let vpc = vpc {
            try container.encode(vpc, forKey: ClientRuntime.Key("Vpc"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sequenceNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sequenceNumber)
        sequenceNumber = sequenceNumberDecoded
        let aclRuleDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisAclRule.self, forKey: .aclRule)
        aclRule = aclRuleDecoded
        let attachedToDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .attachedTo)
        attachedTo = attachedToDecoded
        let componentDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .component)
        component = componentDecoded
        let destinationVpcDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .destinationVpc)
        destinationVpc = destinationVpcDecoded
        let outboundHeaderDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisPacketHeader.self, forKey: .outboundHeader)
        outboundHeader = outboundHeaderDecoded
        let inboundHeaderDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisPacketHeader.self, forKey: .inboundHeader)
        inboundHeader = inboundHeaderDecoded
        let routeTableRouteDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisRouteTableRoute.self, forKey: .routeTableRoute)
        routeTableRoute = routeTableRouteDecoded
        let securityGroupRuleDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisSecurityGroupRule.self, forKey: .securityGroupRule)
        securityGroupRule = securityGroupRuleDecoded
        let sourceVpcDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .sourceVpc)
        sourceVpc = sourceVpcDecoded
        let subnetDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .subnet)
        subnet = subnetDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .vpc)
        vpc = vpcDecoded
        if containerValues.contains(.additionalDetails) {
            struct KeyVal0{struct item{}}
            let additionalDetailsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .additionalDetails)
            if let additionalDetailsWrappedContainer = additionalDetailsWrappedContainer {
                let additionalDetailsContainer = try additionalDetailsWrappedContainer.decodeIfPresent([Ec2ClientTypes.AdditionalDetail].self, forKey: .member)
                var additionalDetailsBuffer:[Ec2ClientTypes.AdditionalDetail]? = nil
                if let additionalDetailsContainer = additionalDetailsContainer {
                    additionalDetailsBuffer = [Ec2ClientTypes.AdditionalDetail]()
                    for structureContainer0 in additionalDetailsContainer {
                        additionalDetailsBuffer?.append(structureContainer0)
                    }
                }
                additionalDetails = additionalDetailsBuffer
            } else {
                additionalDetails = []
            }
        } else {
            additionalDetails = nil
        }
        let transitGatewayDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .transitGateway)
        transitGateway = transitGatewayDecoded
        let transitGatewayRouteTableRouteDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.TransitGatewayRouteTableRoute.self, forKey: .transitGatewayRouteTableRoute)
        transitGatewayRouteTableRoute = transitGatewayRouteTableRouteDecoded
        if containerValues.contains(.explanations) {
            struct KeyVal0{struct item{}}
            let explanationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .explanations)
            if let explanationsWrappedContainer = explanationsWrappedContainer {
                let explanationsContainer = try explanationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Explanation].self, forKey: .member)
                var explanationsBuffer:[Ec2ClientTypes.Explanation]? = nil
                if let explanationsContainer = explanationsContainer {
                    explanationsBuffer = [Ec2ClientTypes.Explanation]()
                    for structureContainer0 in explanationsContainer {
                        explanationsBuffer?.append(structureContainer0)
                    }
                }
                explanations = explanationsBuffer
            } else {
                explanations = []
            }
        } else {
            explanations = nil
        }
        let elasticLoadBalancerListenerDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AnalysisComponent.self, forKey: .elasticLoadBalancerListener)
        elasticLoadBalancerListener = elasticLoadBalancerListenerDecoded
    }
}
