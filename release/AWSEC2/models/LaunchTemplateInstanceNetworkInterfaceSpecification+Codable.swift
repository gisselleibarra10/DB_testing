// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateCarrierIpAddress = "associateCarrierIpAddress"
        case associatePublicIpAddress = "associatePublicIpAddress"
        case deleteOnTermination = "deleteOnTermination"
        case description = "description"
        case deviceIndex = "deviceIndex"
        case groups = "groupSet"
        case interfaceType = "interfaceType"
        case ipv4PrefixCount = "ipv4PrefixCount"
        case ipv4Prefixes = "ipv4PrefixSet"
        case ipv6AddressCount = "ipv6AddressCount"
        case ipv6Addresses = "ipv6AddressesSet"
        case ipv6PrefixCount = "ipv6PrefixCount"
        case ipv6Prefixes = "ipv6PrefixSet"
        case networkCardIndex = "networkCardIndex"
        case networkInterfaceId = "networkInterfaceId"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddressesSet"
        case secondaryPrivateIpAddressCount = "secondaryPrivateIpAddressCount"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let associateCarrierIpAddress = associateCarrierIpAddress {
            try container.encode(associateCarrierIpAddress, forKey: ClientRuntime.Key("AssociateCarrierIpAddress"))
        }
        if let associatePublicIpAddress = associatePublicIpAddress {
            try container.encode(associatePublicIpAddress, forKey: ClientRuntime.Key("AssociatePublicIpAddress"))
        }
        if let deleteOnTermination = deleteOnTermination {
            try container.encode(deleteOnTermination, forKey: ClientRuntime.Key("DeleteOnTermination"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let deviceIndex = deviceIndex {
            try container.encode(deviceIndex, forKey: ClientRuntime.Key("DeviceIndex"))
        }
        if let groups = groups {
            if !groups.isEmpty {
                for (index0, securitygroupid0) in groups.enumerated() {
                    var groupsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupSet.\(index0.advanced(by: 1))"))
                    try groupsContainer0.encode(securitygroupid0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var groupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GroupSet"))
                try groupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let interfaceType = interfaceType {
            try container.encode(interfaceType, forKey: ClientRuntime.Key("InterfaceType"))
        }
        if let ipv4PrefixCount = ipv4PrefixCount {
            try container.encode(ipv4PrefixCount, forKey: ClientRuntime.Key("Ipv4PrefixCount"))
        }
        if let ipv4Prefixes = ipv4Prefixes {
            if !ipv4Prefixes.isEmpty {
                for (index0, ipv4prefixspecificationresponse0) in ipv4Prefixes.enumerated() {
                    var ipv4PrefixesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv4PrefixSet.\(index0.advanced(by: 1))"))
                    try ipv4PrefixesContainer0.encode(ipv4prefixspecificationresponse0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var ipv4PrefixesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv4PrefixSet"))
                try ipv4PrefixesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let ipv6AddressCount = ipv6AddressCount {
            try container.encode(ipv6AddressCount, forKey: ClientRuntime.Key("Ipv6AddressCount"))
        }
        if let ipv6Addresses = ipv6Addresses {
            if !ipv6Addresses.isEmpty {
                for (index0, instanceipv6address0) in ipv6Addresses.enumerated() {
                    var ipv6AddressesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6AddressesSet.\(index0.advanced(by: 1))"))
                    try ipv6AddressesContainer0.encode(instanceipv6address0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var ipv6AddressesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6AddressesSet"))
                try ipv6AddressesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let ipv6PrefixCount = ipv6PrefixCount {
            try container.encode(ipv6PrefixCount, forKey: ClientRuntime.Key("Ipv6PrefixCount"))
        }
        if let ipv6Prefixes = ipv6Prefixes {
            if !ipv6Prefixes.isEmpty {
                for (index0, ipv6prefixspecificationresponse0) in ipv6Prefixes.enumerated() {
                    var ipv6PrefixesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6PrefixSet.\(index0.advanced(by: 1))"))
                    try ipv6PrefixesContainer0.encode(ipv6prefixspecificationresponse0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var ipv6PrefixesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6PrefixSet"))
                try ipv6PrefixesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let networkCardIndex = networkCardIndex {
            try container.encode(networkCardIndex, forKey: ClientRuntime.Key("NetworkCardIndex"))
        }
        if let networkInterfaceId = networkInterfaceId {
            try container.encode(networkInterfaceId, forKey: ClientRuntime.Key("NetworkInterfaceId"))
        }
        if let privateIpAddress = privateIpAddress {
            try container.encode(privateIpAddress, forKey: ClientRuntime.Key("PrivateIpAddress"))
        }
        if let privateIpAddresses = privateIpAddresses {
            if !privateIpAddresses.isEmpty {
                for (index0, privateipaddressspecification0) in privateIpAddresses.enumerated() {
                    var privateIpAddressesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PrivateIpAddressesSet.\(index0.advanced(by: 1))"))
                    try privateIpAddressesContainer0.encode(privateipaddressspecification0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var privateIpAddressesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PrivateIpAddressesSet"))
                try privateIpAddressesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount {
            try container.encode(secondaryPrivateIpAddressCount, forKey: ClientRuntime.Key("SecondaryPrivateIpAddressCount"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associateCarrierIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateCarrierIpAddress)
        associateCarrierIpAddress = associateCarrierIpAddressDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deviceIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .deviceIndex)
        deviceIndex = deviceIndexDecoded
        if containerValues.contains(.groups) {
            struct KeyVal0{struct groupId{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.groupId>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var groupsBuffer:[Swift.String]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [Swift.String]()
                    for stringContainer0 in groupsContainer {
                        groupsBuffer?.append(stringContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        let interfaceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceType)
        interfaceType = interfaceTypeDecoded
        let ipv6AddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6AddressCount)
        ipv6AddressCount = ipv6AddressCountDecoded
        if containerValues.contains(.ipv6Addresses) {
            struct KeyVal0{struct item{}}
            let ipv6AddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Addresses)
            if let ipv6AddressesWrappedContainer = ipv6AddressesWrappedContainer {
                let ipv6AddressesContainer = try ipv6AddressesWrappedContainer.decodeIfPresent([EC2ClientTypes.InstanceIpv6Address].self, forKey: .member)
                var ipv6AddressesBuffer:[EC2ClientTypes.InstanceIpv6Address]? = nil
                if let ipv6AddressesContainer = ipv6AddressesContainer {
                    ipv6AddressesBuffer = [EC2ClientTypes.InstanceIpv6Address]()
                    for structureContainer0 in ipv6AddressesContainer {
                        ipv6AddressesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Addresses = ipv6AddressesBuffer
            } else {
                ipv6Addresses = []
            }
        } else {
            ipv6Addresses = nil
        }
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        if containerValues.contains(.privateIpAddresses) {
            struct KeyVal0{struct item{}}
            let privateIpAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .privateIpAddresses)
            if let privateIpAddressesWrappedContainer = privateIpAddressesWrappedContainer {
                let privateIpAddressesContainer = try privateIpAddressesWrappedContainer.decodeIfPresent([EC2ClientTypes.PrivateIpAddressSpecification].self, forKey: .member)
                var privateIpAddressesBuffer:[EC2ClientTypes.PrivateIpAddressSpecification]? = nil
                if let privateIpAddressesContainer = privateIpAddressesContainer {
                    privateIpAddressesBuffer = [EC2ClientTypes.PrivateIpAddressSpecification]()
                    for structureContainer0 in privateIpAddressesContainer {
                        privateIpAddressesBuffer?.append(structureContainer0)
                    }
                }
                privateIpAddresses = privateIpAddressesBuffer
            } else {
                privateIpAddresses = []
            }
        } else {
            privateIpAddresses = nil
        }
        let secondaryPrivateIpAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .secondaryPrivateIpAddressCount)
        secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCountDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let networkCardIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .networkCardIndex)
        networkCardIndex = networkCardIndexDecoded
        if containerValues.contains(.ipv4Prefixes) {
            struct KeyVal0{struct item{}}
            let ipv4PrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv4Prefixes)
            if let ipv4PrefixesWrappedContainer = ipv4PrefixesWrappedContainer {
                let ipv4PrefixesContainer = try ipv4PrefixesWrappedContainer.decodeIfPresent([EC2ClientTypes.Ipv4PrefixSpecificationResponse].self, forKey: .member)
                var ipv4PrefixesBuffer:[EC2ClientTypes.Ipv4PrefixSpecificationResponse]? = nil
                if let ipv4PrefixesContainer = ipv4PrefixesContainer {
                    ipv4PrefixesBuffer = [EC2ClientTypes.Ipv4PrefixSpecificationResponse]()
                    for structureContainer0 in ipv4PrefixesContainer {
                        ipv4PrefixesBuffer?.append(structureContainer0)
                    }
                }
                ipv4Prefixes = ipv4PrefixesBuffer
            } else {
                ipv4Prefixes = []
            }
        } else {
            ipv4Prefixes = nil
        }
        let ipv4PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv4PrefixCount)
        ipv4PrefixCount = ipv4PrefixCountDecoded
        if containerValues.contains(.ipv6Prefixes) {
            struct KeyVal0{struct item{}}
            let ipv6PrefixesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6Prefixes)
            if let ipv6PrefixesWrappedContainer = ipv6PrefixesWrappedContainer {
                let ipv6PrefixesContainer = try ipv6PrefixesWrappedContainer.decodeIfPresent([EC2ClientTypes.Ipv6PrefixSpecificationResponse].self, forKey: .member)
                var ipv6PrefixesBuffer:[EC2ClientTypes.Ipv6PrefixSpecificationResponse]? = nil
                if let ipv6PrefixesContainer = ipv6PrefixesContainer {
                    ipv6PrefixesBuffer = [EC2ClientTypes.Ipv6PrefixSpecificationResponse]()
                    for structureContainer0 in ipv6PrefixesContainer {
                        ipv6PrefixesBuffer?.append(structureContainer0)
                    }
                }
                ipv6Prefixes = ipv6PrefixesBuffer
            } else {
                ipv6Prefixes = []
            }
        } else {
            ipv6Prefixes = nil
        }
        let ipv6PrefixCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ipv6PrefixCount)
        ipv6PrefixCount = ipv6PrefixCountDecoded
    }
}
