// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ReportInstanceStatusInputBody: Swift.Equatable {
    let description: Swift.String?
    let dryRun: Swift.Bool?
    let endTime: ClientRuntime.Date?
    let instances: [Swift.String]?
    let reasonCodes: [Ec2ClientTypes.ReportInstanceReasonCodes]?
    let startTime: ClientRuntime.Date?
    let status: Ec2ClientTypes.ReportStatusType?
}

extension ReportInstanceStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case dryRun = "dryRun"
        case endTime = "endTime"
        case instances = "instanceId"
        case reasonCodes = "reasonCode"
        case startTime = "startTime"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        var endTimeBuffer:ClientRuntime.Date? = nil
        if let endTimeDecoded = endTimeDecoded {
            endTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endTimeDecoded, format: .dateTime)
        }
        endTime = endTimeBuffer
        if containerValues.contains(.instances) {
            struct KeyVal0{struct InstanceId{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstanceId>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var instancesBuffer:[Swift.String]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Swift.String]()
                    for stringContainer0 in instancesContainer {
                        instancesBuffer?.append(stringContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        if containerValues.contains(.reasonCodes) {
            struct KeyVal0{struct item{}}
            let reasonCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .reasonCodes)
            if let reasonCodesWrappedContainer = reasonCodesWrappedContainer {
                let reasonCodesContainer = try reasonCodesWrappedContainer.decodeIfPresent([Ec2ClientTypes.ReportInstanceReasonCodes].self, forKey: .member)
                var reasonCodesBuffer:[Ec2ClientTypes.ReportInstanceReasonCodes]? = nil
                if let reasonCodesContainer = reasonCodesContainer {
                    reasonCodesBuffer = [Ec2ClientTypes.ReportInstanceReasonCodes]()
                    for enumContainer0 in reasonCodesContainer {
                        reasonCodesBuffer?.append(enumContainer0)
                    }
                }
                reasonCodes = reasonCodesBuffer
            } else {
                reasonCodes = []
            }
        } else {
            reasonCodes = nil
        }
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        var startTimeBuffer:ClientRuntime.Date? = nil
        if let startTimeDecoded = startTimeDecoded {
            startTimeBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startTimeDecoded, format: .dateTime)
        }
        startTime = startTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ReportStatusType.self, forKey: .status)
        status = statusDecoded
    }
}
