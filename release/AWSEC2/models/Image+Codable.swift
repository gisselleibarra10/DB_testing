// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture = "architecture"
        case blockDeviceMappings = "blockDeviceMapping"
        case bootMode = "bootMode"
        case creationDate = "creationDate"
        case deprecationTime = "deprecationTime"
        case description = "description"
        case enaSupport = "enaSupport"
        case hypervisor = "hypervisor"
        case imageId = "imageId"
        case imageLocation = "imageLocation"
        case imageOwnerAlias = "imageOwnerAlias"
        case imageType = "imageType"
        case kernelId = "kernelId"
        case name = "name"
        case ownerId = "imageOwnerId"
        case platform = "platform"
        case platformDetails = "platformDetails"
        case productCodes = "productCodes"
        case `public` = "isPublic"
        case ramdiskId = "ramdiskId"
        case rootDeviceName = "rootDeviceName"
        case rootDeviceType = "rootDeviceType"
        case sriovNetSupport = "sriovNetSupport"
        case state = "imageState"
        case stateReason = "stateReason"
        case tags = "tagSet"
        case tpmSupport = "tpmSupport"
        case usageOperation = "usageOperation"
        case virtualizationType = "virtualizationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let architecture = architecture {
            try container.encode(architecture, forKey: ClientRuntime.Key("Architecture"))
        }
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, blockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(blockdevicemapping0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let bootMode = bootMode {
            try container.encode(bootMode, forKey: ClientRuntime.Key("BootMode"))
        }
        if let creationDate = creationDate {
            try container.encode(creationDate, forKey: ClientRuntime.Key("CreationDate"))
        }
        if let deprecationTime = deprecationTime {
            try container.encode(deprecationTime, forKey: ClientRuntime.Key("DeprecationTime"))
        }
        if let description = description {
            try container.encode(description, forKey: ClientRuntime.Key("Description"))
        }
        if let enaSupport = enaSupport {
            try container.encode(enaSupport, forKey: ClientRuntime.Key("EnaSupport"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: ClientRuntime.Key("Hypervisor"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: ClientRuntime.Key("ImageId"))
        }
        if let imageLocation = imageLocation {
            try container.encode(imageLocation, forKey: ClientRuntime.Key("ImageLocation"))
        }
        if let imageOwnerAlias = imageOwnerAlias {
            try container.encode(imageOwnerAlias, forKey: ClientRuntime.Key("ImageOwnerAlias"))
        }
        if let imageType = imageType {
            try container.encode(imageType, forKey: ClientRuntime.Key("ImageType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: ClientRuntime.Key("KernelId"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: ClientRuntime.Key("ImageOwnerId"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: ClientRuntime.Key("Platform"))
        }
        if let platformDetails = platformDetails {
            try container.encode(platformDetails, forKey: ClientRuntime.Key("PlatformDetails"))
        }
        if let productCodes = productCodes {
            if !productCodes.isEmpty {
                for (index0, productcode0) in productCodes.enumerated() {
                    var productCodesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ProductCodes.\(index0.advanced(by: 1))"))
                    try productCodesContainer0.encode(productcode0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let `public` = `public` {
            try container.encode(`public`, forKey: ClientRuntime.Key("IsPublic"))
        }
        if let ramdiskId = ramdiskId {
            try container.encode(ramdiskId, forKey: ClientRuntime.Key("RamdiskId"))
        }
        if let rootDeviceName = rootDeviceName {
            try container.encode(rootDeviceName, forKey: ClientRuntime.Key("RootDeviceName"))
        }
        if let rootDeviceType = rootDeviceType {
            try container.encode(rootDeviceType, forKey: ClientRuntime.Key("RootDeviceType"))
        }
        if let sriovNetSupport = sriovNetSupport {
            try container.encode(sriovNetSupport, forKey: ClientRuntime.Key("SriovNetSupport"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("ImageState"))
        }
        if let stateReason = stateReason {
            try container.encode(stateReason, forKey: ClientRuntime.Key("StateReason"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let tpmSupport = tpmSupport {
            try container.encode(tpmSupport, forKey: ClientRuntime.Key("TpmSupport"))
        }
        if let usageOperation = usageOperation {
            try container.encode(usageOperation, forKey: ClientRuntime.Key("UsageOperation"))
        }
        if let virtualizationType = virtualizationType {
            try container.encode(virtualizationType, forKey: ClientRuntime.Key("VirtualizationType"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let architectureDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ArchitectureValues.self, forKey: .architecture)
        architecture = architectureDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageLocation)
        imageLocation = imageLocationDecoded
        let imageTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ImageTypeValues.self, forKey: .imageType)
        imageType = imageTypeDecoded
        let publicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .public)
        `public` = publicDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.PlatformValues.self, forKey: .platform)
        platform = platformDecoded
        let platformDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformDetails)
        platformDetails = platformDetailsDecoded
        let usageOperationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageOperation)
        usageOperation = usageOperationDecoded
        if containerValues.contains(.productCodes) {
            struct KeyVal0{struct item{}}
            let productCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .productCodes)
            if let productCodesWrappedContainer = productCodesWrappedContainer {
                let productCodesContainer = try productCodesWrappedContainer.decodeIfPresent([Ec2ClientTypes.ProductCode].self, forKey: .member)
                var productCodesBuffer:[Ec2ClientTypes.ProductCode]? = nil
                if let productCodesContainer = productCodesContainer {
                    productCodesBuffer = [Ec2ClientTypes.ProductCode]()
                    for structureContainer0 in productCodesContainer {
                        productCodesBuffer?.append(structureContainer0)
                    }
                }
                productCodes = productCodesBuffer
            } else {
                productCodes = []
            }
        } else {
            productCodes = nil
        }
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([Ec2ClientTypes.BlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[Ec2ClientTypes.BlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [Ec2ClientTypes.BlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enaSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.HypervisorType.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let imageOwnerAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOwnerAlias)
        imageOwnerAlias = imageOwnerAliasDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
        let rootDeviceTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.DeviceType.self, forKey: .rootDeviceType)
        rootDeviceType = rootDeviceTypeDecoded
        let sriovNetSupportDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sriovNetSupport)
        sriovNetSupport = sriovNetSupportDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.StateReason.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[Ec2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Ec2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let virtualizationTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.VirtualizationType.self, forKey: .virtualizationType)
        virtualizationType = virtualizationTypeDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.BootModeValues.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let tpmSupportDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.TpmSupportValues.self, forKey: .tpmSupport)
        tpmSupport = tpmSupportDecoded
        let deprecationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deprecationTime)
        deprecationTime = deprecationTimeDecoded
    }
}
