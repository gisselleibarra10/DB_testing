// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.PacketHeaderStatementRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationAddresses = "DestinationAddress"
        case destinationPorts = "DestinationPort"
        case destinationPrefixLists = "DestinationPrefixList"
        case protocols = "Protocol"
        case sourceAddresses = "SourceAddress"
        case sourcePorts = "SourcePort"
        case sourcePrefixLists = "SourcePrefixList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let destinationAddresses = destinationAddresses {
            if !destinationAddresses.isEmpty {
                for (index0, string0) in destinationAddresses.enumerated() {
                    var destinationAddressesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationAddress.\(index0.advanced(by: 1))"))
                    try destinationAddressesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var destinationAddressesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationAddress"))
                try destinationAddressesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let destinationPorts = destinationPorts {
            if !destinationPorts.isEmpty {
                for (index0, string0) in destinationPorts.enumerated() {
                    var destinationPortsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationPort.\(index0.advanced(by: 1))"))
                    try destinationPortsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var destinationPortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationPort"))
                try destinationPortsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let destinationPrefixLists = destinationPrefixLists {
            if !destinationPrefixLists.isEmpty {
                for (index0, string0) in destinationPrefixLists.enumerated() {
                    var destinationPrefixListsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationPrefixList.\(index0.advanced(by: 1))"))
                    try destinationPrefixListsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var destinationPrefixListsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("DestinationPrefixList"))
                try destinationPrefixListsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let protocols = protocols {
            if !protocols.isEmpty {
                for (index0, protocol0) in protocols.enumerated() {
                    var protocolsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Protocol.\(index0.advanced(by: 1))"))
                    try protocolsContainer0.encode(protocol0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var protocolsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Protocol"))
                try protocolsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourceAddresses = sourceAddresses {
            if !sourceAddresses.isEmpty {
                for (index0, string0) in sourceAddresses.enumerated() {
                    var sourceAddressesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceAddress.\(index0.advanced(by: 1))"))
                    try sourceAddressesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var sourceAddressesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourceAddress"))
                try sourceAddressesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourcePorts = sourcePorts {
            if !sourcePorts.isEmpty {
                for (index0, string0) in sourcePorts.enumerated() {
                    var sourcePortsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourcePort.\(index0.advanced(by: 1))"))
                    try sourcePortsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var sourcePortsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourcePort"))
                try sourcePortsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let sourcePrefixLists = sourcePrefixLists {
            if !sourcePrefixLists.isEmpty {
                for (index0, string0) in sourcePrefixLists.enumerated() {
                    var sourcePrefixListsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourcePrefixList.\(index0.advanced(by: 1))"))
                    try sourcePrefixListsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var sourcePrefixListsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SourcePrefixList"))
                try sourcePrefixListsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.sourceAddresses) {
            struct KeyVal0{struct item{}}
            let sourceAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .sourceAddresses)
            if let sourceAddressesWrappedContainer = sourceAddressesWrappedContainer {
                let sourceAddressesContainer = try sourceAddressesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourceAddressesBuffer:[Swift.String]? = nil
                if let sourceAddressesContainer = sourceAddressesContainer {
                    sourceAddressesBuffer = [Swift.String]()
                    for stringContainer0 in sourceAddressesContainer {
                        sourceAddressesBuffer?.append(stringContainer0)
                    }
                }
                sourceAddresses = sourceAddressesBuffer
            } else {
                sourceAddresses = []
            }
        } else {
            sourceAddresses = nil
        }
        if containerValues.contains(.destinationAddresses) {
            struct KeyVal0{struct item{}}
            let destinationAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .destinationAddresses)
            if let destinationAddressesWrappedContainer = destinationAddressesWrappedContainer {
                let destinationAddressesContainer = try destinationAddressesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var destinationAddressesBuffer:[Swift.String]? = nil
                if let destinationAddressesContainer = destinationAddressesContainer {
                    destinationAddressesBuffer = [Swift.String]()
                    for stringContainer0 in destinationAddressesContainer {
                        destinationAddressesBuffer?.append(stringContainer0)
                    }
                }
                destinationAddresses = destinationAddressesBuffer
            } else {
                destinationAddresses = []
            }
        } else {
            destinationAddresses = nil
        }
        if containerValues.contains(.sourcePorts) {
            struct KeyVal0{struct item{}}
            let sourcePortsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .sourcePorts)
            if let sourcePortsWrappedContainer = sourcePortsWrappedContainer {
                let sourcePortsContainer = try sourcePortsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourcePortsBuffer:[Swift.String]? = nil
                if let sourcePortsContainer = sourcePortsContainer {
                    sourcePortsBuffer = [Swift.String]()
                    for stringContainer0 in sourcePortsContainer {
                        sourcePortsBuffer?.append(stringContainer0)
                    }
                }
                sourcePorts = sourcePortsBuffer
            } else {
                sourcePorts = []
            }
        } else {
            sourcePorts = nil
        }
        if containerValues.contains(.destinationPorts) {
            struct KeyVal0{struct item{}}
            let destinationPortsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .destinationPorts)
            if let destinationPortsWrappedContainer = destinationPortsWrappedContainer {
                let destinationPortsContainer = try destinationPortsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var destinationPortsBuffer:[Swift.String]? = nil
                if let destinationPortsContainer = destinationPortsContainer {
                    destinationPortsBuffer = [Swift.String]()
                    for stringContainer0 in destinationPortsContainer {
                        destinationPortsBuffer?.append(stringContainer0)
                    }
                }
                destinationPorts = destinationPortsBuffer
            } else {
                destinationPorts = []
            }
        } else {
            destinationPorts = nil
        }
        if containerValues.contains(.sourcePrefixLists) {
            struct KeyVal0{struct item{}}
            let sourcePrefixListsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .sourcePrefixLists)
            if let sourcePrefixListsWrappedContainer = sourcePrefixListsWrappedContainer {
                let sourcePrefixListsContainer = try sourcePrefixListsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var sourcePrefixListsBuffer:[Swift.String]? = nil
                if let sourcePrefixListsContainer = sourcePrefixListsContainer {
                    sourcePrefixListsBuffer = [Swift.String]()
                    for stringContainer0 in sourcePrefixListsContainer {
                        sourcePrefixListsBuffer?.append(stringContainer0)
                    }
                }
                sourcePrefixLists = sourcePrefixListsBuffer
            } else {
                sourcePrefixLists = []
            }
        } else {
            sourcePrefixLists = nil
        }
        if containerValues.contains(.destinationPrefixLists) {
            struct KeyVal0{struct item{}}
            let destinationPrefixListsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .destinationPrefixLists)
            if let destinationPrefixListsWrappedContainer = destinationPrefixListsWrappedContainer {
                let destinationPrefixListsContainer = try destinationPrefixListsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var destinationPrefixListsBuffer:[Swift.String]? = nil
                if let destinationPrefixListsContainer = destinationPrefixListsContainer {
                    destinationPrefixListsBuffer = [Swift.String]()
                    for stringContainer0 in destinationPrefixListsContainer {
                        destinationPrefixListsBuffer?.append(stringContainer0)
                    }
                }
                destinationPrefixLists = destinationPrefixListsBuffer
            } else {
                destinationPrefixLists = []
            }
        } else {
            destinationPrefixLists = nil
        }
        if containerValues.contains(.protocols) {
            struct KeyVal0{struct item{}}
            let protocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .protocols)
            if let protocolsWrappedContainer = protocolsWrappedContainer {
                let protocolsContainer = try protocolsWrappedContainer.decodeIfPresent([EC2ClientTypes.ModelProtocol].self, forKey: .member)
                var protocolsBuffer:[EC2ClientTypes.ModelProtocol]? = nil
                if let protocolsContainer = protocolsContainer {
                    protocolsBuffer = [EC2ClientTypes.ModelProtocol]()
                    for enumContainer0 in protocolsContainer {
                        protocolsBuffer?.append(enumContainer0)
                    }
                }
                protocols = protocolsBuffer
            } else {
                protocols = []
            }
        } else {
            protocols = nil
        }
    }
}
