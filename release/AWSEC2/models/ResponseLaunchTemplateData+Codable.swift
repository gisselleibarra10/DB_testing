// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.ResponseLaunchTemplateData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings = "blockDeviceMappingSet"
        case capacityReservationSpecification = "capacityReservationSpecification"
        case cpuOptions = "cpuOptions"
        case creditSpecification = "creditSpecification"
        case disableApiStop = "disableApiStop"
        case disableApiTermination = "disableApiTermination"
        case ebsOptimized = "ebsOptimized"
        case elasticGpuSpecifications = "elasticGpuSpecificationSet"
        case elasticInferenceAccelerators = "elasticInferenceAcceleratorSet"
        case enclaveOptions = "enclaveOptions"
        case hibernationOptions = "hibernationOptions"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageId = "imageId"
        case instanceInitiatedShutdownBehavior = "instanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "instanceMarketOptions"
        case instanceRequirements = "instanceRequirements"
        case instanceType = "instanceType"
        case kernelId = "kernelId"
        case keyName = "keyName"
        case licenseSpecifications = "licenseSet"
        case maintenanceOptions = "maintenanceOptions"
        case metadataOptions = "metadataOptions"
        case monitoring = "monitoring"
        case networkInterfaces = "networkInterfaceSet"
        case placement = "placement"
        case privateDnsNameOptions = "privateDnsNameOptions"
        case ramDiskId = "ramDiskId"
        case securityGroupIds = "securityGroupIdSet"
        case securityGroups = "securityGroupSet"
        case tagSpecifications = "tagSpecificationSet"
        case userData = "userData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, launchtemplateblockdevicemapping0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMappingSet.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(launchtemplateblockdevicemapping0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let capacityReservationSpecification = capacityReservationSpecification {
            try container.encode(capacityReservationSpecification, forKey: ClientRuntime.Key("CapacityReservationSpecification"))
        }
        if let cpuOptions = cpuOptions {
            try container.encode(cpuOptions, forKey: ClientRuntime.Key("CpuOptions"))
        }
        if let creditSpecification = creditSpecification {
            try container.encode(creditSpecification, forKey: ClientRuntime.Key("CreditSpecification"))
        }
        if let disableApiStop = disableApiStop {
            try container.encode(disableApiStop, forKey: ClientRuntime.Key("DisableApiStop"))
        }
        if let disableApiTermination = disableApiTermination {
            try container.encode(disableApiTermination, forKey: ClientRuntime.Key("DisableApiTermination"))
        }
        if let ebsOptimized = ebsOptimized {
            try container.encode(ebsOptimized, forKey: ClientRuntime.Key("EbsOptimized"))
        }
        if let elasticGpuSpecifications = elasticGpuSpecifications {
            if !elasticGpuSpecifications.isEmpty {
                for (index0, elasticgpuspecificationresponse0) in elasticGpuSpecifications.enumerated() {
                    var elasticGpuSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticGpuSpecificationSet.\(index0.advanced(by: 1))"))
                    try elasticGpuSpecificationsContainer0.encode(elasticgpuspecificationresponse0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let elasticInferenceAccelerators = elasticInferenceAccelerators {
            if !elasticInferenceAccelerators.isEmpty {
                for (index0, launchtemplateelasticinferenceacceleratorresponse0) in elasticInferenceAccelerators.enumerated() {
                    var elasticInferenceAcceleratorsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticInferenceAcceleratorSet.\(index0.advanced(by: 1))"))
                    try elasticInferenceAcceleratorsContainer0.encode(launchtemplateelasticinferenceacceleratorresponse0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let enclaveOptions = enclaveOptions {
            try container.encode(enclaveOptions, forKey: ClientRuntime.Key("EnclaveOptions"))
        }
        if let hibernationOptions = hibernationOptions {
            try container.encode(hibernationOptions, forKey: ClientRuntime.Key("HibernationOptions"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: ClientRuntime.Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: ClientRuntime.Key("ImageId"))
        }
        if let instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior {
            try container.encode(instanceInitiatedShutdownBehavior, forKey: ClientRuntime.Key("InstanceInitiatedShutdownBehavior"))
        }
        if let instanceMarketOptions = instanceMarketOptions {
            try container.encode(instanceMarketOptions, forKey: ClientRuntime.Key("InstanceMarketOptions"))
        }
        if let instanceRequirements = instanceRequirements {
            try container.encode(instanceRequirements, forKey: ClientRuntime.Key("InstanceRequirements"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: ClientRuntime.Key("InstanceType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: ClientRuntime.Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: ClientRuntime.Key("KeyName"))
        }
        if let licenseSpecifications = licenseSpecifications {
            if !licenseSpecifications.isEmpty {
                for (index0, launchtemplatelicenseconfiguration0) in licenseSpecifications.enumerated() {
                    var licenseSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LicenseSet.\(index0.advanced(by: 1))"))
                    try licenseSpecificationsContainer0.encode(launchtemplatelicenseconfiguration0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let maintenanceOptions = maintenanceOptions {
            try container.encode(maintenanceOptions, forKey: ClientRuntime.Key("MaintenanceOptions"))
        }
        if let metadataOptions = metadataOptions {
            try container.encode(metadataOptions, forKey: ClientRuntime.Key("MetadataOptions"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: ClientRuntime.Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, launchtemplateinstancenetworkinterfacespecification0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterfaceSet.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(launchtemplateinstancenetworkinterfacespecification0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let placement = placement {
            try container.encode(placement, forKey: ClientRuntime.Key("Placement"))
        }
        if let privateDnsNameOptions = privateDnsNameOptions {
            try container.encode(privateDnsNameOptions, forKey: ClientRuntime.Key("PrivateDnsNameOptions"))
        }
        if let ramDiskId = ramDiskId {
            try container.encode(ramDiskId, forKey: ClientRuntime.Key("RamDiskId"))
        }
        if let securityGroupIds = securityGroupIds {
            if !securityGroupIds.isEmpty {
                for (index0, string0) in securityGroupIds.enumerated() {
                    var securityGroupIdsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroupIdSet.\(index0.advanced(by: 1))"))
                    try securityGroupIdsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, string0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroupSet.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, launchtemplatetagspecification0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSpecificationSet.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(launchtemplatetagspecification0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let userData = userData {
            try container.encode(userData, forKey: ClientRuntime.Key("UserData"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateIamInstanceProfileSpecification.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateBlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[Ec2ClientTypes.LaunchTemplateBlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [Ec2ClientTypes.LaunchTemplateBlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct item{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecification].self, forKey: .member)
                var networkInterfacesBuffer:[Ec2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecification]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [Ec2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecification]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplatesMonitoring.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplatePlacement.self, forKey: .placement)
        placement = placementDecoded
        let ramDiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramDiskId)
        ramDiskId = ramDiskIdDecoded
        let disableApiTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiTermination)
        disableApiTermination = disableApiTerminationDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ShutdownBehavior.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userData)
        userData = userDataDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateTagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[Ec2ClientTypes.LaunchTemplateTagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [Ec2ClientTypes.LaunchTemplateTagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
        if containerValues.contains(.elasticGpuSpecifications) {
            struct KeyVal0{struct item{}}
            let elasticGpuSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticGpuSpecifications)
            if let elasticGpuSpecificationsWrappedContainer = elasticGpuSpecificationsWrappedContainer {
                let elasticGpuSpecificationsContainer = try elasticGpuSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.ElasticGpuSpecificationResponse].self, forKey: .member)
                var elasticGpuSpecificationsBuffer:[Ec2ClientTypes.ElasticGpuSpecificationResponse]? = nil
                if let elasticGpuSpecificationsContainer = elasticGpuSpecificationsContainer {
                    elasticGpuSpecificationsBuffer = [Ec2ClientTypes.ElasticGpuSpecificationResponse]()
                    for structureContainer0 in elasticGpuSpecificationsContainer {
                        elasticGpuSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuSpecifications = elasticGpuSpecificationsBuffer
            } else {
                elasticGpuSpecifications = []
            }
        } else {
            elasticGpuSpecifications = nil
        }
        if containerValues.contains(.elasticInferenceAccelerators) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAccelerators)
            if let elasticInferenceAcceleratorsWrappedContainer = elasticInferenceAcceleratorsWrappedContainer {
                let elasticInferenceAcceleratorsContainer = try elasticInferenceAcceleratorsWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateElasticInferenceAcceleratorResponse].self, forKey: .member)
                var elasticInferenceAcceleratorsBuffer:[Ec2ClientTypes.LaunchTemplateElasticInferenceAcceleratorResponse]? = nil
                if let elasticInferenceAcceleratorsContainer = elasticInferenceAcceleratorsContainer {
                    elasticInferenceAcceleratorsBuffer = [Ec2ClientTypes.LaunchTemplateElasticInferenceAcceleratorResponse]()
                    for structureContainer0 in elasticInferenceAcceleratorsContainer {
                        elasticInferenceAcceleratorsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAccelerators = elasticInferenceAcceleratorsBuffer
            } else {
                elasticInferenceAccelerators = []
            }
        } else {
            elasticInferenceAccelerators = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct item{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct item{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateInstanceMarketOptions.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
        let creditSpecificationDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.CreditSpecification.self, forKey: .creditSpecification)
        creditSpecification = creditSpecificationDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateCpuOptions.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateCapacityReservationSpecificationResponse.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        if containerValues.contains(.licenseSpecifications) {
            struct KeyVal0{struct item{}}
            let licenseSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenseSpecifications)
            if let licenseSpecificationsWrappedContainer = licenseSpecificationsWrappedContainer {
                let licenseSpecificationsContainer = try licenseSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateLicenseConfiguration].self, forKey: .member)
                var licenseSpecificationsBuffer:[Ec2ClientTypes.LaunchTemplateLicenseConfiguration]? = nil
                if let licenseSpecificationsContainer = licenseSpecificationsContainer {
                    licenseSpecificationsBuffer = [Ec2ClientTypes.LaunchTemplateLicenseConfiguration]()
                    for structureContainer0 in licenseSpecificationsContainer {
                        licenseSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                licenseSpecifications = licenseSpecificationsBuffer
            } else {
                licenseSpecifications = []
            }
        } else {
            licenseSpecifications = nil
        }
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateHibernationOptions.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateInstanceMetadataOptions.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateEnclaveOptions.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let instanceRequirementsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.InstanceRequirements.self, forKey: .instanceRequirements)
        instanceRequirements = instanceRequirementsDecoded
        let privateDnsNameOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplatePrivateDnsNameOptions.self, forKey: .privateDnsNameOptions)
        privateDnsNameOptions = privateDnsNameOptionsDecoded
        let maintenanceOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LaunchTemplateInstanceMaintenanceOptions.self, forKey: .maintenanceOptions)
        maintenanceOptions = maintenanceOptionsDecoded
        let disableApiStopDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiStop)
        disableApiStop = disableApiStopDecoded
    }
}
