// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct DescribeInstanceAttributeOutputResponseBody: Swift.Equatable {
    let groups: [Ec2ClientTypes.GroupIdentifier]?
    let blockDeviceMappings: [Ec2ClientTypes.InstanceBlockDeviceMapping]?
    let disableApiTermination: Ec2ClientTypes.AttributeBooleanValue?
    let enaSupport: Ec2ClientTypes.AttributeBooleanValue?
    let enclaveOptions: Ec2ClientTypes.EnclaveOptions?
    let ebsOptimized: Ec2ClientTypes.AttributeBooleanValue?
    let instanceId: Swift.String?
    let instanceInitiatedShutdownBehavior: Ec2ClientTypes.AttributeValue?
    let instanceType: Ec2ClientTypes.AttributeValue?
    let kernelId: Ec2ClientTypes.AttributeValue?
    let productCodes: [Ec2ClientTypes.ProductCode]?
    let ramdiskId: Ec2ClientTypes.AttributeValue?
    let rootDeviceName: Ec2ClientTypes.AttributeValue?
    let sourceDestCheck: Ec2ClientTypes.AttributeBooleanValue?
    let sriovNetSupport: Ec2ClientTypes.AttributeValue?
    let userData: Ec2ClientTypes.AttributeValue?
    let disableApiStop: Ec2ClientTypes.AttributeBooleanValue?
}

extension DescribeInstanceAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings = "blockDeviceMapping"
        case disableApiStop = "disableApiStop"
        case disableApiTermination = "disableApiTermination"
        case ebsOptimized = "ebsOptimized"
        case enaSupport = "enaSupport"
        case enclaveOptions = "enclaveOptions"
        case groups = "groupSet"
        case instanceId = "instanceId"
        case instanceInitiatedShutdownBehavior = "instanceInitiatedShutdownBehavior"
        case instanceType = "instanceType"
        case kernelId = "kernel"
        case productCodes = "productCodes"
        case ramdiskId = "ramdisk"
        case rootDeviceName = "rootDeviceName"
        case sourceDestCheck = "sourceDestCheck"
        case sriovNetSupport = "sriovNetSupport"
        case userData = "userData"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.groups) {
            struct KeyVal0{struct item{}}
            let groupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .groups)
            if let groupsWrappedContainer = groupsWrappedContainer {
                let groupsContainer = try groupsWrappedContainer.decodeIfPresent([Ec2ClientTypes.GroupIdentifier].self, forKey: .member)
                var groupsBuffer:[Ec2ClientTypes.GroupIdentifier]? = nil
                if let groupsContainer = groupsContainer {
                    groupsBuffer = [Ec2ClientTypes.GroupIdentifier]()
                    for structureContainer0 in groupsContainer {
                        groupsBuffer?.append(structureContainer0)
                    }
                }
                groups = groupsBuffer
            } else {
                groups = []
            }
        } else {
            groups = nil
        }
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct item{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([Ec2ClientTypes.InstanceBlockDeviceMapping].self, forKey: .member)
                var blockDeviceMappingsBuffer:[Ec2ClientTypes.InstanceBlockDeviceMapping]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [Ec2ClientTypes.InstanceBlockDeviceMapping]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        let disableApiTerminationDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeBooleanValue.self, forKey: .disableApiTermination)
        disableApiTermination = disableApiTerminationDecoded
        let enaSupportDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeBooleanValue.self, forKey: .enaSupport)
        enaSupport = enaSupportDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.EnclaveOptions.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeBooleanValue.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let kernelIdDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        if containerValues.contains(.productCodes) {
            struct KeyVal0{struct item{}}
            let productCodesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .productCodes)
            if let productCodesWrappedContainer = productCodesWrappedContainer {
                let productCodesContainer = try productCodesWrappedContainer.decodeIfPresent([Ec2ClientTypes.ProductCode].self, forKey: .member)
                var productCodesBuffer:[Ec2ClientTypes.ProductCode]? = nil
                if let productCodesContainer = productCodesContainer {
                    productCodesBuffer = [Ec2ClientTypes.ProductCode]()
                    for structureContainer0 in productCodesContainer {
                        productCodesBuffer?.append(structureContainer0)
                    }
                }
                productCodes = productCodesBuffer
            } else {
                productCodes = []
            }
        } else {
            productCodes = nil
        }
        let ramdiskIdDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .ramdiskId)
        ramdiskId = ramdiskIdDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
        let sourceDestCheckDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeBooleanValue.self, forKey: .sourceDestCheck)
        sourceDestCheck = sourceDestCheckDecoded
        let sriovNetSupportDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .sriovNetSupport)
        sriovNetSupport = sriovNetSupportDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeValue.self, forKey: .userData)
        userData = userDataDecoded
        let disableApiStopDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AttributeBooleanValue.self, forKey: .disableApiStop)
        disableApiStop = disableApiStopDecoded
    }
}
