// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct GetReservedInstancesExchangeQuoteOutputResponseBody: Swift.Equatable {
    let currencyCode: Swift.String?
    let isValidExchange: Swift.Bool?
    let outputReservedInstancesWillExpireAt: ClientRuntime.Date?
    let paymentDue: Swift.String?
    let reservedInstanceValueRollup: Ec2ClientTypes.ReservationValue?
    let reservedInstanceValueSet: [Ec2ClientTypes.ReservedInstanceReservationValue]?
    let targetConfigurationValueRollup: Ec2ClientTypes.ReservationValue?
    let targetConfigurationValueSet: [Ec2ClientTypes.TargetReservationValue]?
    let validationFailureReason: Swift.String?
}

extension GetReservedInstancesExchangeQuoteOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "currencyCode"
        case isValidExchange = "isValidExchange"
        case outputReservedInstancesWillExpireAt = "outputReservedInstancesWillExpireAt"
        case paymentDue = "paymentDue"
        case reservedInstanceValueRollup = "reservedInstanceValueRollup"
        case reservedInstanceValueSet = "reservedInstanceValueSet"
        case targetConfigurationValueRollup = "targetConfigurationValueRollup"
        case targetConfigurationValueSet = "targetConfigurationValueSet"
        case validationFailureReason = "validationFailureReason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let isValidExchangeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isValidExchange)
        isValidExchange = isValidExchangeDecoded
        let outputReservedInstancesWillExpireAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputReservedInstancesWillExpireAt)
        var outputReservedInstancesWillExpireAtBuffer:ClientRuntime.Date? = nil
        if let outputReservedInstancesWillExpireAtDecoded = outputReservedInstancesWillExpireAtDecoded {
            outputReservedInstancesWillExpireAtBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(outputReservedInstancesWillExpireAtDecoded, format: .dateTime)
        }
        outputReservedInstancesWillExpireAt = outputReservedInstancesWillExpireAtBuffer
        let paymentDueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentDue)
        paymentDue = paymentDueDecoded
        let reservedInstanceValueRollupDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ReservationValue.self, forKey: .reservedInstanceValueRollup)
        reservedInstanceValueRollup = reservedInstanceValueRollupDecoded
        if containerValues.contains(.reservedInstanceValueSet) {
            struct KeyVal0{struct item{}}
            let reservedInstanceValueSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .reservedInstanceValueSet)
            if let reservedInstanceValueSetWrappedContainer = reservedInstanceValueSetWrappedContainer {
                let reservedInstanceValueSetContainer = try reservedInstanceValueSetWrappedContainer.decodeIfPresent([Ec2ClientTypes.ReservedInstanceReservationValue].self, forKey: .member)
                var reservedInstanceValueSetBuffer:[Ec2ClientTypes.ReservedInstanceReservationValue]? = nil
                if let reservedInstanceValueSetContainer = reservedInstanceValueSetContainer {
                    reservedInstanceValueSetBuffer = [Ec2ClientTypes.ReservedInstanceReservationValue]()
                    for structureContainer0 in reservedInstanceValueSetContainer {
                        reservedInstanceValueSetBuffer?.append(structureContainer0)
                    }
                }
                reservedInstanceValueSet = reservedInstanceValueSetBuffer
            } else {
                reservedInstanceValueSet = []
            }
        } else {
            reservedInstanceValueSet = nil
        }
        let targetConfigurationValueRollupDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ReservationValue.self, forKey: .targetConfigurationValueRollup)
        targetConfigurationValueRollup = targetConfigurationValueRollupDecoded
        if containerValues.contains(.targetConfigurationValueSet) {
            struct KeyVal0{struct item{}}
            let targetConfigurationValueSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .targetConfigurationValueSet)
            if let targetConfigurationValueSetWrappedContainer = targetConfigurationValueSetWrappedContainer {
                let targetConfigurationValueSetContainer = try targetConfigurationValueSetWrappedContainer.decodeIfPresent([Ec2ClientTypes.TargetReservationValue].self, forKey: .member)
                var targetConfigurationValueSetBuffer:[Ec2ClientTypes.TargetReservationValue]? = nil
                if let targetConfigurationValueSetContainer = targetConfigurationValueSetContainer {
                    targetConfigurationValueSetBuffer = [Ec2ClientTypes.TargetReservationValue]()
                    for structureContainer0 in targetConfigurationValueSetContainer {
                        targetConfigurationValueSetBuffer?.append(structureContainer0)
                    }
                }
                targetConfigurationValueSet = targetConfigurationValueSetBuffer
            } else {
                targetConfigurationValueSet = []
            }
        } else {
            targetConfigurationValueSet = nil
        }
        let validationFailureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationFailureReason)
        validationFailureReason = validationFailureReasonDecoded
    }
}
