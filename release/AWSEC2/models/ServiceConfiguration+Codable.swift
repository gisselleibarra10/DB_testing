// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.ServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceRequired = "acceptanceRequired"
        case availabilityZones = "availabilityZoneSet"
        case baseEndpointDnsNames = "baseEndpointDnsNameSet"
        case gatewayLoadBalancerArns = "gatewayLoadBalancerArnSet"
        case managesVpcEndpoints = "managesVpcEndpoints"
        case networkLoadBalancerArns = "networkLoadBalancerArnSet"
        case payerResponsibility = "payerResponsibility"
        case privateDnsName = "privateDnsName"
        case privateDnsNameConfiguration = "privateDnsNameConfiguration"
        case serviceId = "serviceId"
        case serviceName = "serviceName"
        case serviceState = "serviceState"
        case serviceType = "serviceType"
        case supportedIpAddressTypes = "supportedIpAddressTypeSet"
        case tags = "tagSet"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let acceptanceRequired = acceptanceRequired {
            try container.encode(acceptanceRequired, forKey: ClientRuntime.Key("AcceptanceRequired"))
        }
        if let availabilityZones = availabilityZones {
            if !availabilityZones.isEmpty {
                for (index0, string0) in availabilityZones.enumerated() {
                    var availabilityZonesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZoneSet.\(index0.advanced(by: 1))"))
                    try availabilityZonesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var availabilityZonesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AvailabilityZoneSet"))
                try availabilityZonesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let baseEndpointDnsNames = baseEndpointDnsNames {
            if !baseEndpointDnsNames.isEmpty {
                for (index0, string0) in baseEndpointDnsNames.enumerated() {
                    var baseEndpointDnsNamesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BaseEndpointDnsNameSet.\(index0.advanced(by: 1))"))
                    try baseEndpointDnsNamesContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var baseEndpointDnsNamesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BaseEndpointDnsNameSet"))
                try baseEndpointDnsNamesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let gatewayLoadBalancerArns = gatewayLoadBalancerArns {
            if !gatewayLoadBalancerArns.isEmpty {
                for (index0, string0) in gatewayLoadBalancerArns.enumerated() {
                    var gatewayLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GatewayLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try gatewayLoadBalancerArnsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var gatewayLoadBalancerArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("GatewayLoadBalancerArnSet"))
                try gatewayLoadBalancerArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let managesVpcEndpoints = managesVpcEndpoints {
            try container.encode(managesVpcEndpoints, forKey: ClientRuntime.Key("ManagesVpcEndpoints"))
        }
        if let networkLoadBalancerArns = networkLoadBalancerArns {
            if !networkLoadBalancerArns.isEmpty {
                for (index0, string0) in networkLoadBalancerArns.enumerated() {
                    var networkLoadBalancerArnsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkLoadBalancerArnSet.\(index0.advanced(by: 1))"))
                    try networkLoadBalancerArnsContainer0.encode(string0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var networkLoadBalancerArnsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkLoadBalancerArnSet"))
                try networkLoadBalancerArnsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let payerResponsibility = payerResponsibility {
            try container.encode(payerResponsibility, forKey: ClientRuntime.Key("PayerResponsibility"))
        }
        if let privateDnsName = privateDnsName {
            try container.encode(privateDnsName, forKey: ClientRuntime.Key("PrivateDnsName"))
        }
        if let privateDnsNameConfiguration = privateDnsNameConfiguration {
            try container.encode(privateDnsNameConfiguration, forKey: ClientRuntime.Key("PrivateDnsNameConfiguration"))
        }
        if let serviceId = serviceId {
            try container.encode(serviceId, forKey: ClientRuntime.Key("ServiceId"))
        }
        if let serviceName = serviceName {
            try container.encode(serviceName, forKey: ClientRuntime.Key("ServiceName"))
        }
        if let serviceState = serviceState {
            try container.encode(serviceState, forKey: ClientRuntime.Key("ServiceState"))
        }
        if let serviceType = serviceType {
            if !serviceType.isEmpty {
                for (index0, servicetypedetail0) in serviceType.enumerated() {
                    var serviceTypeContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceType.\(index0.advanced(by: 1))"))
                    try serviceTypeContainer0.encode(servicetypedetail0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var serviceTypeContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ServiceType"))
                try serviceTypeContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let supportedIpAddressTypes = supportedIpAddressTypes {
            if !supportedIpAddressTypes.isEmpty {
                for (index0, serviceconnectivitytype0) in supportedIpAddressTypes.enumerated() {
                    var supportedIpAddressTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedIpAddressTypeSet.\(index0.advanced(by: 1))"))
                    try supportedIpAddressTypesContainer0.encode(serviceconnectivitytype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedIpAddressTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedIpAddressTypeSet"))
                try supportedIpAddressTypesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.serviceType) {
            struct KeyVal0{struct item{}}
            let serviceTypeWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .serviceType)
            if let serviceTypeWrappedContainer = serviceTypeWrappedContainer {
                let serviceTypeContainer = try serviceTypeWrappedContainer.decodeIfPresent([EC2ClientTypes.ServiceTypeDetail].self, forKey: .member)
                var serviceTypeBuffer:[EC2ClientTypes.ServiceTypeDetail]? = nil
                if let serviceTypeContainer = serviceTypeContainer {
                    serviceTypeBuffer = [EC2ClientTypes.ServiceTypeDetail]()
                    for structureContainer0 in serviceTypeContainer {
                        serviceTypeBuffer?.append(structureContainer0)
                    }
                }
                serviceType = serviceTypeBuffer
            } else {
                serviceType = []
            }
        } else {
            serviceType = nil
        }
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceStateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.ServiceState.self, forKey: .serviceState)
        serviceState = serviceStateDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct item{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var availabilityZonesBuffer:[Swift.String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [Swift.String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let acceptanceRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptanceRequired)
        acceptanceRequired = acceptanceRequiredDecoded
        let managesVpcEndpointsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .managesVpcEndpoints)
        managesVpcEndpoints = managesVpcEndpointsDecoded
        if containerValues.contains(.networkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let networkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .networkLoadBalancerArns)
            if let networkLoadBalancerArnsWrappedContainer = networkLoadBalancerArnsWrappedContainer {
                let networkLoadBalancerArnsContainer = try networkLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var networkLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let networkLoadBalancerArnsContainer = networkLoadBalancerArnsContainer {
                    networkLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in networkLoadBalancerArnsContainer {
                        networkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                networkLoadBalancerArns = networkLoadBalancerArnsBuffer
            } else {
                networkLoadBalancerArns = []
            }
        } else {
            networkLoadBalancerArns = nil
        }
        if containerValues.contains(.gatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let gatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .gatewayLoadBalancerArns)
            if let gatewayLoadBalancerArnsWrappedContainer = gatewayLoadBalancerArnsWrappedContainer {
                let gatewayLoadBalancerArnsContainer = try gatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var gatewayLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let gatewayLoadBalancerArnsContainer = gatewayLoadBalancerArnsContainer {
                    gatewayLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in gatewayLoadBalancerArnsContainer {
                        gatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                gatewayLoadBalancerArns = gatewayLoadBalancerArnsBuffer
            } else {
                gatewayLoadBalancerArns = []
            }
        } else {
            gatewayLoadBalancerArns = nil
        }
        if containerValues.contains(.supportedIpAddressTypes) {
            struct KeyVal0{struct item{}}
            let supportedIpAddressTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedIpAddressTypes)
            if let supportedIpAddressTypesWrappedContainer = supportedIpAddressTypesWrappedContainer {
                let supportedIpAddressTypesContainer = try supportedIpAddressTypesWrappedContainer.decodeIfPresent([EC2ClientTypes.ServiceConnectivityType].self, forKey: .member)
                var supportedIpAddressTypesBuffer:[EC2ClientTypes.ServiceConnectivityType]? = nil
                if let supportedIpAddressTypesContainer = supportedIpAddressTypesContainer {
                    supportedIpAddressTypesBuffer = [EC2ClientTypes.ServiceConnectivityType]()
                    for enumContainer0 in supportedIpAddressTypesContainer {
                        supportedIpAddressTypesBuffer?.append(enumContainer0)
                    }
                }
                supportedIpAddressTypes = supportedIpAddressTypesBuffer
            } else {
                supportedIpAddressTypes = []
            }
        } else {
            supportedIpAddressTypes = nil
        }
        if containerValues.contains(.baseEndpointDnsNames) {
            struct KeyVal0{struct item{}}
            let baseEndpointDnsNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .baseEndpointDnsNames)
            if let baseEndpointDnsNamesWrappedContainer = baseEndpointDnsNamesWrappedContainer {
                let baseEndpointDnsNamesContainer = try baseEndpointDnsNamesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var baseEndpointDnsNamesBuffer:[Swift.String]? = nil
                if let baseEndpointDnsNamesContainer = baseEndpointDnsNamesContainer {
                    baseEndpointDnsNamesBuffer = [Swift.String]()
                    for stringContainer0 in baseEndpointDnsNamesContainer {
                        baseEndpointDnsNamesBuffer?.append(stringContainer0)
                    }
                }
                baseEndpointDnsNames = baseEndpointDnsNamesBuffer
            } else {
                baseEndpointDnsNames = []
            }
        } else {
            baseEndpointDnsNames = nil
        }
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateDnsNameConfigurationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PrivateDnsNameConfiguration.self, forKey: .privateDnsNameConfiguration)
        privateDnsNameConfiguration = privateDnsNameConfigurationDecoded
        let payerResponsibilityDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PayerResponsibility.self, forKey: .payerResponsibility)
        payerResponsibility = payerResponsibilityDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([EC2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[EC2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [EC2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}
