// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.InstanceTypeInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRecoverySupported = "autoRecoverySupported"
        case bareMetal = "bareMetal"
        case burstablePerformanceSupported = "burstablePerformanceSupported"
        case currentGeneration = "currentGeneration"
        case dedicatedHostsSupported = "dedicatedHostsSupported"
        case ebsInfo = "ebsInfo"
        case fpgaInfo = "fpgaInfo"
        case freeTierEligible = "freeTierEligible"
        case gpuInfo = "gpuInfo"
        case hibernationSupported = "hibernationSupported"
        case hypervisor = "hypervisor"
        case inferenceAcceleratorInfo = "inferenceAcceleratorInfo"
        case instanceStorageInfo = "instanceStorageInfo"
        case instanceStorageSupported = "instanceStorageSupported"
        case instanceType = "instanceType"
        case memoryInfo = "memoryInfo"
        case networkInfo = "networkInfo"
        case placementGroupInfo = "placementGroupInfo"
        case processorInfo = "processorInfo"
        case supportedBootModes = "supportedBootModes"
        case supportedRootDeviceTypes = "supportedRootDeviceTypes"
        case supportedUsageClasses = "supportedUsageClasses"
        case supportedVirtualizationTypes = "supportedVirtualizationTypes"
        case vCpuInfo = "vCpuInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let autoRecoverySupported = autoRecoverySupported {
            try container.encode(autoRecoverySupported, forKey: ClientRuntime.Key("AutoRecoverySupported"))
        }
        if let bareMetal = bareMetal {
            try container.encode(bareMetal, forKey: ClientRuntime.Key("BareMetal"))
        }
        if let burstablePerformanceSupported = burstablePerformanceSupported {
            try container.encode(burstablePerformanceSupported, forKey: ClientRuntime.Key("BurstablePerformanceSupported"))
        }
        if let currentGeneration = currentGeneration {
            try container.encode(currentGeneration, forKey: ClientRuntime.Key("CurrentGeneration"))
        }
        if let dedicatedHostsSupported = dedicatedHostsSupported {
            try container.encode(dedicatedHostsSupported, forKey: ClientRuntime.Key("DedicatedHostsSupported"))
        }
        if let ebsInfo = ebsInfo {
            try container.encode(ebsInfo, forKey: ClientRuntime.Key("EbsInfo"))
        }
        if let fpgaInfo = fpgaInfo {
            try container.encode(fpgaInfo, forKey: ClientRuntime.Key("FpgaInfo"))
        }
        if let freeTierEligible = freeTierEligible {
            try container.encode(freeTierEligible, forKey: ClientRuntime.Key("FreeTierEligible"))
        }
        if let gpuInfo = gpuInfo {
            try container.encode(gpuInfo, forKey: ClientRuntime.Key("GpuInfo"))
        }
        if let hibernationSupported = hibernationSupported {
            try container.encode(hibernationSupported, forKey: ClientRuntime.Key("HibernationSupported"))
        }
        if let hypervisor = hypervisor {
            try container.encode(hypervisor, forKey: ClientRuntime.Key("Hypervisor"))
        }
        if let inferenceAcceleratorInfo = inferenceAcceleratorInfo {
            try container.encode(inferenceAcceleratorInfo, forKey: ClientRuntime.Key("InferenceAcceleratorInfo"))
        }
        if let instanceStorageInfo = instanceStorageInfo {
            try container.encode(instanceStorageInfo, forKey: ClientRuntime.Key("InstanceStorageInfo"))
        }
        if let instanceStorageSupported = instanceStorageSupported {
            try container.encode(instanceStorageSupported, forKey: ClientRuntime.Key("InstanceStorageSupported"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: ClientRuntime.Key("InstanceType"))
        }
        if let memoryInfo = memoryInfo {
            try container.encode(memoryInfo, forKey: ClientRuntime.Key("MemoryInfo"))
        }
        if let networkInfo = networkInfo {
            try container.encode(networkInfo, forKey: ClientRuntime.Key("NetworkInfo"))
        }
        if let placementGroupInfo = placementGroupInfo {
            try container.encode(placementGroupInfo, forKey: ClientRuntime.Key("PlacementGroupInfo"))
        }
        if let processorInfo = processorInfo {
            try container.encode(processorInfo, forKey: ClientRuntime.Key("ProcessorInfo"))
        }
        if let supportedBootModes = supportedBootModes {
            if !supportedBootModes.isEmpty {
                for (index0, bootmodetype0) in supportedBootModes.enumerated() {
                    var supportedBootModesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedBootModes.\(index0.advanced(by: 1))"))
                    try supportedBootModesContainer0.encode(bootmodetype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedBootModesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedBootModes"))
                try supportedBootModesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let supportedRootDeviceTypes = supportedRootDeviceTypes {
            if !supportedRootDeviceTypes.isEmpty {
                for (index0, rootdevicetype0) in supportedRootDeviceTypes.enumerated() {
                    var supportedRootDeviceTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedRootDeviceTypes.\(index0.advanced(by: 1))"))
                    try supportedRootDeviceTypesContainer0.encode(rootdevicetype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedRootDeviceTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedRootDeviceTypes"))
                try supportedRootDeviceTypesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let supportedUsageClasses = supportedUsageClasses {
            if !supportedUsageClasses.isEmpty {
                for (index0, usageclasstype0) in supportedUsageClasses.enumerated() {
                    var supportedUsageClassesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedUsageClasses.\(index0.advanced(by: 1))"))
                    try supportedUsageClassesContainer0.encode(usageclasstype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedUsageClassesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedUsageClasses"))
                try supportedUsageClassesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let supportedVirtualizationTypes = supportedVirtualizationTypes {
            if !supportedVirtualizationTypes.isEmpty {
                for (index0, virtualizationtype0) in supportedVirtualizationTypes.enumerated() {
                    var supportedVirtualizationTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedVirtualizationTypes.\(index0.advanced(by: 1))"))
                    try supportedVirtualizationTypesContainer0.encode(virtualizationtype0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var supportedVirtualizationTypesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SupportedVirtualizationTypes"))
                try supportedVirtualizationTypesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let vCpuInfo = vCpuInfo {
            try container.encode(vCpuInfo, forKey: ClientRuntime.Key("VCpuInfo"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let freeTierEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .freeTierEligible)
        freeTierEligible = freeTierEligibleDecoded
        if containerValues.contains(.supportedUsageClasses) {
            struct KeyVal0{struct item{}}
            let supportedUsageClassesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedUsageClasses)
            if let supportedUsageClassesWrappedContainer = supportedUsageClassesWrappedContainer {
                let supportedUsageClassesContainer = try supportedUsageClassesWrappedContainer.decodeIfPresent([EC2ClientTypes.UsageClassType].self, forKey: .member)
                var supportedUsageClassesBuffer:[EC2ClientTypes.UsageClassType]? = nil
                if let supportedUsageClassesContainer = supportedUsageClassesContainer {
                    supportedUsageClassesBuffer = [EC2ClientTypes.UsageClassType]()
                    for enumContainer0 in supportedUsageClassesContainer {
                        supportedUsageClassesBuffer?.append(enumContainer0)
                    }
                }
                supportedUsageClasses = supportedUsageClassesBuffer
            } else {
                supportedUsageClasses = []
            }
        } else {
            supportedUsageClasses = nil
        }
        if containerValues.contains(.supportedRootDeviceTypes) {
            struct KeyVal0{struct item{}}
            let supportedRootDeviceTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedRootDeviceTypes)
            if let supportedRootDeviceTypesWrappedContainer = supportedRootDeviceTypesWrappedContainer {
                let supportedRootDeviceTypesContainer = try supportedRootDeviceTypesWrappedContainer.decodeIfPresent([EC2ClientTypes.RootDeviceType].self, forKey: .member)
                var supportedRootDeviceTypesBuffer:[EC2ClientTypes.RootDeviceType]? = nil
                if let supportedRootDeviceTypesContainer = supportedRootDeviceTypesContainer {
                    supportedRootDeviceTypesBuffer = [EC2ClientTypes.RootDeviceType]()
                    for enumContainer0 in supportedRootDeviceTypesContainer {
                        supportedRootDeviceTypesBuffer?.append(enumContainer0)
                    }
                }
                supportedRootDeviceTypes = supportedRootDeviceTypesBuffer
            } else {
                supportedRootDeviceTypes = []
            }
        } else {
            supportedRootDeviceTypes = nil
        }
        if containerValues.contains(.supportedVirtualizationTypes) {
            struct KeyVal0{struct item{}}
            let supportedVirtualizationTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedVirtualizationTypes)
            if let supportedVirtualizationTypesWrappedContainer = supportedVirtualizationTypesWrappedContainer {
                let supportedVirtualizationTypesContainer = try supportedVirtualizationTypesWrappedContainer.decodeIfPresent([EC2ClientTypes.VirtualizationType].self, forKey: .member)
                var supportedVirtualizationTypesBuffer:[EC2ClientTypes.VirtualizationType]? = nil
                if let supportedVirtualizationTypesContainer = supportedVirtualizationTypesContainer {
                    supportedVirtualizationTypesBuffer = [EC2ClientTypes.VirtualizationType]()
                    for enumContainer0 in supportedVirtualizationTypesContainer {
                        supportedVirtualizationTypesBuffer?.append(enumContainer0)
                    }
                }
                supportedVirtualizationTypes = supportedVirtualizationTypesBuffer
            } else {
                supportedVirtualizationTypes = []
            }
        } else {
            supportedVirtualizationTypes = nil
        }
        let bareMetalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bareMetal)
        bareMetal = bareMetalDecoded
        let hypervisorDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceTypeHypervisor.self, forKey: .hypervisor)
        hypervisor = hypervisorDecoded
        let processorInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.ProcessorInfo.self, forKey: .processorInfo)
        processorInfo = processorInfoDecoded
        let vCpuInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.VCpuInfo.self, forKey: .vCpuInfo)
        vCpuInfo = vCpuInfoDecoded
        let memoryInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.MemoryInfo.self, forKey: .memoryInfo)
        memoryInfo = memoryInfoDecoded
        let instanceStorageSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .instanceStorageSupported)
        instanceStorageSupported = instanceStorageSupportedDecoded
        let instanceStorageInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceStorageInfo.self, forKey: .instanceStorageInfo)
        instanceStorageInfo = instanceStorageInfoDecoded
        let ebsInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.EbsInfo.self, forKey: .ebsInfo)
        ebsInfo = ebsInfoDecoded
        let networkInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.NetworkInfo.self, forKey: .networkInfo)
        networkInfo = networkInfoDecoded
        let gpuInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.GpuInfo.self, forKey: .gpuInfo)
        gpuInfo = gpuInfoDecoded
        let fpgaInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.FpgaInfo.self, forKey: .fpgaInfo)
        fpgaInfo = fpgaInfoDecoded
        let placementGroupInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PlacementGroupInfo.self, forKey: .placementGroupInfo)
        placementGroupInfo = placementGroupInfoDecoded
        let inferenceAcceleratorInfoDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InferenceAcceleratorInfo.self, forKey: .inferenceAcceleratorInfo)
        inferenceAcceleratorInfo = inferenceAcceleratorInfoDecoded
        let hibernationSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hibernationSupported)
        hibernationSupported = hibernationSupportedDecoded
        let burstablePerformanceSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .burstablePerformanceSupported)
        burstablePerformanceSupported = burstablePerformanceSupportedDecoded
        let dedicatedHostsSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dedicatedHostsSupported)
        dedicatedHostsSupported = dedicatedHostsSupportedDecoded
        let autoRecoverySupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoRecoverySupported)
        autoRecoverySupported = autoRecoverySupportedDecoded
        if containerValues.contains(.supportedBootModes) {
            struct KeyVal0{struct item{}}
            let supportedBootModesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .supportedBootModes)
            if let supportedBootModesWrappedContainer = supportedBootModesWrappedContainer {
                let supportedBootModesContainer = try supportedBootModesWrappedContainer.decodeIfPresent([EC2ClientTypes.BootModeType].self, forKey: .member)
                var supportedBootModesBuffer:[EC2ClientTypes.BootModeType]? = nil
                if let supportedBootModesContainer = supportedBootModesContainer {
                    supportedBootModesBuffer = [EC2ClientTypes.BootModeType]()
                    for enumContainer0 in supportedBootModesContainer {
                        supportedBootModesBuffer?.append(enumContainer0)
                    }
                }
                supportedBootModes = supportedBootModesBuffer
            } else {
                supportedBootModes = []
            }
        } else {
            supportedBootModes = nil
        }
    }
}
