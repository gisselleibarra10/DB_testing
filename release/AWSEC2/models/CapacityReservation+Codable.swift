// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.CapacityReservation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case availabilityZoneId = "availabilityZoneId"
        case availableInstanceCount = "availableInstanceCount"
        case capacityAllocations = "capacityAllocationSet"
        case capacityReservationArn = "capacityReservationArn"
        case capacityReservationFleetId = "capacityReservationFleetId"
        case capacityReservationId = "capacityReservationId"
        case createDate = "createDate"
        case ebsOptimized = "ebsOptimized"
        case endDate = "endDate"
        case endDateType = "endDateType"
        case ephemeralStorage = "ephemeralStorage"
        case instanceMatchCriteria = "instanceMatchCriteria"
        case instancePlatform = "instancePlatform"
        case instanceType = "instanceType"
        case outpostArn = "outpostArn"
        case ownerId = "ownerId"
        case placementGroupArn = "placementGroupArn"
        case startDate = "startDate"
        case state = "state"
        case tags = "tagSet"
        case tenancy = "tenancy"
        case totalInstanceCount = "totalInstanceCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneId = availabilityZoneId {
            try container.encode(availabilityZoneId, forKey: ClientRuntime.Key("AvailabilityZoneId"))
        }
        if let availableInstanceCount = availableInstanceCount {
            try container.encode(availableInstanceCount, forKey: ClientRuntime.Key("AvailableInstanceCount"))
        }
        if let capacityAllocations = capacityAllocations {
            if !capacityAllocations.isEmpty {
                for (index0, capacityallocation0) in capacityAllocations.enumerated() {
                    var capacityAllocationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CapacityAllocationSet.\(index0.advanced(by: 1))"))
                    try capacityAllocationsContainer0.encode(capacityallocation0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let capacityReservationArn = capacityReservationArn {
            try container.encode(capacityReservationArn, forKey: ClientRuntime.Key("CapacityReservationArn"))
        }
        if let capacityReservationFleetId = capacityReservationFleetId {
            try container.encode(capacityReservationFleetId, forKey: ClientRuntime.Key("CapacityReservationFleetId"))
        }
        if let capacityReservationId = capacityReservationId {
            try container.encode(capacityReservationId, forKey: ClientRuntime.Key("CapacityReservationId"))
        }
        if let createDate = createDate {
            try container.encode(ClientRuntime.TimestampWrapper(createDate, format: .dateTime), forKey: ClientRuntime.Key("CreateDate"))
        }
        if let ebsOptimized = ebsOptimized {
            try container.encode(ebsOptimized, forKey: ClientRuntime.Key("EbsOptimized"))
        }
        if let endDate = endDate {
            try container.encode(ClientRuntime.TimestampWrapper(endDate, format: .dateTime), forKey: ClientRuntime.Key("EndDate"))
        }
        if let endDateType = endDateType {
            try container.encode(endDateType, forKey: ClientRuntime.Key("EndDateType"))
        }
        if let ephemeralStorage = ephemeralStorage {
            try container.encode(ephemeralStorage, forKey: ClientRuntime.Key("EphemeralStorage"))
        }
        if let instanceMatchCriteria = instanceMatchCriteria {
            try container.encode(instanceMatchCriteria, forKey: ClientRuntime.Key("InstanceMatchCriteria"))
        }
        if let instancePlatform = instancePlatform {
            try container.encode(instancePlatform, forKey: ClientRuntime.Key("InstancePlatform"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: ClientRuntime.Key("InstanceType"))
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: ClientRuntime.Key("OutpostArn"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: ClientRuntime.Key("OwnerId"))
        }
        if let placementGroupArn = placementGroupArn {
            try container.encode(placementGroupArn, forKey: ClientRuntime.Key("PlacementGroupArn"))
        }
        if let startDate = startDate {
            try container.encode(ClientRuntime.TimestampWrapper(startDate, format: .dateTime), forKey: ClientRuntime.Key("StartDate"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let tenancy = tenancy {
            try container.encode(tenancy, forKey: ClientRuntime.Key("Tenancy"))
        }
        if let totalInstanceCount = totalInstanceCount {
            try container.encode(totalInstanceCount, forKey: ClientRuntime.Key("TotalInstanceCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capacityReservationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationId)
        capacityReservationId = capacityReservationIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let capacityReservationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationArn)
        capacityReservationArn = capacityReservationArnDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let instancePlatformDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.CapacityReservationInstancePlatform.self, forKey: .instancePlatform)
        instancePlatform = instancePlatformDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.CapacityReservationTenancy.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let totalInstanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalInstanceCount)
        totalInstanceCount = totalInstanceCountDecoded
        let availableInstanceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableInstanceCount)
        availableInstanceCount = availableInstanceCountDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let ephemeralStorageDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ephemeralStorage)
        ephemeralStorage = ephemeralStorageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.CapacityReservationState.self, forKey: .state)
        state = stateDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        var startDateBuffer:ClientRuntime.Date? = nil
        if let startDateDecoded = startDateDecoded {
            startDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(startDateDecoded, format: .dateTime)
        }
        startDate = startDateBuffer
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        var endDateBuffer:ClientRuntime.Date? = nil
        if let endDateDecoded = endDateDecoded {
            endDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(endDateDecoded, format: .dateTime)
        }
        endDate = endDateBuffer
        let endDateTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.EndDateType.self, forKey: .endDateType)
        endDateType = endDateTypeDecoded
        let instanceMatchCriteriaDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.InstanceMatchCriteria.self, forKey: .instanceMatchCriteria)
        instanceMatchCriteria = instanceMatchCriteriaDecoded
        let createDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createDate)
        var createDateBuffer:ClientRuntime.Date? = nil
        if let createDateDecoded = createDateDecoded {
            createDateBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(createDateDecoded, format: .dateTime)
        }
        createDate = createDateBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[Ec2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Ec2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let capacityReservationFleetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capacityReservationFleetId)
        capacityReservationFleetId = capacityReservationFleetIdDecoded
        let placementGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .placementGroupArn)
        placementGroupArn = placementGroupArnDecoded
        if containerValues.contains(.capacityAllocations) {
            struct KeyVal0{struct item{}}
            let capacityAllocationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .capacityAllocations)
            if let capacityAllocationsWrappedContainer = capacityAllocationsWrappedContainer {
                let capacityAllocationsContainer = try capacityAllocationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.CapacityAllocation].self, forKey: .member)
                var capacityAllocationsBuffer:[Ec2ClientTypes.CapacityAllocation]? = nil
                if let capacityAllocationsContainer = capacityAllocationsContainer {
                    capacityAllocationsBuffer = [Ec2ClientTypes.CapacityAllocation]()
                    for structureContainer0 in capacityAllocationsContainer {
                        capacityAllocationsBuffer?.append(structureContainer0)
                    }
                }
                capacityAllocations = capacityAllocationsBuffer
            } else {
                capacityAllocations = []
            }
        } else {
            capacityAllocations = nil
        }
    }
}
