// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.InstanceRequirements: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceleratorCount = "acceleratorCount"
        case acceleratorManufacturers = "acceleratorManufacturerSet"
        case acceleratorNames = "acceleratorNameSet"
        case acceleratorTotalMemoryMiB = "acceleratorTotalMemoryMiB"
        case acceleratorTypes = "acceleratorTypeSet"
        case bareMetal = "bareMetal"
        case baselineEbsBandwidthMbps = "baselineEbsBandwidthMbps"
        case burstablePerformance = "burstablePerformance"
        case cpuManufacturers = "cpuManufacturerSet"
        case excludedInstanceTypes = "excludedInstanceTypeSet"
        case instanceGenerations = "instanceGenerationSet"
        case localStorage = "localStorage"
        case localStorageTypes = "localStorageTypeSet"
        case memoryGiBPerVCpu = "memoryGiBPerVCpu"
        case memoryMiB = "memoryMiB"
        case networkInterfaceCount = "networkInterfaceCount"
        case onDemandMaxPricePercentageOverLowestPrice = "onDemandMaxPricePercentageOverLowestPrice"
        case requireHibernateSupport = "requireHibernateSupport"
        case spotMaxPricePercentageOverLowestPrice = "spotMaxPricePercentageOverLowestPrice"
        case totalLocalStorageGB = "totalLocalStorageGB"
        case vCpuCount = "vCpuCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let acceleratorCount = acceleratorCount {
            try container.encode(acceleratorCount, forKey: ClientRuntime.Key("AcceleratorCount"))
        }
        if let acceleratorManufacturers = acceleratorManufacturers {
            if !acceleratorManufacturers.isEmpty {
                for (index0, acceleratormanufacturer0) in acceleratorManufacturers.enumerated() {
                    var acceleratorManufacturersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorManufacturerSet.\(index0.advanced(by: 1))"))
                    try acceleratorManufacturersContainer0.encode(acceleratormanufacturer0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let acceleratorNames = acceleratorNames {
            if !acceleratorNames.isEmpty {
                for (index0, acceleratorname0) in acceleratorNames.enumerated() {
                    var acceleratorNamesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorNameSet.\(index0.advanced(by: 1))"))
                    try acceleratorNamesContainer0.encode(acceleratorname0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB {
            try container.encode(acceleratorTotalMemoryMiB, forKey: ClientRuntime.Key("AcceleratorTotalMemoryMiB"))
        }
        if let acceleratorTypes = acceleratorTypes {
            if !acceleratorTypes.isEmpty {
                for (index0, acceleratortype0) in acceleratorTypes.enumerated() {
                    var acceleratorTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AcceleratorTypeSet.\(index0.advanced(by: 1))"))
                    try acceleratorTypesContainer0.encode(acceleratortype0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let bareMetal = bareMetal {
            try container.encode(bareMetal, forKey: ClientRuntime.Key("BareMetal"))
        }
        if let baselineEbsBandwidthMbps = baselineEbsBandwidthMbps {
            try container.encode(baselineEbsBandwidthMbps, forKey: ClientRuntime.Key("BaselineEbsBandwidthMbps"))
        }
        if let burstablePerformance = burstablePerformance {
            try container.encode(burstablePerformance, forKey: ClientRuntime.Key("BurstablePerformance"))
        }
        if let cpuManufacturers = cpuManufacturers {
            if !cpuManufacturers.isEmpty {
                for (index0, cpumanufacturer0) in cpuManufacturers.enumerated() {
                    var cpuManufacturersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("CpuManufacturerSet.\(index0.advanced(by: 1))"))
                    try cpuManufacturersContainer0.encode(cpumanufacturer0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let excludedInstanceTypes = excludedInstanceTypes {
            if !excludedInstanceTypes.isEmpty {
                for (index0, excludedinstancetype0) in excludedInstanceTypes.enumerated() {
                    var excludedInstanceTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ExcludedInstanceTypeSet.\(index0.advanced(by: 1))"))
                    try excludedInstanceTypesContainer0.encode(excludedinstancetype0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let instanceGenerations = instanceGenerations {
            if !instanceGenerations.isEmpty {
                for (index0, instancegeneration0) in instanceGenerations.enumerated() {
                    var instanceGenerationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("InstanceGenerationSet.\(index0.advanced(by: 1))"))
                    try instanceGenerationsContainer0.encode(instancegeneration0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let localStorage = localStorage {
            try container.encode(localStorage, forKey: ClientRuntime.Key("LocalStorage"))
        }
        if let localStorageTypes = localStorageTypes {
            if !localStorageTypes.isEmpty {
                for (index0, localstoragetype0) in localStorageTypes.enumerated() {
                    var localStorageTypesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LocalStorageTypeSet.\(index0.advanced(by: 1))"))
                    try localStorageTypesContainer0.encode(localstoragetype0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let memoryGiBPerVCpu = memoryGiBPerVCpu {
            try container.encode(memoryGiBPerVCpu, forKey: ClientRuntime.Key("MemoryGiBPerVCpu"))
        }
        if let memoryMiB = memoryMiB {
            try container.encode(memoryMiB, forKey: ClientRuntime.Key("MemoryMiB"))
        }
        if let networkInterfaceCount = networkInterfaceCount {
            try container.encode(networkInterfaceCount, forKey: ClientRuntime.Key("NetworkInterfaceCount"))
        }
        if let onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPrice {
            try container.encode(onDemandMaxPricePercentageOverLowestPrice, forKey: ClientRuntime.Key("OnDemandMaxPricePercentageOverLowestPrice"))
        }
        if let requireHibernateSupport = requireHibernateSupport {
            try container.encode(requireHibernateSupport, forKey: ClientRuntime.Key("RequireHibernateSupport"))
        }
        if let spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPrice {
            try container.encode(spotMaxPricePercentageOverLowestPrice, forKey: ClientRuntime.Key("SpotMaxPricePercentageOverLowestPrice"))
        }
        if let totalLocalStorageGB = totalLocalStorageGB {
            try container.encode(totalLocalStorageGB, forKey: ClientRuntime.Key("TotalLocalStorageGB"))
        }
        if let vCpuCount = vCpuCount {
            try container.encode(vCpuCount, forKey: ClientRuntime.Key("VCpuCount"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCpuCountDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.VCpuCountRange.self, forKey: .vCpuCount)
        vCpuCount = vCpuCountDecoded
        let memoryMiBDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.MemoryMiB.self, forKey: .memoryMiB)
        memoryMiB = memoryMiBDecoded
        if containerValues.contains(.cpuManufacturers) {
            struct KeyVal0{struct item{}}
            let cpuManufacturersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .cpuManufacturers)
            if let cpuManufacturersWrappedContainer = cpuManufacturersWrappedContainer {
                let cpuManufacturersContainer = try cpuManufacturersWrappedContainer.decodeIfPresent([Ec2ClientTypes.CpuManufacturer].self, forKey: .member)
                var cpuManufacturersBuffer:[Ec2ClientTypes.CpuManufacturer]? = nil
                if let cpuManufacturersContainer = cpuManufacturersContainer {
                    cpuManufacturersBuffer = [Ec2ClientTypes.CpuManufacturer]()
                    for enumContainer0 in cpuManufacturersContainer {
                        cpuManufacturersBuffer?.append(enumContainer0)
                    }
                }
                cpuManufacturers = cpuManufacturersBuffer
            } else {
                cpuManufacturers = []
            }
        } else {
            cpuManufacturers = nil
        }
        let memoryGiBPerVCpuDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.MemoryGiBPerVCpu.self, forKey: .memoryGiBPerVCpu)
        memoryGiBPerVCpu = memoryGiBPerVCpuDecoded
        if containerValues.contains(.excludedInstanceTypes) {
            struct KeyVal0{struct item{}}
            let excludedInstanceTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .excludedInstanceTypes)
            if let excludedInstanceTypesWrappedContainer = excludedInstanceTypesWrappedContainer {
                let excludedInstanceTypesContainer = try excludedInstanceTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var excludedInstanceTypesBuffer:[Swift.String]? = nil
                if let excludedInstanceTypesContainer = excludedInstanceTypesContainer {
                    excludedInstanceTypesBuffer = [Swift.String]()
                    for stringContainer0 in excludedInstanceTypesContainer {
                        excludedInstanceTypesBuffer?.append(stringContainer0)
                    }
                }
                excludedInstanceTypes = excludedInstanceTypesBuffer
            } else {
                excludedInstanceTypes = []
            }
        } else {
            excludedInstanceTypes = nil
        }
        if containerValues.contains(.instanceGenerations) {
            struct KeyVal0{struct item{}}
            let instanceGenerationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .instanceGenerations)
            if let instanceGenerationsWrappedContainer = instanceGenerationsWrappedContainer {
                let instanceGenerationsContainer = try instanceGenerationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.InstanceGeneration].self, forKey: .member)
                var instanceGenerationsBuffer:[Ec2ClientTypes.InstanceGeneration]? = nil
                if let instanceGenerationsContainer = instanceGenerationsContainer {
                    instanceGenerationsBuffer = [Ec2ClientTypes.InstanceGeneration]()
                    for enumContainer0 in instanceGenerationsContainer {
                        instanceGenerationsBuffer?.append(enumContainer0)
                    }
                }
                instanceGenerations = instanceGenerationsBuffer
            } else {
                instanceGenerations = []
            }
        } else {
            instanceGenerations = nil
        }
        let spotMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .spotMaxPricePercentageOverLowestPrice)
        spotMaxPricePercentageOverLowestPrice = spotMaxPricePercentageOverLowestPriceDecoded
        let onDemandMaxPricePercentageOverLowestPriceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandMaxPricePercentageOverLowestPrice)
        onDemandMaxPricePercentageOverLowestPrice = onDemandMaxPricePercentageOverLowestPriceDecoded
        let bareMetalDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.BareMetal.self, forKey: .bareMetal)
        bareMetal = bareMetalDecoded
        let burstablePerformanceDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.BurstablePerformance.self, forKey: .burstablePerformance)
        burstablePerformance = burstablePerformanceDecoded
        let requireHibernateSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .requireHibernateSupport)
        requireHibernateSupport = requireHibernateSupportDecoded
        let networkInterfaceCountDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.NetworkInterfaceCount.self, forKey: .networkInterfaceCount)
        networkInterfaceCount = networkInterfaceCountDecoded
        let localStorageDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LocalStorage.self, forKey: .localStorage)
        localStorage = localStorageDecoded
        if containerValues.contains(.localStorageTypes) {
            struct KeyVal0{struct item{}}
            let localStorageTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .localStorageTypes)
            if let localStorageTypesWrappedContainer = localStorageTypesWrappedContainer {
                let localStorageTypesContainer = try localStorageTypesWrappedContainer.decodeIfPresent([Ec2ClientTypes.LocalStorageType].self, forKey: .member)
                var localStorageTypesBuffer:[Ec2ClientTypes.LocalStorageType]? = nil
                if let localStorageTypesContainer = localStorageTypesContainer {
                    localStorageTypesBuffer = [Ec2ClientTypes.LocalStorageType]()
                    for enumContainer0 in localStorageTypesContainer {
                        localStorageTypesBuffer?.append(enumContainer0)
                    }
                }
                localStorageTypes = localStorageTypesBuffer
            } else {
                localStorageTypes = []
            }
        } else {
            localStorageTypes = nil
        }
        let totalLocalStorageGBDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.TotalLocalStorageGB.self, forKey: .totalLocalStorageGB)
        totalLocalStorageGB = totalLocalStorageGBDecoded
        let baselineEbsBandwidthMbpsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.BaselineEbsBandwidthMbps.self, forKey: .baselineEbsBandwidthMbps)
        baselineEbsBandwidthMbps = baselineEbsBandwidthMbpsDecoded
        if containerValues.contains(.acceleratorTypes) {
            struct KeyVal0{struct item{}}
            let acceleratorTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .acceleratorTypes)
            if let acceleratorTypesWrappedContainer = acceleratorTypesWrappedContainer {
                let acceleratorTypesContainer = try acceleratorTypesWrappedContainer.decodeIfPresent([Ec2ClientTypes.AcceleratorType].self, forKey: .member)
                var acceleratorTypesBuffer:[Ec2ClientTypes.AcceleratorType]? = nil
                if let acceleratorTypesContainer = acceleratorTypesContainer {
                    acceleratorTypesBuffer = [Ec2ClientTypes.AcceleratorType]()
                    for enumContainer0 in acceleratorTypesContainer {
                        acceleratorTypesBuffer?.append(enumContainer0)
                    }
                }
                acceleratorTypes = acceleratorTypesBuffer
            } else {
                acceleratorTypes = []
            }
        } else {
            acceleratorTypes = nil
        }
        let acceleratorCountDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AcceleratorCount.self, forKey: .acceleratorCount)
        acceleratorCount = acceleratorCountDecoded
        if containerValues.contains(.acceleratorManufacturers) {
            struct KeyVal0{struct item{}}
            let acceleratorManufacturersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .acceleratorManufacturers)
            if let acceleratorManufacturersWrappedContainer = acceleratorManufacturersWrappedContainer {
                let acceleratorManufacturersContainer = try acceleratorManufacturersWrappedContainer.decodeIfPresent([Ec2ClientTypes.AcceleratorManufacturer].self, forKey: .member)
                var acceleratorManufacturersBuffer:[Ec2ClientTypes.AcceleratorManufacturer]? = nil
                if let acceleratorManufacturersContainer = acceleratorManufacturersContainer {
                    acceleratorManufacturersBuffer = [Ec2ClientTypes.AcceleratorManufacturer]()
                    for enumContainer0 in acceleratorManufacturersContainer {
                        acceleratorManufacturersBuffer?.append(enumContainer0)
                    }
                }
                acceleratorManufacturers = acceleratorManufacturersBuffer
            } else {
                acceleratorManufacturers = []
            }
        } else {
            acceleratorManufacturers = nil
        }
        if containerValues.contains(.acceleratorNames) {
            struct KeyVal0{struct item{}}
            let acceleratorNamesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .acceleratorNames)
            if let acceleratorNamesWrappedContainer = acceleratorNamesWrappedContainer {
                let acceleratorNamesContainer = try acceleratorNamesWrappedContainer.decodeIfPresent([Ec2ClientTypes.AcceleratorName].self, forKey: .member)
                var acceleratorNamesBuffer:[Ec2ClientTypes.AcceleratorName]? = nil
                if let acceleratorNamesContainer = acceleratorNamesContainer {
                    acceleratorNamesBuffer = [Ec2ClientTypes.AcceleratorName]()
                    for enumContainer0 in acceleratorNamesContainer {
                        acceleratorNamesBuffer?.append(enumContainer0)
                    }
                }
                acceleratorNames = acceleratorNamesBuffer
            } else {
                acceleratorNames = []
            }
        } else {
            acceleratorNames = nil
        }
        let acceleratorTotalMemoryMiBDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AcceleratorTotalMemoryMiB.self, forKey: .acceleratorTotalMemoryMiB)
        acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiBDecoded
    }
}
