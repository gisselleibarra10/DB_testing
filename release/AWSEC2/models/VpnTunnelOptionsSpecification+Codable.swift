// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.VpnTunnelOptionsSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dPDTimeoutAction = "DPDTimeoutAction"
        case dPDTimeoutSeconds = "DPDTimeoutSeconds"
        case iKEVersions = "IKEVersion"
        case logOptions = "LogOptions"
        case phase1DHGroupNumbers = "Phase1DHGroupNumber"
        case phase1EncryptionAlgorithms = "Phase1EncryptionAlgorithm"
        case phase1IntegrityAlgorithms = "Phase1IntegrityAlgorithm"
        case phase1LifetimeSeconds = "Phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "Phase2DHGroupNumber"
        case phase2EncryptionAlgorithms = "Phase2EncryptionAlgorithm"
        case phase2IntegrityAlgorithms = "Phase2IntegrityAlgorithm"
        case phase2LifetimeSeconds = "Phase2LifetimeSeconds"
        case preSharedKey = "PreSharedKey"
        case rekeyFuzzPercentage = "RekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "RekeyMarginTimeSeconds"
        case replayWindowSize = "ReplayWindowSize"
        case startupAction = "StartupAction"
        case tunnelInsideCidr = "TunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "TunnelInsideIpv6Cidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dPDTimeoutAction = dPDTimeoutAction {
            try container.encode(dPDTimeoutAction, forKey: ClientRuntime.Key("DPDTimeoutAction"))
        }
        if let dPDTimeoutSeconds = dPDTimeoutSeconds {
            try container.encode(dPDTimeoutSeconds, forKey: ClientRuntime.Key("DPDTimeoutSeconds"))
        }
        if let iKEVersions = iKEVersions {
            if !iKEVersions.isEmpty {
                for (index0, ikeversionsrequestlistvalue0) in iKEVersions.enumerated() {
                    var iKEVersionsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("IKEVersion.\(index0.advanced(by: 1))"))
                    try iKEVersionsContainer0.encode(ikeversionsrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let logOptions = logOptions {
            try container.encode(logOptions, forKey: ClientRuntime.Key("LogOptions"))
        }
        if let phase1DHGroupNumbers = phase1DHGroupNumbers {
            if !phase1DHGroupNumbers.isEmpty {
                for (index0, phase1dhgroupnumbersrequestlistvalue0) in phase1DHGroupNumbers.enumerated() {
                    var phase1DHGroupNumbersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase1DHGroupNumber.\(index0.advanced(by: 1))"))
                    try phase1DHGroupNumbersContainer0.encode(phase1dhgroupnumbersrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase1EncryptionAlgorithms = phase1EncryptionAlgorithms {
            if !phase1EncryptionAlgorithms.isEmpty {
                for (index0, phase1encryptionalgorithmsrequestlistvalue0) in phase1EncryptionAlgorithms.enumerated() {
                    var phase1EncryptionAlgorithmsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase1EncryptionAlgorithm.\(index0.advanced(by: 1))"))
                    try phase1EncryptionAlgorithmsContainer0.encode(phase1encryptionalgorithmsrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase1IntegrityAlgorithms = phase1IntegrityAlgorithms {
            if !phase1IntegrityAlgorithms.isEmpty {
                for (index0, phase1integrityalgorithmsrequestlistvalue0) in phase1IntegrityAlgorithms.enumerated() {
                    var phase1IntegrityAlgorithmsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase1IntegrityAlgorithm.\(index0.advanced(by: 1))"))
                    try phase1IntegrityAlgorithmsContainer0.encode(phase1integrityalgorithmsrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase1LifetimeSeconds = phase1LifetimeSeconds {
            try container.encode(phase1LifetimeSeconds, forKey: ClientRuntime.Key("Phase1LifetimeSeconds"))
        }
        if let phase2DHGroupNumbers = phase2DHGroupNumbers {
            if !phase2DHGroupNumbers.isEmpty {
                for (index0, phase2dhgroupnumbersrequestlistvalue0) in phase2DHGroupNumbers.enumerated() {
                    var phase2DHGroupNumbersContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase2DHGroupNumber.\(index0.advanced(by: 1))"))
                    try phase2DHGroupNumbersContainer0.encode(phase2dhgroupnumbersrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase2EncryptionAlgorithms = phase2EncryptionAlgorithms {
            if !phase2EncryptionAlgorithms.isEmpty {
                for (index0, phase2encryptionalgorithmsrequestlistvalue0) in phase2EncryptionAlgorithms.enumerated() {
                    var phase2EncryptionAlgorithmsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase2EncryptionAlgorithm.\(index0.advanced(by: 1))"))
                    try phase2EncryptionAlgorithmsContainer0.encode(phase2encryptionalgorithmsrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase2IntegrityAlgorithms = phase2IntegrityAlgorithms {
            if !phase2IntegrityAlgorithms.isEmpty {
                for (index0, phase2integrityalgorithmsrequestlistvalue0) in phase2IntegrityAlgorithms.enumerated() {
                    var phase2IntegrityAlgorithmsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Phase2IntegrityAlgorithm.\(index0.advanced(by: 1))"))
                    try phase2IntegrityAlgorithmsContainer0.encode(phase2integrityalgorithmsrequestlistvalue0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let phase2LifetimeSeconds = phase2LifetimeSeconds {
            try container.encode(phase2LifetimeSeconds, forKey: ClientRuntime.Key("Phase2LifetimeSeconds"))
        }
        if let preSharedKey = preSharedKey {
            try container.encode(preSharedKey, forKey: ClientRuntime.Key("PreSharedKey"))
        }
        if let rekeyFuzzPercentage = rekeyFuzzPercentage {
            try container.encode(rekeyFuzzPercentage, forKey: ClientRuntime.Key("RekeyFuzzPercentage"))
        }
        if let rekeyMarginTimeSeconds = rekeyMarginTimeSeconds {
            try container.encode(rekeyMarginTimeSeconds, forKey: ClientRuntime.Key("RekeyMarginTimeSeconds"))
        }
        if let replayWindowSize = replayWindowSize {
            try container.encode(replayWindowSize, forKey: ClientRuntime.Key("ReplayWindowSize"))
        }
        if let startupAction = startupAction {
            try container.encode(startupAction, forKey: ClientRuntime.Key("StartupAction"))
        }
        if let tunnelInsideCidr = tunnelInsideCidr {
            try container.encode(tunnelInsideCidr, forKey: ClientRuntime.Key("TunnelInsideCidr"))
        }
        if let tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr {
            try container.encode(tunnelInsideIpv6Cidr, forKey: ClientRuntime.Key("TunnelInsideIpv6Cidr"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tunnelInsideCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelInsideCidr)
        tunnelInsideCidr = tunnelInsideCidrDecoded
        let tunnelInsideIpv6CidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tunnelInsideIpv6Cidr)
        tunnelInsideIpv6Cidr = tunnelInsideIpv6CidrDecoded
        let preSharedKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preSharedKey)
        preSharedKey = preSharedKeyDecoded
        let phase1LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase1LifetimeSeconds)
        phase1LifetimeSeconds = phase1LifetimeSecondsDecoded
        let phase2LifetimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .phase2LifetimeSeconds)
        phase2LifetimeSeconds = phase2LifetimeSecondsDecoded
        let rekeyMarginTimeSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyMarginTimeSeconds)
        rekeyMarginTimeSeconds = rekeyMarginTimeSecondsDecoded
        let rekeyFuzzPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rekeyFuzzPercentage)
        rekeyFuzzPercentage = rekeyFuzzPercentageDecoded
        let replayWindowSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replayWindowSize)
        replayWindowSize = replayWindowSizeDecoded
        let dPDTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dPDTimeoutSeconds)
        dPDTimeoutSeconds = dPDTimeoutSecondsDecoded
        let dPDTimeoutActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dPDTimeoutAction)
        dPDTimeoutAction = dPDTimeoutActionDecoded
        if containerValues.contains(.phase1EncryptionAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase1EncryptionAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1EncryptionAlgorithms)
            if let phase1EncryptionAlgorithmsWrappedContainer = phase1EncryptionAlgorithmsWrappedContainer {
                let phase1EncryptionAlgorithmsContainer = try phase1EncryptionAlgorithmsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase1EncryptionAlgorithmsRequestListValue].self, forKey: .member)
                var phase1EncryptionAlgorithmsBuffer:[Ec2ClientTypes.Phase1EncryptionAlgorithmsRequestListValue]? = nil
                if let phase1EncryptionAlgorithmsContainer = phase1EncryptionAlgorithmsContainer {
                    phase1EncryptionAlgorithmsBuffer = [Ec2ClientTypes.Phase1EncryptionAlgorithmsRequestListValue]()
                    for structureContainer0 in phase1EncryptionAlgorithmsContainer {
                        phase1EncryptionAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase1EncryptionAlgorithms = phase1EncryptionAlgorithmsBuffer
            } else {
                phase1EncryptionAlgorithms = []
            }
        } else {
            phase1EncryptionAlgorithms = nil
        }
        if containerValues.contains(.phase2EncryptionAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase2EncryptionAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2EncryptionAlgorithms)
            if let phase2EncryptionAlgorithmsWrappedContainer = phase2EncryptionAlgorithmsWrappedContainer {
                let phase2EncryptionAlgorithmsContainer = try phase2EncryptionAlgorithmsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase2EncryptionAlgorithmsRequestListValue].self, forKey: .member)
                var phase2EncryptionAlgorithmsBuffer:[Ec2ClientTypes.Phase2EncryptionAlgorithmsRequestListValue]? = nil
                if let phase2EncryptionAlgorithmsContainer = phase2EncryptionAlgorithmsContainer {
                    phase2EncryptionAlgorithmsBuffer = [Ec2ClientTypes.Phase2EncryptionAlgorithmsRequestListValue]()
                    for structureContainer0 in phase2EncryptionAlgorithmsContainer {
                        phase2EncryptionAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase2EncryptionAlgorithms = phase2EncryptionAlgorithmsBuffer
            } else {
                phase2EncryptionAlgorithms = []
            }
        } else {
            phase2EncryptionAlgorithms = nil
        }
        if containerValues.contains(.phase1IntegrityAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase1IntegrityAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1IntegrityAlgorithms)
            if let phase1IntegrityAlgorithmsWrappedContainer = phase1IntegrityAlgorithmsWrappedContainer {
                let phase1IntegrityAlgorithmsContainer = try phase1IntegrityAlgorithmsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase1IntegrityAlgorithmsRequestListValue].self, forKey: .member)
                var phase1IntegrityAlgorithmsBuffer:[Ec2ClientTypes.Phase1IntegrityAlgorithmsRequestListValue]? = nil
                if let phase1IntegrityAlgorithmsContainer = phase1IntegrityAlgorithmsContainer {
                    phase1IntegrityAlgorithmsBuffer = [Ec2ClientTypes.Phase1IntegrityAlgorithmsRequestListValue]()
                    for structureContainer0 in phase1IntegrityAlgorithmsContainer {
                        phase1IntegrityAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase1IntegrityAlgorithms = phase1IntegrityAlgorithmsBuffer
            } else {
                phase1IntegrityAlgorithms = []
            }
        } else {
            phase1IntegrityAlgorithms = nil
        }
        if containerValues.contains(.phase2IntegrityAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase2IntegrityAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2IntegrityAlgorithms)
            if let phase2IntegrityAlgorithmsWrappedContainer = phase2IntegrityAlgorithmsWrappedContainer {
                let phase2IntegrityAlgorithmsContainer = try phase2IntegrityAlgorithmsWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase2IntegrityAlgorithmsRequestListValue].self, forKey: .member)
                var phase2IntegrityAlgorithmsBuffer:[Ec2ClientTypes.Phase2IntegrityAlgorithmsRequestListValue]? = nil
                if let phase2IntegrityAlgorithmsContainer = phase2IntegrityAlgorithmsContainer {
                    phase2IntegrityAlgorithmsBuffer = [Ec2ClientTypes.Phase2IntegrityAlgorithmsRequestListValue]()
                    for structureContainer0 in phase2IntegrityAlgorithmsContainer {
                        phase2IntegrityAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase2IntegrityAlgorithms = phase2IntegrityAlgorithmsBuffer
            } else {
                phase2IntegrityAlgorithms = []
            }
        } else {
            phase2IntegrityAlgorithms = nil
        }
        if containerValues.contains(.phase1DHGroupNumbers) {
            struct KeyVal0{struct item{}}
            let phase1DHGroupNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1DHGroupNumbers)
            if let phase1DHGroupNumbersWrappedContainer = phase1DHGroupNumbersWrappedContainer {
                let phase1DHGroupNumbersContainer = try phase1DHGroupNumbersWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase1DHGroupNumbersRequestListValue].self, forKey: .member)
                var phase1DHGroupNumbersBuffer:[Ec2ClientTypes.Phase1DHGroupNumbersRequestListValue]? = nil
                if let phase1DHGroupNumbersContainer = phase1DHGroupNumbersContainer {
                    phase1DHGroupNumbersBuffer = [Ec2ClientTypes.Phase1DHGroupNumbersRequestListValue]()
                    for structureContainer0 in phase1DHGroupNumbersContainer {
                        phase1DHGroupNumbersBuffer?.append(structureContainer0)
                    }
                }
                phase1DHGroupNumbers = phase1DHGroupNumbersBuffer
            } else {
                phase1DHGroupNumbers = []
            }
        } else {
            phase1DHGroupNumbers = nil
        }
        if containerValues.contains(.phase2DHGroupNumbers) {
            struct KeyVal0{struct item{}}
            let phase2DHGroupNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2DHGroupNumbers)
            if let phase2DHGroupNumbersWrappedContainer = phase2DHGroupNumbersWrappedContainer {
                let phase2DHGroupNumbersContainer = try phase2DHGroupNumbersWrappedContainer.decodeIfPresent([Ec2ClientTypes.Phase2DHGroupNumbersRequestListValue].self, forKey: .member)
                var phase2DHGroupNumbersBuffer:[Ec2ClientTypes.Phase2DHGroupNumbersRequestListValue]? = nil
                if let phase2DHGroupNumbersContainer = phase2DHGroupNumbersContainer {
                    phase2DHGroupNumbersBuffer = [Ec2ClientTypes.Phase2DHGroupNumbersRequestListValue]()
                    for structureContainer0 in phase2DHGroupNumbersContainer {
                        phase2DHGroupNumbersBuffer?.append(structureContainer0)
                    }
                }
                phase2DHGroupNumbers = phase2DHGroupNumbersBuffer
            } else {
                phase2DHGroupNumbers = []
            }
        } else {
            phase2DHGroupNumbers = nil
        }
        if containerValues.contains(.iKEVersions) {
            struct KeyVal0{struct item{}}
            let iKEVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .iKEVersions)
            if let iKEVersionsWrappedContainer = iKEVersionsWrappedContainer {
                let iKEVersionsContainer = try iKEVersionsWrappedContainer.decodeIfPresent([Ec2ClientTypes.IKEVersionsRequestListValue].self, forKey: .member)
                var iKEVersionsBuffer:[Ec2ClientTypes.IKEVersionsRequestListValue]? = nil
                if let iKEVersionsContainer = iKEVersionsContainer {
                    iKEVersionsBuffer = [Ec2ClientTypes.IKEVersionsRequestListValue]()
                    for structureContainer0 in iKEVersionsContainer {
                        iKEVersionsBuffer?.append(structureContainer0)
                    }
                }
                iKEVersions = iKEVersionsBuffer
            } else {
                iKEVersions = []
            }
        } else {
            iKEVersions = nil
        }
        let startupActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startupAction)
        startupAction = startupActionDecoded
        let logOptionsDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.VpnTunnelLogOptionsSpecification.self, forKey: .logOptions)
        logOptions = logOptionsDecoded
    }
}
