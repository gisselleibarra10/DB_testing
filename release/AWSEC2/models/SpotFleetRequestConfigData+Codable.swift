// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Ec2ClientTypes.SpotFleetRequestConfigData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allocationStrategy = "allocationStrategy"
        case clientToken = "clientToken"
        case context = "context"
        case excessCapacityTerminationPolicy = "excessCapacityTerminationPolicy"
        case fulfilledCapacity = "fulfilledCapacity"
        case iamFleetRole = "iamFleetRole"
        case instanceInterruptionBehavior = "instanceInterruptionBehavior"
        case instancePoolsToUseCount = "instancePoolsToUseCount"
        case launchSpecifications = "launchSpecifications"
        case launchTemplateConfigs = "launchTemplateConfigs"
        case loadBalancersConfig = "loadBalancersConfig"
        case onDemandAllocationStrategy = "onDemandAllocationStrategy"
        case onDemandFulfilledCapacity = "onDemandFulfilledCapacity"
        case onDemandMaxTotalPrice = "onDemandMaxTotalPrice"
        case onDemandTargetCapacity = "onDemandTargetCapacity"
        case replaceUnhealthyInstances = "replaceUnhealthyInstances"
        case spotMaintenanceStrategies = "spotMaintenanceStrategies"
        case spotMaxTotalPrice = "spotMaxTotalPrice"
        case spotPrice = "spotPrice"
        case tagSpecifications = "TagSpecification"
        case targetCapacity = "targetCapacity"
        case targetCapacityUnitType = "targetCapacityUnitType"
        case terminateInstancesWithExpiration = "terminateInstancesWithExpiration"
        case type = "type"
        case validFrom = "validFrom"
        case validUntil = "validUntil"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let allocationStrategy = allocationStrategy {
            try container.encode(allocationStrategy, forKey: ClientRuntime.Key("AllocationStrategy"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: ClientRuntime.Key("ClientToken"))
        }
        if let context = context {
            try container.encode(context, forKey: ClientRuntime.Key("Context"))
        }
        if let excessCapacityTerminationPolicy = excessCapacityTerminationPolicy {
            try container.encode(excessCapacityTerminationPolicy, forKey: ClientRuntime.Key("ExcessCapacityTerminationPolicy"))
        }
        if let fulfilledCapacity = fulfilledCapacity {
            try container.encode(fulfilledCapacity, forKey: ClientRuntime.Key("FulfilledCapacity"))
        }
        if let iamFleetRole = iamFleetRole {
            try container.encode(iamFleetRole, forKey: ClientRuntime.Key("IamFleetRole"))
        }
        if let instanceInterruptionBehavior = instanceInterruptionBehavior {
            try container.encode(instanceInterruptionBehavior, forKey: ClientRuntime.Key("InstanceInterruptionBehavior"))
        }
        if let instancePoolsToUseCount = instancePoolsToUseCount {
            try container.encode(instancePoolsToUseCount, forKey: ClientRuntime.Key("InstancePoolsToUseCount"))
        }
        if let launchSpecifications = launchSpecifications {
            if !launchSpecifications.isEmpty {
                for (index0, spotfleetlaunchspecification0) in launchSpecifications.enumerated() {
                    var launchSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LaunchSpecifications.\(index0.advanced(by: 1))"))
                    try launchSpecificationsContainer0.encode(spotfleetlaunchspecification0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let launchTemplateConfigs = launchTemplateConfigs {
            if !launchTemplateConfigs.isEmpty {
                for (index0, launchtemplateconfig0) in launchTemplateConfigs.enumerated() {
                    var launchTemplateConfigsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LaunchTemplateConfigs.\(index0.advanced(by: 1))"))
                    try launchTemplateConfigsContainer0.encode(launchtemplateconfig0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let loadBalancersConfig = loadBalancersConfig {
            try container.encode(loadBalancersConfig, forKey: ClientRuntime.Key("LoadBalancersConfig"))
        }
        if let onDemandAllocationStrategy = onDemandAllocationStrategy {
            try container.encode(onDemandAllocationStrategy, forKey: ClientRuntime.Key("OnDemandAllocationStrategy"))
        }
        if let onDemandFulfilledCapacity = onDemandFulfilledCapacity {
            try container.encode(onDemandFulfilledCapacity, forKey: ClientRuntime.Key("OnDemandFulfilledCapacity"))
        }
        if let onDemandMaxTotalPrice = onDemandMaxTotalPrice {
            try container.encode(onDemandMaxTotalPrice, forKey: ClientRuntime.Key("OnDemandMaxTotalPrice"))
        }
        if let onDemandTargetCapacity = onDemandTargetCapacity {
            try container.encode(onDemandTargetCapacity, forKey: ClientRuntime.Key("OnDemandTargetCapacity"))
        }
        if let replaceUnhealthyInstances = replaceUnhealthyInstances {
            try container.encode(replaceUnhealthyInstances, forKey: ClientRuntime.Key("ReplaceUnhealthyInstances"))
        }
        if let spotMaintenanceStrategies = spotMaintenanceStrategies {
            try container.encode(spotMaintenanceStrategies, forKey: ClientRuntime.Key("SpotMaintenanceStrategies"))
        }
        if let spotMaxTotalPrice = spotMaxTotalPrice {
            try container.encode(spotMaxTotalPrice, forKey: ClientRuntime.Key("SpotMaxTotalPrice"))
        }
        if let spotPrice = spotPrice {
            try container.encode(spotPrice, forKey: ClientRuntime.Key("SpotPrice"))
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, tagspecification0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSpecification.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(tagspecification0, forKey: ClientRuntime.Key(""))
                }
            }
        }
        if let targetCapacity = targetCapacity {
            try container.encode(targetCapacity, forKey: ClientRuntime.Key("TargetCapacity"))
        }
        if let targetCapacityUnitType = targetCapacityUnitType {
            try container.encode(targetCapacityUnitType, forKey: ClientRuntime.Key("TargetCapacityUnitType"))
        }
        if let terminateInstancesWithExpiration = terminateInstancesWithExpiration {
            try container.encode(terminateInstancesWithExpiration, forKey: ClientRuntime.Key("TerminateInstancesWithExpiration"))
        }
        if let type = type {
            try container.encode(type, forKey: ClientRuntime.Key("Type"))
        }
        if let validFrom = validFrom {
            try container.encode(ClientRuntime.TimestampWrapper(validFrom, format: .dateTime), forKey: ClientRuntime.Key("ValidFrom"))
        }
        if let validUntil = validUntil {
            try container.encode(ClientRuntime.TimestampWrapper(validUntil, format: .dateTime), forKey: ClientRuntime.Key("ValidUntil"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allocationStrategyDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.AllocationStrategy.self, forKey: .allocationStrategy)
        allocationStrategy = allocationStrategyDecoded
        let onDemandAllocationStrategyDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.OnDemandAllocationStrategy.self, forKey: .onDemandAllocationStrategy)
        onDemandAllocationStrategy = onDemandAllocationStrategyDecoded
        let spotMaintenanceStrategiesDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.SpotMaintenanceStrategies.self, forKey: .spotMaintenanceStrategies)
        spotMaintenanceStrategies = spotMaintenanceStrategiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let excessCapacityTerminationPolicyDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.ExcessCapacityTerminationPolicy.self, forKey: .excessCapacityTerminationPolicy)
        excessCapacityTerminationPolicy = excessCapacityTerminationPolicyDecoded
        let fulfilledCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .fulfilledCapacity)
        fulfilledCapacity = fulfilledCapacityDecoded
        let onDemandFulfilledCapacityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .onDemandFulfilledCapacity)
        onDemandFulfilledCapacity = onDemandFulfilledCapacityDecoded
        let iamFleetRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamFleetRole)
        iamFleetRole = iamFleetRoleDecoded
        if containerValues.contains(.launchSpecifications) {
            struct KeyVal0{struct item{}}
            let launchSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .launchSpecifications)
            if let launchSpecificationsWrappedContainer = launchSpecificationsWrappedContainer {
                let launchSpecificationsContainer = try launchSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.SpotFleetLaunchSpecification].self, forKey: .member)
                var launchSpecificationsBuffer:[Ec2ClientTypes.SpotFleetLaunchSpecification]? = nil
                if let launchSpecificationsContainer = launchSpecificationsContainer {
                    launchSpecificationsBuffer = [Ec2ClientTypes.SpotFleetLaunchSpecification]()
                    for structureContainer0 in launchSpecificationsContainer {
                        launchSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                launchSpecifications = launchSpecificationsBuffer
            } else {
                launchSpecifications = []
            }
        } else {
            launchSpecifications = nil
        }
        if containerValues.contains(.launchTemplateConfigs) {
            struct KeyVal0{struct item{}}
            let launchTemplateConfigsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .launchTemplateConfigs)
            if let launchTemplateConfigsWrappedContainer = launchTemplateConfigsWrappedContainer {
                let launchTemplateConfigsContainer = try launchTemplateConfigsWrappedContainer.decodeIfPresent([Ec2ClientTypes.LaunchTemplateConfig].self, forKey: .member)
                var launchTemplateConfigsBuffer:[Ec2ClientTypes.LaunchTemplateConfig]? = nil
                if let launchTemplateConfigsContainer = launchTemplateConfigsContainer {
                    launchTemplateConfigsBuffer = [Ec2ClientTypes.LaunchTemplateConfig]()
                    for structureContainer0 in launchTemplateConfigsContainer {
                        launchTemplateConfigsBuffer?.append(structureContainer0)
                    }
                }
                launchTemplateConfigs = launchTemplateConfigsBuffer
            } else {
                launchTemplateConfigs = []
            }
        } else {
            launchTemplateConfigs = nil
        }
        let spotPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotPrice)
        spotPrice = spotPriceDecoded
        let targetCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetCapacity)
        targetCapacity = targetCapacityDecoded
        let onDemandTargetCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .onDemandTargetCapacity)
        onDemandTargetCapacity = onDemandTargetCapacityDecoded
        let onDemandMaxTotalPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandMaxTotalPrice)
        onDemandMaxTotalPrice = onDemandMaxTotalPriceDecoded
        let spotMaxTotalPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spotMaxTotalPrice)
        spotMaxTotalPrice = spotMaxTotalPriceDecoded
        let terminateInstancesWithExpirationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstancesWithExpiration)
        terminateInstancesWithExpiration = terminateInstancesWithExpirationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.FleetType.self, forKey: .type)
        type = typeDecoded
        let validFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validFrom)
        var validFromBuffer:ClientRuntime.Date? = nil
        if let validFromDecoded = validFromDecoded {
            validFromBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validFromDecoded, format: .dateTime)
        }
        validFrom = validFromBuffer
        let validUntilDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validUntil)
        var validUntilBuffer:ClientRuntime.Date? = nil
        if let validUntilDecoded = validUntilDecoded {
            validUntilBuffer = try ClientRuntime.TimestampWrapperDecoder.parseDateStringValue(validUntilDecoded, format: .dateTime)
        }
        validUntil = validUntilBuffer
        let replaceUnhealthyInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replaceUnhealthyInstances)
        replaceUnhealthyInstances = replaceUnhealthyInstancesDecoded
        let instanceInterruptionBehaviorDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.InstanceInterruptionBehavior.self, forKey: .instanceInterruptionBehavior)
        instanceInterruptionBehavior = instanceInterruptionBehaviorDecoded
        let loadBalancersConfigDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.LoadBalancersConfig.self, forKey: .loadBalancersConfig)
        loadBalancersConfig = loadBalancersConfigDecoded
        let instancePoolsToUseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .instancePoolsToUseCount)
        instancePoolsToUseCount = instancePoolsToUseCountDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .context)
        context = contextDecoded
        let targetCapacityUnitTypeDecoded = try containerValues.decodeIfPresent(Ec2ClientTypes.TargetCapacityUnitType.self, forKey: .targetCapacityUnitType)
        targetCapacityUnitType = targetCapacityUnitTypeDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct item{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([Ec2ClientTypes.TagSpecification].self, forKey: .member)
                var tagSpecificationsBuffer:[Ec2ClientTypes.TagSpecification]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [Ec2ClientTypes.TagSpecification]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
    }
}
