// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.Subnet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignIpv6AddressOnCreation = "assignIpv6AddressOnCreation"
        case availabilityZone = "availabilityZone"
        case availabilityZoneId = "availabilityZoneId"
        case availableIpAddressCount = "availableIpAddressCount"
        case cidrBlock = "cidrBlock"
        case customerOwnedIpv4Pool = "customerOwnedIpv4Pool"
        case defaultForAz = "defaultForAz"
        case enableDns64 = "enableDns64"
        case enableLniAtDeviceIndex = "enableLniAtDeviceIndex"
        case ipv6CidrBlockAssociationSet = "ipv6CidrBlockAssociationSet"
        case ipv6Native = "ipv6Native"
        case mapCustomerOwnedIpOnLaunch = "mapCustomerOwnedIpOnLaunch"
        case mapPublicIpOnLaunch = "mapPublicIpOnLaunch"
        case outpostArn = "outpostArn"
        case ownerId = "ownerId"
        case privateDnsNameOptionsOnLaunch = "privateDnsNameOptionsOnLaunch"
        case state = "state"
        case subnetArn = "subnetArn"
        case subnetId = "subnetId"
        case tags = "tagSet"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let assignIpv6AddressOnCreation = assignIpv6AddressOnCreation {
            try container.encode(assignIpv6AddressOnCreation, forKey: ClientRuntime.Key("AssignIpv6AddressOnCreation"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: ClientRuntime.Key("AvailabilityZone"))
        }
        if let availabilityZoneId = availabilityZoneId {
            try container.encode(availabilityZoneId, forKey: ClientRuntime.Key("AvailabilityZoneId"))
        }
        if let availableIpAddressCount = availableIpAddressCount {
            try container.encode(availableIpAddressCount, forKey: ClientRuntime.Key("AvailableIpAddressCount"))
        }
        if let cidrBlock = cidrBlock {
            try container.encode(cidrBlock, forKey: ClientRuntime.Key("CidrBlock"))
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: ClientRuntime.Key("CustomerOwnedIpv4Pool"))
        }
        if let defaultForAz = defaultForAz {
            try container.encode(defaultForAz, forKey: ClientRuntime.Key("DefaultForAz"))
        }
        if let enableDns64 = enableDns64 {
            try container.encode(enableDns64, forKey: ClientRuntime.Key("EnableDns64"))
        }
        if let enableLniAtDeviceIndex = enableLniAtDeviceIndex {
            try container.encode(enableLniAtDeviceIndex, forKey: ClientRuntime.Key("EnableLniAtDeviceIndex"))
        }
        if let ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSet {
            if !ipv6CidrBlockAssociationSet.isEmpty {
                for (index0, subnetipv6cidrblockassociation0) in ipv6CidrBlockAssociationSet.enumerated() {
                    var ipv6CidrBlockAssociationSetContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6CidrBlockAssociationSet.\(index0.advanced(by: 1))"))
                    try ipv6CidrBlockAssociationSetContainer0.encode(subnetipv6cidrblockassociation0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var ipv6CidrBlockAssociationSetContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Ipv6CidrBlockAssociationSet"))
                try ipv6CidrBlockAssociationSetContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let ipv6Native = ipv6Native {
            try container.encode(ipv6Native, forKey: ClientRuntime.Key("Ipv6Native"))
        }
        if let mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunch {
            try container.encode(mapCustomerOwnedIpOnLaunch, forKey: ClientRuntime.Key("MapCustomerOwnedIpOnLaunch"))
        }
        if let mapPublicIpOnLaunch = mapPublicIpOnLaunch {
            try container.encode(mapPublicIpOnLaunch, forKey: ClientRuntime.Key("MapPublicIpOnLaunch"))
        }
        if let outpostArn = outpostArn {
            try container.encode(outpostArn, forKey: ClientRuntime.Key("OutpostArn"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: ClientRuntime.Key("OwnerId"))
        }
        if let privateDnsNameOptionsOnLaunch = privateDnsNameOptionsOnLaunch {
            try container.encode(privateDnsNameOptionsOnLaunch, forKey: ClientRuntime.Key("PrivateDnsNameOptionsOnLaunch"))
        }
        if let state = state {
            try container.encode(state, forKey: ClientRuntime.Key("State"))
        }
        if let subnetArn = subnetArn {
            try container.encode(subnetArn, forKey: ClientRuntime.Key("SubnetArn"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: ClientRuntime.Key("SubnetId"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSet"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: ClientRuntime.Key("VpcId"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availableIpAddressCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .availableIpAddressCount)
        availableIpAddressCount = availableIpAddressCountDecoded
        let cidrBlockDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cidrBlock)
        cidrBlock = cidrBlockDecoded
        let defaultForAzDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultForAz)
        defaultForAz = defaultForAzDecoded
        let enableLniAtDeviceIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .enableLniAtDeviceIndex)
        enableLniAtDeviceIndex = enableLniAtDeviceIndexDecoded
        let mapPublicIpOnLaunchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapPublicIpOnLaunch)
        mapPublicIpOnLaunch = mapPublicIpOnLaunchDecoded
        let mapCustomerOwnedIpOnLaunchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mapCustomerOwnedIpOnLaunch)
        mapCustomerOwnedIpOnLaunch = mapCustomerOwnedIpOnLaunchDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.SubnetState.self, forKey: .state)
        state = stateDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let assignIpv6AddressOnCreationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignIpv6AddressOnCreation)
        assignIpv6AddressOnCreation = assignIpv6AddressOnCreationDecoded
        if containerValues.contains(.ipv6CidrBlockAssociationSet) {
            struct KeyVal0{struct item{}}
            let ipv6CidrBlockAssociationSetWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ipv6CidrBlockAssociationSet)
            if let ipv6CidrBlockAssociationSetWrappedContainer = ipv6CidrBlockAssociationSetWrappedContainer {
                let ipv6CidrBlockAssociationSetContainer = try ipv6CidrBlockAssociationSetWrappedContainer.decodeIfPresent([EC2ClientTypes.SubnetIpv6CidrBlockAssociation].self, forKey: .member)
                var ipv6CidrBlockAssociationSetBuffer:[EC2ClientTypes.SubnetIpv6CidrBlockAssociation]? = nil
                if let ipv6CidrBlockAssociationSetContainer = ipv6CidrBlockAssociationSetContainer {
                    ipv6CidrBlockAssociationSetBuffer = [EC2ClientTypes.SubnetIpv6CidrBlockAssociation]()
                    for structureContainer0 in ipv6CidrBlockAssociationSetContainer {
                        ipv6CidrBlockAssociationSetBuffer?.append(structureContainer0)
                    }
                }
                ipv6CidrBlockAssociationSet = ipv6CidrBlockAssociationSetBuffer
            } else {
                ipv6CidrBlockAssociationSet = []
            }
        } else {
            ipv6CidrBlockAssociationSet = nil
        }
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([EC2ClientTypes.Tag].self, forKey: .member)
                var tagsBuffer:[EC2ClientTypes.Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [EC2ClientTypes.Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let subnetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let enableDns64Decoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDns64)
        enableDns64 = enableDns64Decoded
        let ipv6NativeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ipv6Native)
        ipv6Native = ipv6NativeDecoded
        let privateDnsNameOptionsOnLaunchDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.PrivateDnsNameOptionsOnLaunch.self, forKey: .privateDnsNameOptionsOnLaunch)
        privateDnsNameOptionsOnLaunch = privateDnsNameOptionsOnLaunchDecoded
    }
}
