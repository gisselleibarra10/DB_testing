// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EC2ClientTypes.RequestLaunchTemplateData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings = "BlockDeviceMapping"
        case capacityReservationSpecification = "CapacityReservationSpecification"
        case cpuOptions = "CpuOptions"
        case creditSpecification = "CreditSpecification"
        case disableApiStop = "DisableApiStop"
        case disableApiTermination = "DisableApiTermination"
        case ebsOptimized = "EbsOptimized"
        case elasticGpuSpecifications = "ElasticGpuSpecification"
        case elasticInferenceAccelerators = "ElasticInferenceAccelerator"
        case enclaveOptions = "EnclaveOptions"
        case hibernationOptions = "HibernationOptions"
        case iamInstanceProfile = "IamInstanceProfile"
        case imageId = "ImageId"
        case instanceInitiatedShutdownBehavior = "InstanceInitiatedShutdownBehavior"
        case instanceMarketOptions = "InstanceMarketOptions"
        case instanceRequirements = "InstanceRequirements"
        case instanceType = "InstanceType"
        case kernelId = "KernelId"
        case keyName = "KeyName"
        case licenseSpecifications = "LicenseSpecification"
        case maintenanceOptions = "MaintenanceOptions"
        case metadataOptions = "MetadataOptions"
        case monitoring = "Monitoring"
        case networkInterfaces = "NetworkInterface"
        case placement = "Placement"
        case privateDnsNameOptions = "PrivateDnsNameOptions"
        case ramDiskId = "RamDiskId"
        case securityGroupIds = "SecurityGroupId"
        case securityGroups = "SecurityGroup"
        case tagSpecifications = "TagSpecification"
        case userData = "UserData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let blockDeviceMappings = blockDeviceMappings {
            if !blockDeviceMappings.isEmpty {
                for (index0, launchtemplateblockdevicemappingrequest0) in blockDeviceMappings.enumerated() {
                    var blockDeviceMappingsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMapping.\(index0.advanced(by: 1))"))
                    try blockDeviceMappingsContainer0.encode(launchtemplateblockdevicemappingrequest0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var blockDeviceMappingsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("BlockDeviceMapping"))
                try blockDeviceMappingsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let capacityReservationSpecification = capacityReservationSpecification {
            try container.encode(capacityReservationSpecification, forKey: ClientRuntime.Key("CapacityReservationSpecification"))
        }
        if let cpuOptions = cpuOptions {
            try container.encode(cpuOptions, forKey: ClientRuntime.Key("CpuOptions"))
        }
        if let creditSpecification = creditSpecification {
            try container.encode(creditSpecification, forKey: ClientRuntime.Key("CreditSpecification"))
        }
        if let disableApiStop = disableApiStop {
            try container.encode(disableApiStop, forKey: ClientRuntime.Key("DisableApiStop"))
        }
        if let disableApiTermination = disableApiTermination {
            try container.encode(disableApiTermination, forKey: ClientRuntime.Key("DisableApiTermination"))
        }
        if let ebsOptimized = ebsOptimized {
            try container.encode(ebsOptimized, forKey: ClientRuntime.Key("EbsOptimized"))
        }
        if let elasticGpuSpecifications = elasticGpuSpecifications {
            if !elasticGpuSpecifications.isEmpty {
                for (index0, elasticgpuspecification0) in elasticGpuSpecifications.enumerated() {
                    var elasticGpuSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticGpuSpecification.\(index0.advanced(by: 1))"))
                    try elasticGpuSpecificationsContainer0.encode(elasticgpuspecification0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var elasticGpuSpecificationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticGpuSpecification"))
                try elasticGpuSpecificationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let elasticInferenceAccelerators = elasticInferenceAccelerators {
            if !elasticInferenceAccelerators.isEmpty {
                for (index0, launchtemplateelasticinferenceaccelerator0) in elasticInferenceAccelerators.enumerated() {
                    var elasticInferenceAcceleratorsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticInferenceAccelerator.\(index0.advanced(by: 1))"))
                    try elasticInferenceAcceleratorsContainer0.encode(launchtemplateelasticinferenceaccelerator0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var elasticInferenceAcceleratorsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ElasticInferenceAccelerator"))
                try elasticInferenceAcceleratorsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let enclaveOptions = enclaveOptions {
            try container.encode(enclaveOptions, forKey: ClientRuntime.Key("EnclaveOptions"))
        }
        if let hibernationOptions = hibernationOptions {
            try container.encode(hibernationOptions, forKey: ClientRuntime.Key("HibernationOptions"))
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try container.encode(iamInstanceProfile, forKey: ClientRuntime.Key("IamInstanceProfile"))
        }
        if let imageId = imageId {
            try container.encode(imageId, forKey: ClientRuntime.Key("ImageId"))
        }
        if let instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehavior {
            try container.encode(instanceInitiatedShutdownBehavior, forKey: ClientRuntime.Key("InstanceInitiatedShutdownBehavior"))
        }
        if let instanceMarketOptions = instanceMarketOptions {
            try container.encode(instanceMarketOptions, forKey: ClientRuntime.Key("InstanceMarketOptions"))
        }
        if let instanceRequirements = instanceRequirements {
            try container.encode(instanceRequirements, forKey: ClientRuntime.Key("InstanceRequirements"))
        }
        if let instanceType = instanceType {
            try container.encode(instanceType, forKey: ClientRuntime.Key("InstanceType"))
        }
        if let kernelId = kernelId {
            try container.encode(kernelId, forKey: ClientRuntime.Key("KernelId"))
        }
        if let keyName = keyName {
            try container.encode(keyName, forKey: ClientRuntime.Key("KeyName"))
        }
        if let licenseSpecifications = licenseSpecifications {
            if !licenseSpecifications.isEmpty {
                for (index0, launchtemplatelicenseconfigurationrequest0) in licenseSpecifications.enumerated() {
                    var licenseSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LicenseSpecification.\(index0.advanced(by: 1))"))
                    try licenseSpecificationsContainer0.encode(launchtemplatelicenseconfigurationrequest0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var licenseSpecificationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("LicenseSpecification"))
                try licenseSpecificationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let maintenanceOptions = maintenanceOptions {
            try container.encode(maintenanceOptions, forKey: ClientRuntime.Key("MaintenanceOptions"))
        }
        if let metadataOptions = metadataOptions {
            try container.encode(metadataOptions, forKey: ClientRuntime.Key("MetadataOptions"))
        }
        if let monitoring = monitoring {
            try container.encode(monitoring, forKey: ClientRuntime.Key("Monitoring"))
        }
        if let networkInterfaces = networkInterfaces {
            if !networkInterfaces.isEmpty {
                for (index0, launchtemplateinstancenetworkinterfacespecificationrequest0) in networkInterfaces.enumerated() {
                    var networkInterfacesContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterface.\(index0.advanced(by: 1))"))
                    try networkInterfacesContainer0.encode(launchtemplateinstancenetworkinterfacespecificationrequest0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var networkInterfacesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NetworkInterface"))
                try networkInterfacesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let placement = placement {
            try container.encode(placement, forKey: ClientRuntime.Key("Placement"))
        }
        if let privateDnsNameOptions = privateDnsNameOptions {
            try container.encode(privateDnsNameOptions, forKey: ClientRuntime.Key("PrivateDnsNameOptions"))
        }
        if let ramDiskId = ramDiskId {
            try container.encode(ramDiskId, forKey: ClientRuntime.Key("RamDiskId"))
        }
        if let securityGroupIds = securityGroupIds {
            if !securityGroupIds.isEmpty {
                for (index0, securitygroupid0) in securityGroupIds.enumerated() {
                    var securityGroupIdsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroupId.\(index0.advanced(by: 1))"))
                    try securityGroupIdsContainer0.encode(securitygroupid0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var securityGroupIdsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroupId"))
                try securityGroupIdsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let securityGroups = securityGroups {
            if !securityGroups.isEmpty {
                for (index0, securitygroupname0) in securityGroups.enumerated() {
                    var securityGroupsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroup.\(index0.advanced(by: 1))"))
                    try securityGroupsContainer0.encode(securitygroupname0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var securityGroupsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("SecurityGroup"))
                try securityGroupsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let tagSpecifications = tagSpecifications {
            if !tagSpecifications.isEmpty {
                for (index0, launchtemplatetagspecificationrequest0) in tagSpecifications.enumerated() {
                    var tagSpecificationsContainer0 = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSpecification.\(index0.advanced(by: 1))"))
                    try tagSpecificationsContainer0.encode(launchtemplatetagspecificationrequest0, forKey: ClientRuntime.Key(""))
                }
            }
            else {
                var tagSpecificationsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagSpecification"))
                try tagSpecificationsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let userData = userData {
            try container.encode(userData, forKey: ClientRuntime.Key("UserData"))
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kernelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kernelId)
        kernelId = kernelIdDecoded
        let ebsOptimizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsOptimized)
        ebsOptimized = ebsOptimizedDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateIamInstanceProfileSpecificationRequest.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        if containerValues.contains(.blockDeviceMappings) {
            struct KeyVal0{struct BlockDeviceMapping{}}
            let blockDeviceMappingsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.BlockDeviceMapping>.CodingKeys.self, forKey: .blockDeviceMappings)
            if let blockDeviceMappingsWrappedContainer = blockDeviceMappingsWrappedContainer {
                let blockDeviceMappingsContainer = try blockDeviceMappingsWrappedContainer.decodeIfPresent([EC2ClientTypes.LaunchTemplateBlockDeviceMappingRequest].self, forKey: .member)
                var blockDeviceMappingsBuffer:[EC2ClientTypes.LaunchTemplateBlockDeviceMappingRequest]? = nil
                if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
                    blockDeviceMappingsBuffer = [EC2ClientTypes.LaunchTemplateBlockDeviceMappingRequest]()
                    for structureContainer0 in blockDeviceMappingsContainer {
                        blockDeviceMappingsBuffer?.append(structureContainer0)
                    }
                }
                blockDeviceMappings = blockDeviceMappingsBuffer
            } else {
                blockDeviceMappings = []
            }
        } else {
            blockDeviceMappings = nil
        }
        if containerValues.contains(.networkInterfaces) {
            struct KeyVal0{struct InstanceNetworkInterfaceSpecification{}}
            let networkInterfacesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InstanceNetworkInterfaceSpecification>.CodingKeys.self, forKey: .networkInterfaces)
            if let networkInterfacesWrappedContainer = networkInterfacesWrappedContainer {
                let networkInterfacesContainer = try networkInterfacesWrappedContainer.decodeIfPresent([EC2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest].self, forKey: .member)
                var networkInterfacesBuffer:[EC2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest]? = nil
                if let networkInterfacesContainer = networkInterfacesContainer {
                    networkInterfacesBuffer = [EC2ClientTypes.LaunchTemplateInstanceNetworkInterfaceSpecificationRequest]()
                    for structureContainer0 in networkInterfacesContainer {
                        networkInterfacesBuffer?.append(structureContainer0)
                    }
                }
                networkInterfaces = networkInterfacesBuffer
            } else {
                networkInterfaces = []
            }
        } else {
            networkInterfaces = nil
        }
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceType.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyName)
        keyName = keyNameDecoded
        let monitoringDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplatesMonitoringRequest.self, forKey: .monitoring)
        monitoring = monitoringDecoded
        let placementDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplatePlacementRequest.self, forKey: .placement)
        placement = placementDecoded
        let ramDiskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ramDiskId)
        ramDiskId = ramDiskIdDecoded
        let disableApiTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiTermination)
        disableApiTermination = disableApiTerminationDecoded
        let instanceInitiatedShutdownBehaviorDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.ShutdownBehavior.self, forKey: .instanceInitiatedShutdownBehavior)
        instanceInitiatedShutdownBehavior = instanceInitiatedShutdownBehaviorDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userData)
        userData = userDataDecoded
        if containerValues.contains(.tagSpecifications) {
            struct KeyVal0{struct LaunchTemplateTagSpecificationRequest{}}
            let tagSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LaunchTemplateTagSpecificationRequest>.CodingKeys.self, forKey: .tagSpecifications)
            if let tagSpecificationsWrappedContainer = tagSpecificationsWrappedContainer {
                let tagSpecificationsContainer = try tagSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.LaunchTemplateTagSpecificationRequest].self, forKey: .member)
                var tagSpecificationsBuffer:[EC2ClientTypes.LaunchTemplateTagSpecificationRequest]? = nil
                if let tagSpecificationsContainer = tagSpecificationsContainer {
                    tagSpecificationsBuffer = [EC2ClientTypes.LaunchTemplateTagSpecificationRequest]()
                    for structureContainer0 in tagSpecificationsContainer {
                        tagSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                tagSpecifications = tagSpecificationsBuffer
            } else {
                tagSpecifications = []
            }
        } else {
            tagSpecifications = nil
        }
        if containerValues.contains(.elasticGpuSpecifications) {
            struct KeyVal0{struct ElasticGpuSpecification{}}
            let elasticGpuSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ElasticGpuSpecification>.CodingKeys.self, forKey: .elasticGpuSpecifications)
            if let elasticGpuSpecificationsWrappedContainer = elasticGpuSpecificationsWrappedContainer {
                let elasticGpuSpecificationsContainer = try elasticGpuSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.ElasticGpuSpecification].self, forKey: .member)
                var elasticGpuSpecificationsBuffer:[EC2ClientTypes.ElasticGpuSpecification]? = nil
                if let elasticGpuSpecificationsContainer = elasticGpuSpecificationsContainer {
                    elasticGpuSpecificationsBuffer = [EC2ClientTypes.ElasticGpuSpecification]()
                    for structureContainer0 in elasticGpuSpecificationsContainer {
                        elasticGpuSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                elasticGpuSpecifications = elasticGpuSpecificationsBuffer
            } else {
                elasticGpuSpecifications = []
            }
        } else {
            elasticGpuSpecifications = nil
        }
        if containerValues.contains(.elasticInferenceAccelerators) {
            struct KeyVal0{struct item{}}
            let elasticInferenceAcceleratorsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .elasticInferenceAccelerators)
            if let elasticInferenceAcceleratorsWrappedContainer = elasticInferenceAcceleratorsWrappedContainer {
                let elasticInferenceAcceleratorsContainer = try elasticInferenceAcceleratorsWrappedContainer.decodeIfPresent([EC2ClientTypes.LaunchTemplateElasticInferenceAccelerator].self, forKey: .member)
                var elasticInferenceAcceleratorsBuffer:[EC2ClientTypes.LaunchTemplateElasticInferenceAccelerator]? = nil
                if let elasticInferenceAcceleratorsContainer = elasticInferenceAcceleratorsContainer {
                    elasticInferenceAcceleratorsBuffer = [EC2ClientTypes.LaunchTemplateElasticInferenceAccelerator]()
                    for structureContainer0 in elasticInferenceAcceleratorsContainer {
                        elasticInferenceAcceleratorsBuffer?.append(structureContainer0)
                    }
                }
                elasticInferenceAccelerators = elasticInferenceAcceleratorsBuffer
            } else {
                elasticInferenceAccelerators = []
            }
        } else {
            elasticInferenceAccelerators = nil
        }
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct SecurityGroupId{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroupId>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupIdsBuffer:[Swift.String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct SecurityGroup{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SecurityGroup>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var securityGroupsBuffer:[Swift.String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [Swift.String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let instanceMarketOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateInstanceMarketOptionsRequest.self, forKey: .instanceMarketOptions)
        instanceMarketOptions = instanceMarketOptionsDecoded
        let creditSpecificationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.CreditSpecificationRequest.self, forKey: .creditSpecification)
        creditSpecification = creditSpecificationDecoded
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateCpuOptionsRequest.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let capacityReservationSpecificationDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateCapacityReservationSpecificationRequest.self, forKey: .capacityReservationSpecification)
        capacityReservationSpecification = capacityReservationSpecificationDecoded
        if containerValues.contains(.licenseSpecifications) {
            struct KeyVal0{struct item{}}
            let licenseSpecificationsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .licenseSpecifications)
            if let licenseSpecificationsWrappedContainer = licenseSpecificationsWrappedContainer {
                let licenseSpecificationsContainer = try licenseSpecificationsWrappedContainer.decodeIfPresent([EC2ClientTypes.LaunchTemplateLicenseConfigurationRequest].self, forKey: .member)
                var licenseSpecificationsBuffer:[EC2ClientTypes.LaunchTemplateLicenseConfigurationRequest]? = nil
                if let licenseSpecificationsContainer = licenseSpecificationsContainer {
                    licenseSpecificationsBuffer = [EC2ClientTypes.LaunchTemplateLicenseConfigurationRequest]()
                    for structureContainer0 in licenseSpecificationsContainer {
                        licenseSpecificationsBuffer?.append(structureContainer0)
                    }
                }
                licenseSpecifications = licenseSpecificationsBuffer
            } else {
                licenseSpecifications = []
            }
        } else {
            licenseSpecifications = nil
        }
        let hibernationOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateHibernationOptionsRequest.self, forKey: .hibernationOptions)
        hibernationOptions = hibernationOptionsDecoded
        let metadataOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateInstanceMetadataOptionsRequest.self, forKey: .metadataOptions)
        metadataOptions = metadataOptionsDecoded
        let enclaveOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateEnclaveOptionsRequest.self, forKey: .enclaveOptions)
        enclaveOptions = enclaveOptionsDecoded
        let instanceRequirementsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.InstanceRequirementsRequest.self, forKey: .instanceRequirements)
        instanceRequirements = instanceRequirementsDecoded
        let privateDnsNameOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplatePrivateDnsNameOptionsRequest.self, forKey: .privateDnsNameOptions)
        privateDnsNameOptions = privateDnsNameOptionsDecoded
        let maintenanceOptionsDecoded = try containerValues.decodeIfPresent(EC2ClientTypes.LaunchTemplateInstanceMaintenanceOptionsRequest.self, forKey: .maintenanceOptions)
        maintenanceOptions = maintenanceOptionsDecoded
        let disableApiStopDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableApiStop)
        disableApiStop = disableApiStopDecoded
    }
}
