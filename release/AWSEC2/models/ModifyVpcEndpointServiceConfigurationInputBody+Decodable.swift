// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

struct ModifyVpcEndpointServiceConfigurationInputBody: Swift.Equatable {
    let dryRun: Swift.Bool?
    let serviceId: Swift.String?
    let privateDnsName: Swift.String?
    let removePrivateDnsName: Swift.Bool?
    let acceptanceRequired: Swift.Bool?
    let addNetworkLoadBalancerArns: [Swift.String]?
    let removeNetworkLoadBalancerArns: [Swift.String]?
    let addGatewayLoadBalancerArns: [Swift.String]?
    let removeGatewayLoadBalancerArns: [Swift.String]?
    let addSupportedIpAddressTypes: [Swift.String]?
    let removeSupportedIpAddressTypes: [Swift.String]?
}

extension ModifyVpcEndpointServiceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptanceRequired = "AcceptanceRequired"
        case addGatewayLoadBalancerArns = "AddGatewayLoadBalancerArn"
        case addNetworkLoadBalancerArns = "AddNetworkLoadBalancerArn"
        case addSupportedIpAddressTypes = "AddSupportedIpAddressType"
        case dryRun = "DryRun"
        case privateDnsName = "PrivateDnsName"
        case removeGatewayLoadBalancerArns = "RemoveGatewayLoadBalancerArn"
        case removeNetworkLoadBalancerArns = "RemoveNetworkLoadBalancerArn"
        case removePrivateDnsName = "RemovePrivateDnsName"
        case removeSupportedIpAddressTypes = "RemoveSupportedIpAddressType"
        case serviceId = "ServiceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let removePrivateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .removePrivateDnsName)
        removePrivateDnsName = removePrivateDnsNameDecoded
        let acceptanceRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .acceptanceRequired)
        acceptanceRequired = acceptanceRequiredDecoded
        if containerValues.contains(.addNetworkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let addNetworkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .addNetworkLoadBalancerArns)
            if let addNetworkLoadBalancerArnsWrappedContainer = addNetworkLoadBalancerArnsWrappedContainer {
                let addNetworkLoadBalancerArnsContainer = try addNetworkLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var addNetworkLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let addNetworkLoadBalancerArnsContainer = addNetworkLoadBalancerArnsContainer {
                    addNetworkLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in addNetworkLoadBalancerArnsContainer {
                        addNetworkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                addNetworkLoadBalancerArns = addNetworkLoadBalancerArnsBuffer
            } else {
                addNetworkLoadBalancerArns = []
            }
        } else {
            addNetworkLoadBalancerArns = nil
        }
        if containerValues.contains(.removeNetworkLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let removeNetworkLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .removeNetworkLoadBalancerArns)
            if let removeNetworkLoadBalancerArnsWrappedContainer = removeNetworkLoadBalancerArnsWrappedContainer {
                let removeNetworkLoadBalancerArnsContainer = try removeNetworkLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var removeNetworkLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let removeNetworkLoadBalancerArnsContainer = removeNetworkLoadBalancerArnsContainer {
                    removeNetworkLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in removeNetworkLoadBalancerArnsContainer {
                        removeNetworkLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                removeNetworkLoadBalancerArns = removeNetworkLoadBalancerArnsBuffer
            } else {
                removeNetworkLoadBalancerArns = []
            }
        } else {
            removeNetworkLoadBalancerArns = nil
        }
        if containerValues.contains(.addGatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let addGatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .addGatewayLoadBalancerArns)
            if let addGatewayLoadBalancerArnsWrappedContainer = addGatewayLoadBalancerArnsWrappedContainer {
                let addGatewayLoadBalancerArnsContainer = try addGatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var addGatewayLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let addGatewayLoadBalancerArnsContainer = addGatewayLoadBalancerArnsContainer {
                    addGatewayLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in addGatewayLoadBalancerArnsContainer {
                        addGatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                addGatewayLoadBalancerArns = addGatewayLoadBalancerArnsBuffer
            } else {
                addGatewayLoadBalancerArns = []
            }
        } else {
            addGatewayLoadBalancerArns = nil
        }
        if containerValues.contains(.removeGatewayLoadBalancerArns) {
            struct KeyVal0{struct item{}}
            let removeGatewayLoadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .removeGatewayLoadBalancerArns)
            if let removeGatewayLoadBalancerArnsWrappedContainer = removeGatewayLoadBalancerArnsWrappedContainer {
                let removeGatewayLoadBalancerArnsContainer = try removeGatewayLoadBalancerArnsWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var removeGatewayLoadBalancerArnsBuffer:[Swift.String]? = nil
                if let removeGatewayLoadBalancerArnsContainer = removeGatewayLoadBalancerArnsContainer {
                    removeGatewayLoadBalancerArnsBuffer = [Swift.String]()
                    for stringContainer0 in removeGatewayLoadBalancerArnsContainer {
                        removeGatewayLoadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                removeGatewayLoadBalancerArns = removeGatewayLoadBalancerArnsBuffer
            } else {
                removeGatewayLoadBalancerArns = []
            }
        } else {
            removeGatewayLoadBalancerArns = nil
        }
        if containerValues.contains(.addSupportedIpAddressTypes) {
            struct KeyVal0{struct item{}}
            let addSupportedIpAddressTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .addSupportedIpAddressTypes)
            if let addSupportedIpAddressTypesWrappedContainer = addSupportedIpAddressTypesWrappedContainer {
                let addSupportedIpAddressTypesContainer = try addSupportedIpAddressTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var addSupportedIpAddressTypesBuffer:[Swift.String]? = nil
                if let addSupportedIpAddressTypesContainer = addSupportedIpAddressTypesContainer {
                    addSupportedIpAddressTypesBuffer = [Swift.String]()
                    for stringContainer0 in addSupportedIpAddressTypesContainer {
                        addSupportedIpAddressTypesBuffer?.append(stringContainer0)
                    }
                }
                addSupportedIpAddressTypes = addSupportedIpAddressTypesBuffer
            } else {
                addSupportedIpAddressTypes = []
            }
        } else {
            addSupportedIpAddressTypes = nil
        }
        if containerValues.contains(.removeSupportedIpAddressTypes) {
            struct KeyVal0{struct item{}}
            let removeSupportedIpAddressTypesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .removeSupportedIpAddressTypes)
            if let removeSupportedIpAddressTypesWrappedContainer = removeSupportedIpAddressTypesWrappedContainer {
                let removeSupportedIpAddressTypesContainer = try removeSupportedIpAddressTypesWrappedContainer.decodeIfPresent([Swift.String].self, forKey: .member)
                var removeSupportedIpAddressTypesBuffer:[Swift.String]? = nil
                if let removeSupportedIpAddressTypesContainer = removeSupportedIpAddressTypesContainer {
                    removeSupportedIpAddressTypesBuffer = [Swift.String]()
                    for stringContainer0 in removeSupportedIpAddressTypesContainer {
                        removeSupportedIpAddressTypesBuffer?.append(stringContainer0)
                    }
                }
                removeSupportedIpAddressTypes = removeSupportedIpAddressTypesBuffer
            } else {
                removeSupportedIpAddressTypes = []
            }
        } else {
            removeSupportedIpAddressTypes = nil
        }
    }
}
