// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EcrClientTypes.PackageVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
        case vulnerabilityId
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvssscorelist0 in cvss {
                try cvssContainer.encode(cvssscorelist0)
            }
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for referenceurlslist0 in referenceUrls {
                try referenceUrlsContainer.encode(referenceurlslist0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for relatedvulnerabilitieslist0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(relatedvulnerabilitieslist0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encode(vendorCreatedAt.timeIntervalSince1970, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encode(vendorUpdatedAt.timeIntervalSince1970, forKey: .vendorUpdatedAt)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for vulnerablepackageslist0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(vulnerablepackageslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cvssContainer = try containerValues.decodeIfPresent([EcrClientTypes.CvssScore?].self, forKey: .cvss)
        var cvssDecoded0:[EcrClientTypes.CvssScore]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [EcrClientTypes.CvssScore]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([EcrClientTypes.VulnerablePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[EcrClientTypes.VulnerablePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [EcrClientTypes.VulnerablePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
    }
}
