// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime
import AWSClientRuntime

extension StartStreamTranscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentIdentificationTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-content-identification-type") {
            self.contentIdentificationType = TranscribeStreamingClientTypes.ContentIdentificationType(rawValue: contentIdentificationTypeHeaderValue)
        } else {
            self.contentIdentificationType = nil
        }
        if let contentRedactionTypeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-content-redaction-type") {
            self.contentRedactionType = TranscribeStreamingClientTypes.ContentRedactionType(rawValue: contentRedactionTypeHeaderValue)
        } else {
            self.contentRedactionType = nil
        }
        if let enableChannelIdentificationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-channel-identification") {
            self.enableChannelIdentification = Swift.Bool(enableChannelIdentificationHeaderValue) ?? false
        } else {
            self.enableChannelIdentification = false
        }
        if let enablePartialResultsStabilizationHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-enable-partial-results-stabilization") {
            self.enablePartialResultsStabilization = Swift.Bool(enablePartialResultsStabilizationHeaderValue) ?? false
        } else {
            self.enablePartialResultsStabilization = false
        }
        if let identifyLanguageHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-identify-language") {
            self.identifyLanguage = Swift.Bool(identifyLanguageHeaderValue) ?? false
        } else {
            self.identifyLanguage = false
        }
        if let languageCodeHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-code") {
            self.languageCode = TranscribeStreamingClientTypes.LanguageCode(rawValue: languageCodeHeaderValue)
        } else {
            self.languageCode = nil
        }
        if let languageModelNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-model-name") {
            self.languageModelName = languageModelNameHeaderValue
        } else {
            self.languageModelName = nil
        }
        if let languageOptionsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-language-options") {
            self.languageOptions = languageOptionsHeaderValue
        } else {
            self.languageOptions = nil
        }
        if let mediaEncodingHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-media-encoding") {
            self.mediaEncoding = TranscribeStreamingClientTypes.MediaEncoding(rawValue: mediaEncodingHeaderValue)
        } else {
            self.mediaEncoding = nil
        }
        if let mediaSampleRateHertzHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-sample-rate") {
            self.mediaSampleRateHertz = Swift.Int(mediaSampleRateHertzHeaderValue) ?? 0
        } else {
            self.mediaSampleRateHertz = nil
        }
        if let numberOfChannelsHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-number-of-channels") {
            self.numberOfChannels = Swift.Int(numberOfChannelsHeaderValue) ?? 0
        } else {
            self.numberOfChannels = nil
        }
        if let partialResultsStabilityHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-partial-results-stability") {
            self.partialResultsStability = TranscribeStreamingClientTypes.PartialResultsStability(rawValue: partialResultsStabilityHeaderValue)
        } else {
            self.partialResultsStability = nil
        }
        if let piiEntityTypesHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-pii-entity-types") {
            self.piiEntityTypes = piiEntityTypesHeaderValue
        } else {
            self.piiEntityTypes = nil
        }
        if let preferredLanguageHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-preferred-language") {
            self.preferredLanguage = TranscribeStreamingClientTypes.LanguageCode(rawValue: preferredLanguageHeaderValue)
        } else {
            self.preferredLanguage = nil
        }
        if let requestIdHeaderValue = httpResponse.headers.value(for: "x-amzn-request-id") {
            self.requestId = requestIdHeaderValue
        } else {
            self.requestId = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let showSpeakerLabelHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-show-speaker-label") {
            self.showSpeakerLabel = Swift.Bool(showSpeakerLabelHeaderValue) ?? false
        } else {
            self.showSpeakerLabel = false
        }
        if let vocabularyFilterMethodHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-method") {
            self.vocabularyFilterMethod = TranscribeStreamingClientTypes.VocabularyFilterMethod(rawValue: vocabularyFilterMethodHeaderValue)
        } else {
            self.vocabularyFilterMethod = nil
        }
        if let vocabularyFilterNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-name") {
            self.vocabularyFilterName = vocabularyFilterNameHeaderValue
        } else {
            self.vocabularyFilterName = nil
        }
        if let vocabularyFilterNamesHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-filter-names") {
            self.vocabularyFilterNames = vocabularyFilterNamesHeaderValue
        } else {
            self.vocabularyFilterNames = nil
        }
        if let vocabularyNameHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-name") {
            self.vocabularyName = vocabularyNameHeaderValue
        } else {
            self.vocabularyName = nil
        }
        if let vocabularyNamesHeaderValue = httpResponse.headers.value(for: "x-amzn-transcribe-vocabulary-names") {
            self.vocabularyNames = vocabularyNamesHeaderValue
        } else {
            self.vocabularyNames = nil
        }
        switch httpResponse.body {
        case .data(_):
            fatalError()
        case .stream(let stream):
            switch stream {
            case .buffer(_):
                fatalError()
            case .reader(let reader):
                guard let messageDecoder = decoder?.messageDecoder else {
                    fatalError()
                }
                let stream = AsyncThrowingStream<TranscribeStreamingClientTypes.TranscriptResultStream, Error> { continuation in
                    Task {
                        while !reader.hasFinishedWriting {
                            let messageBuffer = AWSMessageDecoder.readMessage(streamReader: reader)
                            let message = try await messageDecoder.decode(data: messageBuffer)
                            guard let decoder = decoder else {
                                fatalError()
                            }
                            let event = try TranscribeStreamingClientTypes.TranscriptResultStream(message: message, decoder: decoder)
                            continuation.yield(event)
                        }
                    }
                }
                self.transcriptResultStream = AsyncResponseStream(stream)
            }
        case .channel(_):
            fatalError()
        case .none:
            fatalError()
        }
    }
}

extension TranscribeStreamingClientTypes.TranscriptResultStream: MessageUnmarshaller {
    public init(message: ClientRuntime.Message, decoder: ResponseDecoder) throws {
        switch message.type {
        case .event(let params):
            switch params.eventType {
            case "TranscriptEvent":
                self = try decoder.decode(responseBody: message.payload)
            default:
                fatalError()
            }
        case .exception(let params):
            fatalError()
            break
        case .error(let params):
            throw TranscribeStreamingError(errorCode: params.errorCode, message: params.message)
        }
    }
}

struct TranscribeStreamingError: Error {
    let errorCode: String
    let message: String?
}
