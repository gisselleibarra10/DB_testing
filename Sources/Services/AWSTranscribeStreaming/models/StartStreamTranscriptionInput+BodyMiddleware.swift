// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime
import AwsCommonRuntimeKit
import AWSClientRuntime
import Foundation.NSISO8601DateFormatter


public struct StartStreamTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            guard let region = context.getRegion(), let signingRegion = context.getSigningRegion(), let signingName = context.getSigningName() else {
                fatalError()
            }
            guard let messageEncoder = encoder.messageEncoder else {
                fatalError()
            }
//            let messageSigner = context.getMessageSigner()
            
            let signatureCalculator = DefaultSignatureCalculator(sha256Provider: Sha256HashFunction())

            if let audioStream = input.operationInput.audioStream {
//                let messages: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data> = audioStream.map { stream -> Data in
//                    let message = try stream.marshall(encoder: encoder)
//                    let signedMessage = try messageSigner.sign(message: message)
//                    let encodedMessage = try messageEncoder.encode(message: signedMessage)
//                    return encodedMessage
//                }
                
                guard let credentialsProvider = context.getCredentialsProvider() else {
                   fatalError()
                }
                
                    let internalStream = FooBar(stream: AsyncThrowingStream<Data, Error> { continuation in
                    Task {
                        if #available(macOS 13.0, *) {
                            try await Task.sleep(for: .seconds(1))
                        } else {
                            // Fallback on earlier versions
                        }
                        var previousMessageSignature = HttpContext.signature.data(using: .utf8)!
                        for try await event in audioStream {
                            // convert event to Message
                            let message = try event.marshall(encoder: encoder)

                            let encodedMessage = try messageEncoder.encode(message: message)

                            let now = Date()
//                            let signingConfig = await makeTrailingSigningConfig(service: signingName,
//                                                                          signatureType: .requestChunk,
//                                                                          region: region,
//                                                                          date: now,
//                                                                          credentials: try credentialsProvider.getCredentials().toCRTType())
//
//                            let canonicalString = try cannonicalString(date: now, priorSignature: previousMessageSignature, nonSignatureHeaders: nonSignatureHeaders(date: now), payload: encodedMessage, region: region, service: signingName)
//                            let signature = try await Signer.signChunk(chunk: canonicalString.data(using: .utf8)!, previousSignature: previousMessageSignature, config: signingConfig)
//                            print("message signature: \(signature)")
                            let signingConfig = SigningConfigV2(signingDate: now, signatureType: .requestEvent, region: region, service: signingName)
                            let stringToSign = try signatureCalculator.chunkStringToSign(chunkBody: encodedMessage, prevSignature: previousMessageSignature, config: signingConfig)
                            print(stringToSign)
                            let credentials = try await credentialsProvider.getCredentials().toCRTType()
                            
                            let signingKey = signatureCalculator.signingKey(config: signingConfig, credentials: .init(accessKeyId: credentials.getAccessKey()!, secretAccessKey: credentials.getAccessKey()!, sessionToken: credentials.getSessionToken()))
                            let signature =  signatureCalculator.calculate(signingKey: signingKey, stringToSign: stringToSign)
                            var signHeaders: [EventStreams.Header] = []
                            signHeaders.append(.init(name: ":chunk-signature", value: .byteBuffer(signature.hexaData)))
//                            signHeaders.append(messag)
                            
                            signHeaders.append(.init(name: ":date", value: .timestamp(now)))
                            let messageWithSig = EventStreams.Message(headers: signHeaders, payload: encodedMessage)
                            
                            let encodedMessageWithSig = try messageEncoder.encode(message: messageWithSig)
                            continuation.yield(encodedMessageWithSig)
                            
                            if #available(macOS 13.0, *) {
                                try await Task.sleep(for: .seconds(1))
                            } else {
                                // Fallback on earlier versions
                            }
                            
                            previousMessageSignature = signature.data(using: .utf8)!
                        }
                        
                        let now = Date()
//                        let signingConfig = await makeTrailingSigningConfig(service: signingName,
//                                                                      signatureType: .requestTrailingHeaders,
//                                                                      region: region,
//                                                                      date: now,
//                                                                      credentials: try credentialsProvider.getCredentials().toCRTType())
//
//                        let canonicalString = try cannonicalString(date: now, priorSignature: previousMessageSignature, nonSignatureHeaders: nonSignatureHeaders(date: now), payload: .init(), region: region, service: signingName)
//                        let signature = try await Signer.signChunk(chunk: canonicalString.data(using: .utf8)!, previousSignature: previousMessageSignature, config: signingConfig)
//                        print("message signature: \(signature)")
                        
                        let signingConfig = SigningConfigV2(signingDate: now, signatureType: .requestEvent, region: region, service: signingName)
                        let stringToSign = try signatureCalculator.chunkStringToSign(chunkBody: .init(), prevSignature: previousMessageSignature, config: signingConfig)
                        print(stringToSign)
                        let credentials = try await credentialsProvider.getCredentials().toCRTType()
                        let signingKey = signatureCalculator.signingKey(config: signingConfig, credentials: .init(accessKeyId: credentials.getAccessKey()!, secretAccessKey: credentials.getAccessKey()!, sessionToken: credentials.getSessionToken()))
                        let signature =  signatureCalculator.calculate(signingKey: signingKey, stringToSign: stringToSign)
                        
                        var signHeaders: [EventStreams.Header] = []
                        
                        let rawSign = Data(signature.hexaBytes)
                        signHeaders.append(.init(name: ":chunk-signature", value: .byteBuffer(signature.hexaData)))
                        
                        signHeaders.append(.init(name: ":date", value: .timestamp(now)))
                        let messageWithSig = EventStreams.Message(headers: signHeaders, payload: Data())
                        
                        let encodedMessageWithSig = try messageEncoder.encode(message: messageWithSig)
                        continuation.yield(encodedMessageWithSig)
                        
                        previousMessageSignature = signature.data(using: .utf8)!

                        continuation.finish()
                    }
                })

                input.builder.withBody(HttpBody.stream(.reader(internalStream)))
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let audioStreamdata = "{}".data(using: .utf8)!
                    let audioStreambody = ClientRuntime.HttpBody.data(audioStreamdata)
                }
            }
        } catch let err {
            throw SdkError<StartStreamTranscriptionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

func makeTrailingSigningConfig(service: String, signatureType: SignatureType, region: String, date: Date, credentials: Credentials) -> SigningConfig {
    SigningConfig(
        algorithm: .signingV4,
        signatureType: signatureType,
        service: service,
        region: region,
        date: date,
        credentials: credentials,
        useDoubleURIEncode: false)
}


/*
String stringToSign =
"AWS4-HMAC-SHA256" +
"\n" +
DateTime +
"\n" +
Keypath +
"\n" +
Hex(priorSignature) +
"\n" +
HexHash(nonSignatureHeaders) +
"\n" +
HexHash(payload);
*/


public class FooBar: IStreamable, StreamReader {

    
    public var availableForRead: UInt
    
    public var hasFinishedWriting: Bool
    
    public func read(maxBytes: UInt?, rewind: Bool) -> AwsCommonRuntimeKit.ByteBuffer {
        do {
            let result = try _unsafeWait {
                await self.read(maxBytes: maxBytes, rewind: rewind)
            }
            return result
        } catch {
            fatalError()
        }
    }
    
    public func read(maxBytes: UInt?, rewind: Bool) async -> AwsCommonRuntimeKit.ByteBuffer {
        var iterator = stream.makeAsyncIterator()
        guard let data = try! await iterator.next() else {
            return ByteBuffer(data: Data())
        }
        return ByteBuffer(data: data)
    }
    
    public func onError(error: ClientRuntime.ClientError) {
        fatalError()
    }
    
    public func write(buffer: AwsCommonRuntimeKit.ByteBuffer) {
        fatalError()
    }
    
    public func seek(offset: Int) {
        fatalError()
    }

    let stream: AsyncThrowingStream<Data, Error>
    
    init(stream: AsyncThrowingStream<Data, Error>) {
        self.stream = stream
        self.availableForRead = 1
        self.hasFinishedWriting = false
    }
    
    public func seek(offset: Int64, streamSeekType: AwsCommonRuntimeKit.StreamSeekType) throws {
        switch streamSeekType {
        case .begin:
            break
        case .end:
            break
        }
    }

    public func read(buffer: UnsafeMutableBufferPointer<UInt8>) throws -> Int? {
        let data = self.read(maxBytes: UInt(buffer.count), rewind: false).getData()
        data.copyBytes(to: buffer, count: data.count)
        print("sending: \(data)")
        return data.count == 0 ? nil : data.count
    }
}


extension TranscribeStreamingClientTypes.AudioStream: MessageMarshaller {
    public func marshall(encoder: RequestEncoder) throws -> EventStreams.Message {
        var headers: [EventStreams.Header] = []
        var payload = Data()

        switch self {
        case .audioevent(let data):
            headers.append(.init(name: ":event-type", value: .string("AudioEvent")))
            headers.append(.init(name: ":content-type", value: .string("application/vnd.amazon.eventstream")))
            if let audioChunk = data.audioChunk {
                payload = audioChunk
            }
        case .configurationevent(let data):
            headers.append(.init(name: ":event-type", value: .string("ConfigurationEvent")))
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(data)
        case .sdkUnknown(_):
            fatalError()
        }
        return EventStreams.Message(headers: headers, payload: payload)
    }
}
