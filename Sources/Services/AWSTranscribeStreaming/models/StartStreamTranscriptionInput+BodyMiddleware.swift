// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime
import AwsCommonRuntimeKit
import AWSClientRuntime
import Foundation.NSISO8601DateFormatter


public struct StartStreamTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            guard let region = context.getRegion(), let signingRegion = context.getSigningRegion(), let signingName = context.getSigningName() else {
                fatalError()
            }
//            guard let messageEncoder = encoder.messageEncoder else {
//                fatalError()
//            }
//            let messageSigner = context.getMessageSigner()
            
//            let signatureCalculator = DefaultSignatureCalculator(sha256Provider: Sha256HashFunction())

            if let audioStream = input.operationInput.audioStream {
//                let messages: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data> = audioStream.map { stream -> Data in
//                    let message = try stream.marshall(encoder: encoder)
//                    let signedMessage = try messageSigner.sign(message: message)
//                    let encodedMessage = try messageEncoder.encode(message: signedMessage)
//                    return encodedMessage
//                }
                
                guard let credentialsProvider = context.getCredentialsProvider() else {
                   fatalError()
                }
                
                    let internalStream = AsyncThrowingStream<Data, Error> { continuation in
                        Task {
                            if #available(macOS 13.0, *) {
                                try await Task.sleep(for: .seconds(5))
                            } else {
                                // Fallback on earlier versions
                            }
                            var prevSignature = HttpContext.signature!.data(using: .utf8)!
                            for try await event in audioStream {
                                // convert event to Message
                                let message = try event.marshall(encoder: encoder)

                                let messagePayload = try message.encode()
                                let epoch = Date()
                                let signingConfig = await AWSSigningConfig(credentials: try credentialsProvider.getCredentials(),
                                                                     signedBodyValue: .emptySha256,
                                                                     flags: .init(useDoubleURIEncode: false, shouldNormalizeURIPath: false, omitSessionToken: false),
                                                                     date: Date(),
                                                                     service: signingName,
                                                                     region: region,
                                                                     signatureType: .requestEvent,
                                                                     signingAlgorithm: .sigv4)
                                
                                let result = try! await AWSSigV4Signer.signPayload(payload: messagePayload, prevSignture: prevSignature, config: signingConfig, signingDate: epoch)
                                
                                let final = try result.output.encode()
                                continuation.yield(final)
                                
                                prevSignature = result.signature
                            }

                            let messagePayload = Data()
                            let epoch = Date()
                            let signingConfig = await AWSSigningConfig(credentials: try credentialsProvider.getCredentials(),
                                                                 signedBodyValue: .emptySha256,
                                                                 flags: .init(useDoubleURIEncode: false, shouldNormalizeURIPath: false, omitSessionToken: false),
                                                                 date: Date(),
                                                                 service: signingName,
                                                                 region: region,
                                                                 signatureType: .requestEvent,
                                                                 signingAlgorithm: .sigv4)
                            
                            let result = try! await AWSSigV4Signer.signPayload(payload: messagePayload, prevSignture: prevSignature, config: signingConfig, signingDate: epoch)
                            let final = try result.output.encode()
                            continuation.yield(final)
                            
                            prevSignature = result.signature

                            continuation.finish()
                        }
                    }

                input.builder.withBody(HttpBody.asyncThrowingStream(internalStream))
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let audioStreamdata = "{}".data(using: .utf8)!
                    let audioStreambody = ClientRuntime.HttpBody.data(audioStreamdata)
                }
            }
        } catch let err {
            throw SdkError<StartStreamTranscriptionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

func makeTrailingSigningConfig(service: String, signatureType: SignatureType, region: String, date: Date, credentials: Credentials) -> SigningConfig {
    SigningConfig(
        algorithm: .signingV4,
        signatureType: signatureType,
        service: service,
        region: region,
        date: date,
        credentials: credentials,
        useDoubleURIEncode: false)
}

public class ContentStream: IStreamable, StreamReader {
    private let lock = NSLock()

    
    public var availableForRead: UInt {
        get {
            withLockingClosure {
                return _availableForRead
            }
        }
        set {
            withLockingClosure {
                _availableForRead = newValue
            }
        }
    }
    
    private func withLockingClosure<T>(closure: () -> T) -> T {
        lock.lock()
        defer {
            lock.unlock()
        }
        return closure()
    }

    
    
    private var _availableForRead: UInt
    public var hasFinishedWriting: Bool
    
    public func read(maxBytes: UInt?, rewind: Bool) -> AwsCommonRuntimeKit.ByteBuffer {
        do {
            let result = try _unsafeWait {
                return await self.readIntenral(maxBytes: maxBytes, rewind: rewind)
            }
            return result
        } catch {
            fatalError()
        }
    }
    
    public func readIntenral(maxBytes: UInt?, rewind: Bool) async -> AwsCommonRuntimeKit.ByteBuffer {
        var iterator = stream.makeAsyncIterator()
        guard let data = try! await iterator.next() else {
            return ByteBuffer(data: Data())
        }
        return ByteBuffer(data: data)
    }
    
    public func onError(error: ClientRuntime.ClientError) {
        fatalError()
    }
    
    public func write(buffer: AwsCommonRuntimeKit.ByteBuffer) {
        fatalError()
    }
    
    public func seek(offset: Int) {
        fatalError()
    }

    let stream: AsyncThrowingStream<Data, Error>
    
    init(stream: AsyncThrowingStream<Data, Error>) {
        self.stream = stream
        self.hasFinishedWriting = true
        self._availableForRead = 0
    }
    
    public func seek(offset: Int64, streamSeekType: AwsCommonRuntimeKit.StreamSeekType) throws {
        switch streamSeekType {
        case .begin:
            break
        case .end:
            break
        }
    }

    public func read(buffer: UnsafeMutableBufferPointer<UInt8>) throws -> Int? {
        let data = self.read(maxBytes: UInt(buffer.count), rewind: false).getData()
        data.copyBytes(to: buffer, count: data.count)
        print("sending: \(data)")
        return data.count == 0 ? nil : data.count
    }
}


extension TranscribeStreamingClientTypes.AudioStream: MessageMarshaller {
    public func marshall(encoder: RequestEncoder) throws -> EventStreams.Message {
        var headers: [EventStreams.Header] = []
        headers.append(.init(name: ":message-type", value: .string("event")))
        var payload = Data()

        switch self {
        case .audioevent(let data):
            headers.append(.init(name: ":event-type", value: .string("AudioEvent")))
            headers.append(.init(name: ":content-type", value: .string("application/octet-stream")))
            if let audioChunk = data.audioChunk {
                payload = audioChunk
            }
        case .configurationevent(let data):
            headers.append(.init(name: ":event-type", value: .string("ConfigurationEvent")))
            headers.append(.init(name: ":content-type", value: .string("application/json")))
            payload = try encoder.encode(data)
        case .sdkUnknown(_):
            fatalError()
        }
        return EventStreams.Message(headers: headers, payload: payload)
    }
}
