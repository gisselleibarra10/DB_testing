// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime
import AwsCommonRuntimeKit
import AWSClientRuntime


public struct StartStreamTranscriptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartStreamTranscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            guard let messageEncoder = encoder.messageEncoder else {
                fatalError()
            }
//            let messageSigner = context.getMessageSigner()
            
            

            if let audioStream = input.operationInput.audioStream {
//                let messages: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data> = audioStream.map { stream -> Data in
//                    let message = try stream.marshall(encoder: encoder)
//                    let signedMessage = try messageSigner.sign(message: message)
//                    let encodedMessage = try messageEncoder.encode(message: signedMessage)
//                    return encodedMessage
//                }
                
                let messages: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data> = audioStream.map { event in
                    let requestSignature = HttpContext.signature
                    
                    guard let credentialsProvider = context.getCredentialsProvider() else {
                       fatalError()
                    }
                    
                    var previousMessageSignature: String? = nil
                    var message = try event.marshall(encoder: encoder)
                    let now = Date()
                    let signingConfig = await AWSSigningConfig(credentials: try credentialsProvider.getCredentials(), signedBodyValue: .streamingSha256Events, flags: .init(useDoubleURIEncode: false, shouldNormalizeURIPath: true, omitSessionToken: true), date: now, service: "transcribe", region: "us-west-2", signatureType: .requestChunk, signingAlgorithm: .sigv4)
                    
                    let messageSignature = try await Signer.signChunk(chunk: message.payload, previousSignature: previousMessageSignature ?? requestSignature, config: signingConfig.toCRTType())
                    message.headers.add(.init(name: ":chunk-signature", value: messageSignature))
                    
                    let formatter = TimestampFormatter(format: .dateTime)
                    message.headers.add(.init(name: ":date", value: formatter.string(from: now)))
                    let encodedMessage = try messageEncoder.encode(message: message)
                    
                    previousMessageSignature = messageSignature
                    return encodedMessage
                }

                let internalStream = FooBar(stream: messages)
                input.builder.withBody(HttpBody.stream(.reader(internalStream)))
            } else {
                if encoder is JSONEncoder {
                    // Encode an empty body as an empty structure in JSON
                    let audioStreamdata = "{}".data(using: .utf8)!
                    let audioStreambody = ClientRuntime.HttpBody.data(audioStreamdata)
                }
            }
        } catch let err {
            throw SdkError<StartStreamTranscriptionOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartStreamTranscriptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartStreamTranscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

public class FooBar: IStreamable, StreamReader {

    
    public var availableForRead: UInt
    
    public var hasFinishedWriting: Bool
    
    public func read(maxBytes: UInt?, rewind: Bool) -> AwsCommonRuntimeKit.ByteBuffer {
        do {
            let result = try _unsafeWait {
                await self.read(maxBytes: maxBytes, rewind: rewind)
            }
            return result
        } catch {
            fatalError()
        }
    }
    
    public func read(maxBytes: UInt?, rewind: Bool) async -> AwsCommonRuntimeKit.ByteBuffer {
        var data = Data()
        let maxBytes = maxBytes ?? UInt.max
        var remaining = maxBytes
        var iterator = stream.makeAsyncIterator()
        while remaining > 0 {
            do {
                let next = try await iterator.next()
                if let next = next {
                    data.append(next)
                    remaining -= UInt(next.count)
                } else {
                    break
                }
            } catch {
                print(error)
                fatalError()
            }
        }
        return ByteBuffer(data: data)
    }
    
    public func onError(error: ClientRuntime.ClientError) {
        fatalError()
    }
    
    public func write(buffer: AwsCommonRuntimeKit.ByteBuffer) {
        fatalError()
    }
    
    public func seek(offset: Int) {
        fatalError()
    }

    let stream: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data>
    
    init(stream: AsyncThrowingMapSequence<AsyncRequestStream<TranscribeStreamingClientTypes.AudioStream>, Data>) {
        self.stream = stream
        self.availableForRead = 1
        self.hasFinishedWriting = false
    }
    
    public func seek(offset: Int64, streamSeekType: AwsCommonRuntimeKit.StreamSeekType) throws {
        switch streamSeekType {
        case .begin:
            break
        case .end:
            break
        }
    }

    public func read(buffer: UnsafeMutableBufferPointer<UInt8>) throws -> Int? {
        let data = self.read(maxBytes: UInt(buffer.count), rewind: false).getData()
        data.copyBytes(to: buffer, count: data.count)
        return data.count
    }
}


extension TranscribeStreamingClientTypes.AudioStream: MessageMarshaller {
    public func marshall(encoder: RequestEncoder) throws -> ClientRuntime.Message {
        var headers = Headers()
        var payload = Data()

        switch self {
        case .audioevent(let data):
            headers.add(name: ":event-type", value: "AudioEvent")
            headers.add(name: ":content-type", value: "application/octet-stream")
            if let audioChunk = data.audioChunk {
                payload = audioChunk
            }
        case .configurationevent(let data):
            headers.add(name: ":event-type", value: "ConfigurationEvent")
            headers.add(name: ":content-type", value: "application/json")
            payload = try encoder.encode(data)
        case .sdkUnknown(_):
            fatalError()
        }
        return Message(headers: headers, payload: payload)
    }
}
