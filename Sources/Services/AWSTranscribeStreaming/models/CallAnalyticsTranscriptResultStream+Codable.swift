// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TranscribeStreamingClientTypes.CallAnalyticsTranscriptResultStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case badrequestexception = "BadRequestException"
        case categoryevent = "CategoryEvent"
        case conflictexception = "ConflictException"
        case internalfailureexception = "InternalFailureException"
        case limitexceededexception = "LimitExceededException"
        case serviceunavailableexception = "ServiceUnavailableException"
        case utteranceevent = "UtteranceEvent"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .badrequestexception(badrequestexception):
                try container.encode(badrequestexception, forKey: .badrequestexception)
            case let .categoryevent(categoryevent):
                try container.encode(categoryevent, forKey: .categoryevent)
            case let .conflictexception(conflictexception):
                try container.encode(conflictexception, forKey: .conflictexception)
            case let .internalfailureexception(internalfailureexception):
                try container.encode(internalfailureexception, forKey: .internalfailureexception)
            case let .limitexceededexception(limitexceededexception):
                try container.encode(limitexceededexception, forKey: .limitexceededexception)
            case let .serviceunavailableexception(serviceunavailableexception):
                try container.encode(serviceunavailableexception, forKey: .serviceunavailableexception)
            case let .utteranceevent(utteranceevent):
                try container.encode(utteranceevent, forKey: .utteranceevent)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let utteranceeventDecoded = try values.decodeIfPresent(TranscribeStreamingClientTypes.UtteranceEvent.self, forKey: .utteranceevent)
        if let utteranceevent = utteranceeventDecoded {
            self = .utteranceevent(utteranceevent)
            return
        }
        let categoryeventDecoded = try values.decodeIfPresent(TranscribeStreamingClientTypes.CategoryEvent.self, forKey: .categoryevent)
        if let categoryevent = categoryeventDecoded {
            self = .categoryevent(categoryevent)
            return
        }
        let badrequestexceptionDecoded = try values.decodeIfPresent(BadRequestException.self, forKey: .badrequestexception)
        if let badrequestexception = badrequestexceptionDecoded {
            self = .badrequestexception(badrequestexception)
            return
        }
        let limitexceededexceptionDecoded = try values.decodeIfPresent(LimitExceededException.self, forKey: .limitexceededexception)
        if let limitexceededexception = limitexceededexceptionDecoded {
            self = .limitexceededexception(limitexceededexception)
            return
        }
        let internalfailureexceptionDecoded = try values.decodeIfPresent(InternalFailureException.self, forKey: .internalfailureexception)
        if let internalfailureexception = internalfailureexceptionDecoded {
            self = .internalfailureexception(internalfailureexception)
            return
        }
        let conflictexceptionDecoded = try values.decodeIfPresent(ConflictException.self, forKey: .conflictexception)
        if let conflictexception = conflictexceptionDecoded {
            self = .conflictexception(conflictexception)
            return
        }
        let serviceunavailableexceptionDecoded = try values.decodeIfPresent(ServiceUnavailableException.self, forKey: .serviceunavailableexception)
        if let serviceunavailableexception = serviceunavailableexceptionDecoded {
            self = .serviceunavailableexception(serviceunavailableexception)
            return
        }
        self = .sdkUnknown("")
    }
}
